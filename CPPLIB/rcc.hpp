#pragma once
#include "common.hpp"

#if !defined(UNUSED)
#define UNUSED(x) ((void)(x))
#endif

#if !defined  (HSE_VALUE)
#if defined(RCC_VER_X) || defined(RCC_VER_3_0)
#define HSE_VALUE    25000000U  /*!< Value of the HSE oscillator in Hz */
#else
#define HSE_VALUE    24000000U  /*!< Value of the HSE oscillator in Hz */
#endif /* RCC_VER_X || RCC_VER_3_0 */
#endif /* HSE_VALUE */

#if !defined  (HSI_VALUE)
#define HSI_VALUE    64000000U  /*!< Value of the HSI oscillator in Hz */
#endif /* HSI_VALUE */

#if !defined  (CSI_VALUE)
#define CSI_VALUE    4000000U   /*!< Value of the CSI oscillator in Hz */
#endif /* CSI_VALUE */

#if !defined  (LSE_VALUE)
#define LSE_VALUE    32768U     /*!< Value of the LSE oscillator in Hz */
#endif /* LSE_VALUE */

#if !defined  (LSI_VALUE)
#define LSI_VALUE    32000U     /*!< Value of the LSI oscillator in Hz */
#endif /* LSI_VALUE */

#if !defined  (EXTERNAL_CLOCK_VALUE)
#define EXTERNAL_CLOCK_VALUE    12288000U /*!< Value of the I2S_CKIN external oscillator in Hz */
#endif /* EXTERNAL_CLOCK_VALUE */

#if !defined  (HSI48_VALUE)
#define HSI48_VALUE  48000000U  /*!< Value of the HSI48 oscillator in Hz */
#endif /* HSI48_VALUE */

/* 32            24           16            8             0
   --------------------------------------------------------
   | Mask        | ClkSource   |  Bit       | Register    |
   |             |  Config     | Position   | Offset      |
   --------------------------------------------------------*/
#if defined(RCC_VER_2_0)
/* Clock source register offset Vs CDCCIPR register */
#define CDCCIP    0x0UL
#define CDCCIP1   0x4UL
#define CDCCIP2   0x8UL
#define SRDCCIP   0xCUL
#else
/* Clock source register offset Vs D1CCIPR register */
#define D1CCIP    0x0UL
#define D2CCIP1   0x4UL
#define D2CCIP2   0x8UL
#define D3CCIP    0xCUL
#endif /* RCC_VER_2_0 */

#define RCC_REG_SHIFT     0U
#define RCC_POS_SHIFT     8U
#define RCC_CONFIG_SHIFT  16U
#define RCC_MASK_SHIFT    24U

#define CLKSOURCE_SHIFT(__CLKSOURCE__)   (((__CLKSOURCE__) >> RCC_POS_SHIFT   ) & 0x1FUL)

#define CLKSOURCE_MASK(__CLKSOURCE__)   ((((__CLKSOURCE__) >> RCC_MASK_SHIFT  ) & 0xFFUL) << CLKSOURCE_SHIFT(__CLKSOURCE__))

#define CLKSOURCE_CONFIG(__CLKSOURCE__) ((((__CLKSOURCE__) >> RCC_CONFIG_SHIFT) & 0xFFUL) << CLKSOURCE_SHIFT(__CLKSOURCE__))

#define CLKSOURCE_REG(__CLKSOURCE__)     (((__CLKSOURCE__) >> RCC_REG_SHIFT   ) & 0xFFUL)

#define CLKSOURCE(__REG__, __MSK__, __POS__, __CLK__) ((uint32_t)((((__MSK__) >> (__POS__)) << RCC_MASK_SHIFT) | \
                                                                     (( __POS__              ) << RCC_POS_SHIFT)  | \
                                                                     (( __REG__              ) << RCC_REG_SHIFT)  | \
                                                                     (((__CLK__) >> (__POS__)) << RCC_CONFIG_SHIFT)))

#define RCC_PERIPH_FREQUENCY_NO         0x00000000U                 /*!< No clock enabled for the peripheral            */
#define RCC_PERIPH_FREQUENCY_NA         0xFFFFFFFFU                 /*!< Frequency cannot be provided as external clock */


struct RCCClocksTypeDef
{
    uint32_t SYSCLK_Frequency;
    uint32_t CPUCLK_Frequency;
    uint32_t HCLK_Frequency;
    uint32_t PCLK1_Frequency;
    uint32_t PCLK2_Frequency;
    uint32_t PCLK3_Frequency;
    uint32_t PCLK4_Frequency;
};

/**
  * @brief  PLL Clocks Frequency Structure
  */
struct PLLClocksTypeDef
{
    uint32_t PLL_P_Frequency;
    uint32_t PLL_Q_Frequency;
    uint32_t PLL_R_Frequency;
} ;

/** @defgroup RCC_EC_HSIDIV  HSI oscillator divider
  * @{
  */
enum RCCHSIOscillatorDivider
{
    RCC_HSI_DIV1         =          RCC_CR_HSIDIV_1,
    RCC_HSI_DIV2         =          RCC_CR_HSIDIV_2,
    RCC_HSI_DIV4         =          RCC_CR_HSIDIV_4,
    RCC_HSI_DIV8         =          RCC_CR_HSIDIV_8
};
/** @defgroup RCC_EC_LSEDRIVE  LSE oscillator drive capability
  * @{
  */
enum RCCLSEOscillatorDriveCapability
{
    RCC_LSEDRIVE_LOW           =     (uint32_t)(0x00000000U),
    RCC_LSEDRIVE_MEDIUMLOW     =     (uint32_t)(RCC_BDCR_LSEDRV_0),
    RCC_LSEDRIVE_MEDIUMHIGH    =     (uint32_t)(RCC_BDCR_LSEDRV_1),
    RCC_LSEDRIVE_HIGH          =     (uint32_t)(RCC_BDCR_LSEDRV)
};
/** @defgroup RCC_EC_SYS_CLKSOURCE  System clock switch
  * @{
  */
enum RCCSYSClkSource
{
    RCC_SYS_CLKSOURCE_HSI      =     RCC_CFGR_SW_HSI,
    RCC_SYS_CLKSOURCE_CSI      =     RCC_CFGR_SW_CSI,
    RCC_SYS_CLKSOURCE_HSE      =     RCC_CFGR_SW_HSE,
    RCC_SYS_CLKSOURCE_PLL1     =     RCC_CFGR_SW_PLL1
};
/** @defgroup RCC_EC_SYS_CLKSOURCE_STATUS  System clock switch status
  * @{
  */
enum RCCSYSClkSourceStatus
{
    RCC_SYS_CLKSOURCE_STATUS_HSI    =  RCC_CFGR_SWS_HSI,   /*!< HSI used as system clock */
    RCC_SYS_CLKSOURCE_STATUS_CSI    =  RCC_CFGR_SWS_CSI,   /*!< CSI used as system clock */
    RCC_SYS_CLKSOURCE_STATUS_HSE    =  RCC_CFGR_SWS_HSE,   /*!< HSE used as system clock */
    RCC_SYS_CLKSOURCE_STATUS_PLL1   =  RCC_CFGR_SWS_PLL1   /*!< PLL1 used as system clock */
};
/** @defgroup RCC_EC_SYSWAKEUP_CLKSOURCE  System wakeup clock source
  * @{
  */
enum RCCSYSWakeupClkSource
{
    RCC_SYSWAKEUP_CLKSOURCE_HSI  =   (uint32_t)(0x00000000U),
    RCC_SYSWAKEUP_CLKSOURCE_CSI  =   (uint32_t)(RCC_CFGR_STOPWUCK)
};
/** @defgroup RCC_EC_KERWAKEUP_CLKSOURCE  Kernel wakeup clock source
  * @{
  */
enum RCCKERWakeupClkSource
{
    RCC_KERWAKEUP_CLKSOURCE_HSI   =  (uint32_t)(0x00000000U),
    RCC_KERWAKEUP_CLKSOURCE_CSI   =  (uint32_t)(RCC_CFGR_STOPKERWUCK)
};
/** @defgroup RCC_EC_SYSCLK_DIV  System prescaler
  * @{
  */
enum RCCSysClkPrescaler
{
    #if defined(RCC_D1CFGR_D1CPRE_DIV1)
    RCC_SYSCLK_DIV_1        =        RCC_D1CFGR_D1CPRE_DIV1,
    RCC_SYSCLK_DIV_2        =        RCC_D1CFGR_D1CPRE_DIV2,
    RCC_SYSCLK_DIV_4        =        RCC_D1CFGR_D1CPRE_DIV4,
    RCC_SYSCLK_DIV_8        =        RCC_D1CFGR_D1CPRE_DIV8,
    RCC_SYSCLK_DIV_16       =        RCC_D1CFGR_D1CPRE_DIV16,
    RCC_SYSCLK_DIV_64       =        RCC_D1CFGR_D1CPRE_DIV64,
    RCC_SYSCLK_DIV_128      =        RCC_D1CFGR_D1CPRE_DIV128,
    RCC_SYSCLK_DIV_256      =        RCC_D1CFGR_D1CPRE_DIV256,
    RCC_SYSCLK_DIV_512      =        RCC_D1CFGR_D1CPRE_DIV512,
    #else
    RCC_SYSCLK_DIV_1        =        RCC_CDCFGR1_CDCPRE_DIV1,
    RCC_SYSCLK_DIV_2        =        RCC_CDCFGR1_CDCPRE_DIV2,
    RCC_SYSCLK_DIV_4        =        RCC_CDCFGR1_CDCPRE_DIV4,
    RCC_SYSCLK_DIV_8        =        RCC_CDCFGR1_CDCPRE_DIV8,
    RCC_SYSCLK_DIV_16       =        RCC_CDCFGR1_CDCPRE_DIV16,
    RCC_SYSCLK_DIV_64       =        RCC_CDCFGR1_CDCPRE_DIV64,
    RCC_SYSCLK_DIV_128      =        RCC_CDCFGR1_CDCPRE_DIV128,
    RCC_SYSCLK_DIV_256      =        RCC_CDCFGR1_CDCPRE_DIV256,
    RCC_SYSCLK_DIV_512      =        RCC_CDCFGR1_CDCPRE_DIV512,
    #endif /* RCC_D1CFGR_D1CPRE_DIV1 */
};
/** @defgroup RCC_EC_AHB_DIV  AHB prescaler
  * @{
  */
enum RCCAHBPrescaler
{
    #if defined(RCC_D1CFGR_HPRE_DIV1)
    RCC_AHB_DIV_1           =        RCC_D1CFGR_HPRE_DIV1,
    RCC_AHB_DIV_2           =        RCC_D1CFGR_HPRE_DIV2,
    RCC_AHB_DIV_4           =        RCC_D1CFGR_HPRE_DIV4,
    RCC_AHB_DIV_8           =        RCC_D1CFGR_HPRE_DIV8,
    RCC_AHB_DIV_16          =        RCC_D1CFGR_HPRE_DIV16,
    RCC_AHB_DIV_64          =        RCC_D1CFGR_HPRE_DIV64,
    RCC_AHB_DIV_128         =        RCC_D1CFGR_HPRE_DIV128,
    RCC_AHB_DIV_256         =        RCC_D1CFGR_HPRE_DIV256,
    RCC_AHB_DIV_512         =        RCC_D1CFGR_HPRE_DIV512,
    #else
    RCC_AHB_DIV_1           =        RCC_CDCFGR1_HPRE_DIV1,
    RCC_AHB_DIV_2           =        RCC_CDCFGR1_HPRE_DIV2,
    RCC_AHB_DIV_4           =        RCC_CDCFGR1_HPRE_DIV4,
    RCC_AHB_DIV_8           =        RCC_CDCFGR1_HPRE_DIV8,
    RCC_AHB_DIV_16          =        RCC_CDCFGR1_HPRE_DIV16,
    RCC_AHB_DIV_64          =        RCC_CDCFGR1_HPRE_DIV64,
    RCC_AHB_DIV_128         =        RCC_CDCFGR1_HPRE_DIV128,
    RCC_AHB_DIV_256         =        RCC_CDCFGR1_HPRE_DIV256,
    RCC_AHB_DIV_512         =        RCC_CDCFGR1_HPRE_DIV512,
    #endif /* RCC_D1CFGR_HPRE_DIV1 */
};
/** @defgroup RCC_EC_APB1_DIV  APB low-speed prescaler (APB1)
  * @{
  */
enum RCCAPB1Prescaler
{
    #if defined(RCC_D2CFGR_D2PPRE1_DIV1)
    RCC_APB1_DIV_1          =        RCC_D2CFGR_D2PPRE1_DIV1,
    RCC_APB1_DIV_2          =        RCC_D2CFGR_D2PPRE1_DIV2,
    RCC_APB1_DIV_4          =        RCC_D2CFGR_D2PPRE1_DIV4,
    RCC_APB1_DIV_8          =        RCC_D2CFGR_D2PPRE1_DIV8,
    RCC_APB1_DIV_16         =        RCC_D2CFGR_D2PPRE1_DIV16,
    #else
    RCC_APB1_DIV_1          =        RCC_CDCFGR2_CDPPRE1_DIV1,
    RCC_APB1_DIV_2          =        RCC_CDCFGR2_CDPPRE1_DIV2,
    RCC_APB1_DIV_4          =        RCC_CDCFGR2_CDPPRE1_DIV4,
    RCC_APB1_DIV_8          =        RCC_CDCFGR2_CDPPRE1_DIV8,
    RCC_APB1_DIV_16         =        RCC_CDCFGR2_CDPPRE1_DIV16,
    #endif /* RCC_D2CFGR_D2PPRE1_DIV1 */
};
/** @defgroup RCC_EC_APB2_DIV  APB low-speed prescaler (APB2)
  * @{
  */
enum RCCAPB2Prescaler
{
    #if defined(RCC_D2CFGR_D2PPRE2_DIV1)
    RCC_APB2_DIV_1        =          RCC_D2CFGR_D2PPRE2_DIV1,
    RCC_APB2_DIV_2        =          RCC_D2CFGR_D2PPRE2_DIV2,
    RCC_APB2_DIV_4        =          RCC_D2CFGR_D2PPRE2_DIV4,
    RCC_APB2_DIV_8        =          RCC_D2CFGR_D2PPRE2_DIV8,
    RCC_APB2_DIV_16       =          RCC_D2CFGR_D2PPRE2_DIV16,
    #else
    RCC_APB2_DIV_1        =          RCC_CDCFGR2_CDPPRE2_DIV1,
    RCC_APB2_DIV_2        =          RCC_CDCFGR2_CDPPRE2_DIV2,
    RCC_APB2_DIV_4        =          RCC_CDCFGR2_CDPPRE2_DIV4,
    RCC_APB2_DIV_8        =          RCC_CDCFGR2_CDPPRE2_DIV8,
    RCC_APB2_DIV_16       =          RCC_CDCFGR2_CDPPRE2_DIV16,
    #endif /* RCC_D2CFGR_D2PPRE2_DIV1 */
};
/** @defgroup RCC_EC_APB3_DIV  APB low-speed prescaler (APB3)
  * @{
  */
enum RCCAPB3Prescaler
{
    #if defined(RCC_D1CFGR_D1PPRE_DIV1)
    RCC_APB3_DIV_1          =        RCC_D1CFGR_D1PPRE_DIV1,
    RCC_APB3_DIV_2          =        RCC_D1CFGR_D1PPRE_DIV2,
    RCC_APB3_DIV_4          =        RCC_D1CFGR_D1PPRE_DIV4,
    RCC_APB3_DIV_8          =        RCC_D1CFGR_D1PPRE_DIV8,
    RCC_APB3_DIV_16         =        RCC_D1CFGR_D1PPRE_DIV16,
    #else
    RCC_APB3_DIV_1          =        RCC_CDCFGR1_CDPPRE_DIV1,
    RCC_APB3_DIV_2          =        RCC_CDCFGR1_CDPPRE_DIV2,
    RCC_APB3_DIV_4          =        RCC_CDCFGR1_CDPPRE_DIV4,
    RCC_APB3_DIV_8          =        RCC_CDCFGR1_CDPPRE_DIV8,
    RCC_APB3_DIV_16         =        RCC_CDCFGR1_CDPPRE_DIV16,
    #endif /* RCC_D1CFGR_D1PPRE_DIV1 */
};
/** @defgroup RCC_EC_APB4_DIV  APB low-speed prescaler (APB4)
  * @{
  */
enum RCCAPB4Prescaler
{
    #if defined(RCC_D3CFGR_D3PPRE_DIV1)
    RCC_APB4_DIV_1          =        RCC_D3CFGR_D3PPRE_DIV1,
    RCC_APB4_DIV_2          =        RCC_D3CFGR_D3PPRE_DIV2,
    RCC_APB4_DIV_4          =        RCC_D3CFGR_D3PPRE_DIV4,
    RCC_APB4_DIV_8          =        RCC_D3CFGR_D3PPRE_DIV8,
    RCC_APB4_DIV_16         =        RCC_D3CFGR_D3PPRE_DIV16,
    #else
    RCC_APB4_DIV_1          =        RCC_SRDCFGR_SRDPPRE_DIV1,
    RCC_APB4_DIV_2          =        RCC_SRDCFGR_SRDPPRE_DIV2,
    RCC_APB4_DIV_4          =        RCC_SRDCFGR_SRDPPRE_DIV4,
    RCC_APB4_DIV_8          =        RCC_SRDCFGR_SRDPPRE_DIV8,
    RCC_APB4_DIV_16         =        RCC_SRDCFGR_SRDPPRE_DIV16,
    #endif /* RCC_D3CFGR_D3PPRE_DIV1 */
};
/** @defgroup RCC_EC_MCOxSOURCE  MCO source selection
  * @{
  */
enum RCCMCOxSource
{
    RCC_MCO1SOURCE_HSI        =      (uint32_t)((RCC_CFGR_MCO1>>16U) | 0x00000000U),
    RCC_MCO1SOURCE_LSE        =      (uint32_t)((RCC_CFGR_MCO1>>16U) | RCC_CFGR_MCO1_0),
    RCC_MCO1SOURCE_HSE        =      (uint32_t)((RCC_CFGR_MCO1>>16U) | RCC_CFGR_MCO1_1),
    RCC_MCO1SOURCE_PLL1QCLK   =      (uint32_t)((RCC_CFGR_MCO1>>16U) | RCC_CFGR_MCO1_1|RCC_CFGR_MCO1_0),
    RCC_MCO1SOURCE_HSI48      =      (uint32_t)((RCC_CFGR_MCO1>>16U) | RCC_CFGR_MCO1_2),
    RCC_MCO2SOURCE_SYSCLK     =      (uint32_t)((RCC_CFGR_MCO2>>16U) | 0x00000000U),
    RCC_MCO2SOURCE_PLL2PCLK   =      (uint32_t)((RCC_CFGR_MCO2>>16U) | RCC_CFGR_MCO2_0),
    RCC_MCO2SOURCE_HSE        =      (uint32_t)((RCC_CFGR_MCO2>>16U) | RCC_CFGR_MCO2_1),
    RCC_MCO2SOURCE_PLL1PCLK   =      (uint32_t)((RCC_CFGR_MCO2>>16U) | RCC_CFGR_MCO2_1|RCC_CFGR_MCO2_0),
    RCC_MCO2SOURCE_CSI        =      (uint32_t)((RCC_CFGR_MCO2>>16U) | RCC_CFGR_MCO2_2),
    RCC_MCO2SOURCE_LSI        =      (uint32_t)((RCC_CFGR_MCO2>>16U) | RCC_CFGR_MCO2_2|RCC_CFGR_MCO2_0)
};
/** @defgroup RCC_EC_MCOx_DIV  MCO prescaler
  * @{
  */
enum RCCMCOxPrescaler
{
    RCC_MCO1_DIV_1         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0),
    RCC_MCO1_DIV_2         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_1),
    RCC_MCO1_DIV_3         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_1),
    RCC_MCO1_DIV_4         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_2),
    RCC_MCO1_DIV_5         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_2),
    RCC_MCO1_DIV_6         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2),
    RCC_MCO1_DIV_7         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2),
    RCC_MCO1_DIV_8         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_9         =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_10        =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_11        =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_12        =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_2 | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_13        =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_2 | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_14        =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2 | RCC_CFGR_MCO1PRE_3),
    RCC_MCO1_DIV_15        =         (uint32_t)((RCC_CFGR_MCO1PRE>>16U) | RCC_CFGR_MCO1PRE),
    RCC_MCO2_DIV_1         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0),
    RCC_MCO2_DIV_2         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_1),
    RCC_MCO2_DIV_3         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0 | RCC_CFGR_MCO2PRE_1),
    RCC_MCO2_DIV_4         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_2),
    RCC_MCO2_DIV_5         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0 | RCC_CFGR_MCO2PRE_2),
    RCC_MCO2_DIV_6         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_1 | RCC_CFGR_MCO2PRE_2),
    RCC_MCO2_DIV_7         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0 | RCC_CFGR_MCO2PRE_1 | RCC_CFGR_MCO2PRE_2),
    RCC_MCO2_DIV_8         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_9         =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0 | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_10        =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_1 | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_11        =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0 | RCC_CFGR_MCO2PRE_1 | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_12        =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_2 | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_13        =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_0 | RCC_CFGR_MCO2PRE_2 | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_14        =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE_1 | RCC_CFGR_MCO2PRE_2 | RCC_CFGR_MCO2PRE_3),
    RCC_MCO2_DIV_15        =         (uint32_t)((RCC_CFGR_MCO2PRE>>16U) | RCC_CFGR_MCO2PRE)
};
/** @defgroup RCC_EC_RTC_HSEDIV  HSE prescaler for RTC clock
  * @{
  */
enum RCCRTCHSEPrescaler
{
    RCC_RTC_NOCLOCK          =       (uint32_t)(0x00000000U),
    RCC_RTC_HSE_DIV_2        =       (uint32_t)(RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_3        =       (uint32_t)(RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_4        =       (uint32_t)(RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_5        =       (uint32_t)(RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_6        =       (uint32_t)(RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_7        =       (uint32_t)(RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_8        =       (uint32_t)(RCC_CFGR_RTCPRE_3),
    RCC_RTC_HSE_DIV_9        =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_10       =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_11       =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_12       =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_13       =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_14       =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_15       =       (uint32_t)(RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_16       =       (uint32_t)(RCC_CFGR_RTCPRE_4),
    RCC_RTC_HSE_DIV_17       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_18       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_19       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_20       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_21       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_22       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_23       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_24       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3),
    RCC_RTC_HSE_DIV_25       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_26       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_27       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_28       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_29       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_30       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_31       =       (uint32_t)(RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_32       =       (uint32_t)(RCC_CFGR_RTCPRE_5),
    RCC_RTC_HSE_DIV_33       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_34       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_35       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_36       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_37       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_38       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_39       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_40       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3),
    RCC_RTC_HSE_DIV_41       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_42       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_43       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_44       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_45       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_46       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_47       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_48       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4),
    RCC_RTC_HSE_DIV_49       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_50       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_51       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_52       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_53       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_54       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_55       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_56       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3),
    RCC_RTC_HSE_DIV_57       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_58       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_59       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_60       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2),
    RCC_RTC_HSE_DIV_61       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_0),
    RCC_RTC_HSE_DIV_62       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1),
    RCC_RTC_HSE_DIV_63       =       (uint32_t)(RCC_CFGR_RTCPRE_5|RCC_CFGR_RTCPRE_4|RCC_CFGR_RTCPRE_3|RCC_CFGR_RTCPRE_2|RCC_CFGR_RTCPRE_1|RCC_CFGR_RTCPRE_0)
};
/** @defgroup RCC_EC_USARTx_CLKSOURCE  Peripheral USART clock source selection
  * @{
  */
enum RCCUSARTxClkSource
{
    #if defined(RCC_D2CCIP2R_USART16SEL)
    RCC_USART16_CLKSOURCE_PCLK2    =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, 0x00000000U),
    RCC_USART16_CLKSOURCE_PLL2Q    =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, RCC_D2CCIP2R_USART16SEL_0),
    RCC_USART16_CLKSOURCE_PLL3Q    =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, RCC_D2CCIP2R_USART16SEL_1),
    RCC_USART16_CLKSOURCE_HSI      =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, RCC_D2CCIP2R_USART16SEL_0 | RCC_D2CCIP2R_USART16SEL_1),
    RCC_USART16_CLKSOURCE_CSI      =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, RCC_D2CCIP2R_USART16SEL_2),
    RCC_USART16_CLKSOURCE_LSE      =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, RCC_D2CCIP2R_USART16SEL_0 | RCC_D2CCIP2R_USART16SEL_2),
    /*  Aliases */
    RCC_USART16910_CLKSOURCE_PCLK2   =   RCC_USART16_CLKSOURCE_PCLK2,
    RCC_USART16910_CLKSOURCE_PLL2Q   =   RCC_USART16_CLKSOURCE_PLL2Q,
    RCC_USART16910_CLKSOURCE_PLL3Q   =   RCC_USART16_CLKSOURCE_PLL3Q,
    RCC_USART16910_CLKSOURCE_HSI     =   RCC_USART16_CLKSOURCE_HSI,
    RCC_USART16910_CLKSOURCE_CSI     =   RCC_USART16_CLKSOURCE_CSI,
    RCC_USART16910_CLKSOURCE_LSE     =   RCC_USART16_CLKSOURCE_LSE,
    #elif defined(RCC_D2CCIP2R_USART16910SEL)
    RCC_USART16910_CLKSOURCE_PCLK2   =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, 0x00000000U),
    RCC_USART16910_CLKSOURCE_PLL2Q   =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, RCC_D2CCIP2R_USART16910SEL_0),
    RCC_USART16910_CLKSOURCE_PLL3Q   =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, RCC_D2CCIP2R_USART16910SEL_1),
    RCC_USART16910_CLKSOURCE_HSI     =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, RCC_D2CCIP2R_USART16910SEL_0 | RCC_D2CCIP2R_USART16910SEL_1),
    RCC_USART16910_CLKSOURCE_CSI     =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, RCC_D2CCIP2R_USART16910SEL_2),
    RCC_USART16910_CLKSOURCE_LSE     =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, RCC_D2CCIP2R_USART16910SEL_0 | RCC_D2CCIP2R_USART16910SEL_2),
    /*  Aliases */
    RCC_USART16_CLKSOURCE_PCLK2      =   RCC_USART16910_CLKSOURCE_PCLK2,
    RCC_USART16_CLKSOURCE_PLL2Q      =   RCC_USART16910_CLKSOURCE_PLL2Q,
    RCC_USART16_CLKSOURCE_PLL3Q      =   RCC_USART16910_CLKSOURCE_PLL3Q,
    RCC_USART16_CLKSOURCE_HSI        =   RCC_USART16910_CLKSOURCE_HSI,
    RCC_USART16_CLKSOURCE_CSI        =   RCC_USART16910_CLKSOURCE_CSI,
    RCC_USART16_CLKSOURCE_LSE        =   RCC_USART16910_CLKSOURCE_LSE,
    #else
    RCC_USART16910_CLKSOURCE_PCLK2    =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, 0x00000000U),
    RCC_USART16910_CLKSOURCE_PLL2Q    =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, RCC_CDCCIP2R_USART16910SEL_0),
    RCC_USART16910_CLKSOURCE_PLL3Q    =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, RCC_CDCCIP2R_USART16910SEL_1),
    RCC_USART16910_CLKSOURCE_HSI      =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, RCC_CDCCIP2R_USART16910SEL_0 | RCC_CDCCIP2R_USART16910SEL_1),
    RCC_USART16910_CLKSOURCE_CSI      =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, RCC_CDCCIP2R_USART16910SEL_2),
    RCC_USART16910_CLKSOURCE_LSE      =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, RCC_CDCCIP2R_USART16910SEL_0 | RCC_CDCCIP2R_USART16910SEL_2),
    /*  Aliases */
    RCC_USART16_CLKSOURCE_PCLK2     =    RCC_USART16910_CLKSOURCE_PCLK2,
    RCC_USART16_CLKSOURCE_PLL2Q     =    RCC_USART16910_CLKSOURCE_PLL2Q,
    RCC_USART16_CLKSOURCE_PLL3Q     =    RCC_USART16910_CLKSOURCE_PLL3Q,
    RCC_USART16_CLKSOURCE_HSI       =    RCC_USART16910_CLKSOURCE_HSI,
    RCC_USART16_CLKSOURCE_CSI       =    RCC_USART16910_CLKSOURCE_CSI,
    RCC_USART16_CLKSOURCE_LSE       =    RCC_USART16910_CLKSOURCE_LSE,
    #endif  /* RCC_D2CCIP2R_USART16SEL */
    #if defined(RCC_D2CCIP2R_USART28SEL)
    RCC_USART234578_CLKSOURCE_PCLK1   =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, 0x00000000U),
    RCC_USART234578_CLKSOURCE_PLL2Q   =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, RCC_D2CCIP2R_USART28SEL_0),
    RCC_USART234578_CLKSOURCE_PLL3Q   =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, RCC_D2CCIP2R_USART28SEL_1),
    RCC_USART234578_CLKSOURCE_HSI     =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, RCC_D2CCIP2R_USART28SEL_0 | RCC_D2CCIP2R_USART28SEL_1),
    RCC_USART234578_CLKSOURCE_CSI     =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, RCC_D2CCIP2R_USART28SEL_2),
    RCC_USART234578_CLKSOURCE_LSE     =   CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, RCC_D2CCIP2R_USART28SEL_0 | RCC_D2CCIP2R_USART28SEL_2),
    #else
    RCC_USART234578_CLKSOURCE_PCLK1   =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, 0x00000000U),
    RCC_USART234578_CLKSOURCE_PLL2Q   =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, RCC_CDCCIP2R_USART234578SEL_0),
    RCC_USART234578_CLKSOURCE_PLL3Q   =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, RCC_CDCCIP2R_USART234578SEL_1),
    RCC_USART234578_CLKSOURCE_HSI     =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, RCC_CDCCIP2R_USART234578SEL_0 | RCC_CDCCIP2R_USART234578SEL_1),
    RCC_USART234578_CLKSOURCE_CSI     =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, RCC_CDCCIP2R_USART234578SEL_2),
    RCC_USART234578_CLKSOURCE_LSE     =  CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, RCC_CDCCIP2R_USART234578SEL_0 | RCC_CDCCIP2R_USART234578SEL_2),
    #endif /* RCC_D2CCIP2R_USART28SEL */
};
/** @defgroup RCC_EC_LPUARTx_CLKSOURCE  Peripheral LPUART clock source selection
  * @{
  */
enum RCCLPUARTxClkSource
{
    #if defined(RCC_D3CCIPR_LPUART1SEL)
    RCC_LPUART1_CLKSOURCE_PCLK4    =     (0x00000000U),
    RCC_LPUART1_CLKSOURCE_PLL2Q    =     (RCC_D3CCIPR_LPUART1SEL_0),
    RCC_LPUART1_CLKSOURCE_PLL3Q    =     (RCC_D3CCIPR_LPUART1SEL_1),
    RCC_LPUART1_CLKSOURCE_HSI      =     (RCC_D3CCIPR_LPUART1SEL_0 | RCC_D3CCIPR_LPUART1SEL_1),
    RCC_LPUART1_CLKSOURCE_CSI      =     (RCC_D3CCIPR_LPUART1SEL_2),
    RCC_LPUART1_CLKSOURCE_LSE      =     (RCC_D3CCIPR_LPUART1SEL_0 | RCC_D3CCIPR_LPUART1SEL_2),
    #else
    RCC_LPUART1_CLKSOURCE_PCLK4    =     (0x00000000U),
    RCC_LPUART1_CLKSOURCE_PLL2Q    =     (RCC_SRDCCIPR_LPUART1SEL_0),
    RCC_LPUART1_CLKSOURCE_PLL3Q    =     (RCC_SRDCCIPR_LPUART1SEL_1),
    RCC_LPUART1_CLKSOURCE_HSI      =     (RCC_SRDCCIPR_LPUART1SEL_0 | RCC_SRDCCIPR_LPUART1SEL_1),
    RCC_LPUART1_CLKSOURCE_CSI      =     (RCC_SRDCCIPR_LPUART1SEL_2),
    RCC_LPUART1_CLKSOURCE_LSE      =     (RCC_SRDCCIPR_LPUART1SEL_0 | RCC_SRDCCIPR_LPUART1SEL_2),
    #endif /* RCC_D3CCIPR_LPUART1SEL */
};
/** @defgroup RCC_EC_I2Cx_CLKSOURCE  Peripheral I2C clock source selection
  * @{
  */
enum RCCI2CxClkSource
{
    #if defined (RCC_D2CCIP2R_I2C123SEL)
    RCC_I2C123_CLKSOURCE_PCLK1     =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C123SEL, RCC_D2CCIP2R_I2C123SEL_Pos, 0x00000000U),
    RCC_I2C123_CLKSOURCE_PLL3R     =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C123SEL, RCC_D2CCIP2R_I2C123SEL_Pos, RCC_D2CCIP2R_I2C123SEL_0),
    RCC_I2C123_CLKSOURCE_HSI       =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C123SEL, RCC_D2CCIP2R_I2C123SEL_Pos, RCC_D2CCIP2R_I2C123SEL_1),
    RCC_I2C123_CLKSOURCE_CSI       =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C123SEL, RCC_D2CCIP2R_I2C123SEL_Pos, RCC_D2CCIP2R_I2C123SEL_0 | RCC_D2CCIP2R_I2C123SEL_1),
    /*  Aliases */
    RCC_I2C1235_CLKSOURCE_PCLK1    =     RCC_I2C123_CLKSOURCE_PCLK1,
    RCC_I2C1235_CLKSOURCE_PLL3R    =     RCC_I2C123_CLKSOURCE_PLL3R,
    RCC_I2C1235_CLKSOURCE_HSI      =     RCC_I2C123_CLKSOURCE_HSI,
    RCC_I2C1235_CLKSOURCE_CSI      =     RCC_I2C123_CLKSOURCE_CSI,

    #elif defined (RCC_D2CCIP2R_I2C1235SEL)
    RCC_I2C1235_CLKSOURCE_PCLK1     =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C1235SEL, RCC_D2CCIP2R_I2C1235SEL_Pos, 0x00000000U),
    RCC_I2C1235_CLKSOURCE_PLL3R     =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C1235SEL, RCC_D2CCIP2R_I2C1235SEL_Pos, RCC_D2CCIP2R_I2C1235SEL_0),
    RCC_I2C1235_CLKSOURCE_HSI       =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C1235SEL, RCC_D2CCIP2R_I2C1235SEL_Pos, RCC_D2CCIP2R_I2C1235SEL_1),
    RCC_I2C1235_CLKSOURCE_CSI       =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C1235SEL, RCC_D2CCIP2R_I2C1235SEL_Pos, RCC_D2CCIP2R_I2C1235SEL_0 | RCC_D2CCIP2R_I2C1235SEL_1),
    /*  Aliases */
    RCC_I2C123_CLKSOURCE_PCLK1      =    RCC_I2C1235_CLKSOURCE_PCLK1,
    RCC_I2C123_CLKSOURCE_PLL3R      =    RCC_I2C1235_CLKSOURCE_PLL3R,
    RCC_I2C123_CLKSOURCE_HSI        =    RCC_I2C1235_CLKSOURCE_HSI,
    RCC_I2C123_CLKSOURCE_CSI        =    RCC_I2C1235_CLKSOURCE_CSI,

    #else
    RCC_I2C123_CLKSOURCE_PCLK1      =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_I2C123SEL, RCC_CDCCIP2R_I2C123SEL_Pos, 0x00000000U),
    RCC_I2C123_CLKSOURCE_PLL3R      =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_I2C123SEL, RCC_CDCCIP2R_I2C123SEL_Pos, RCC_CDCCIP2R_I2C123SEL_0),
    RCC_I2C123_CLKSOURCE_HSI        =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_I2C123SEL, RCC_CDCCIP2R_I2C123SEL_Pos, RCC_CDCCIP2R_I2C123SEL_1),
    RCC_I2C123_CLKSOURCE_CSI        =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_I2C123SEL, RCC_CDCCIP2R_I2C123SEL_Pos, RCC_CDCCIP2R_I2C123SEL_0 | RCC_CDCCIP2R_I2C123SEL_1),
    #endif /* RCC_D2CCIP2R_I2C123SEL */
    #if defined (RCC_D3CCIPR_I2C4SEL)
    RCC_I2C4_CLKSOURCE_PCLK4        =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_I2C4SEL,    RCC_D3CCIPR_I2C4SEL_Pos,    0x00000000U),
    RCC_I2C4_CLKSOURCE_PLL3R        =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_I2C4SEL,    RCC_D3CCIPR_I2C4SEL_Pos,    RCC_D3CCIPR_I2C4SEL_0),
    RCC_I2C4_CLKSOURCE_HSI          =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_I2C4SEL,    RCC_D3CCIPR_I2C4SEL_Pos,    RCC_D3CCIPR_I2C4SEL_1),
    RCC_I2C4_CLKSOURCE_CSI          =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_I2C4SEL,    RCC_D3CCIPR_I2C4SEL_Pos,    RCC_D3CCIPR_I2C4SEL_0 | RCC_D3CCIPR_I2C4SEL_1),
    #else
    RCC_I2C4_CLKSOURCE_PCLK4        =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_I2C4SEL,    RCC_SRDCCIPR_I2C4SEL_Pos,    0x00000000U),
    RCC_I2C4_CLKSOURCE_PLL3R        =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_I2C4SEL,    RCC_SRDCCIPR_I2C4SEL_Pos,    RCC_SRDCCIPR_I2C4SEL_0),
    RCC_I2C4_CLKSOURCE_HSI          =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_I2C4SEL,    RCC_SRDCCIPR_I2C4SEL_Pos,    RCC_SRDCCIPR_I2C4SEL_1),
    RCC_I2C4_CLKSOURCE_CSI          =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_I2C4SEL,    RCC_SRDCCIPR_I2C4SEL_Pos,    RCC_SRDCCIPR_I2C4SEL_0 | RCC_SRDCCIPR_I2C4SEL_1),
    #endif /* RCC_D3CCIPR_I2C4SEL */
};
/** @defgroup RCC_EC_LPTIMx_CLKSOURCE  Peripheral LPTIM clock source selection
  * @{
  */
enum RCCLPTIMxClkSource
{
    #if defined(RCC_D2CCIP2R_LPTIM1SEL)
    RCC_LPTIM1_CLKSOURCE_PCLK1     =      CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,  0x00000000U),
    RCC_LPTIM1_CLKSOURCE_PLL2P     =      CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,  RCC_D2CCIP2R_LPTIM1SEL_0),
    RCC_LPTIM1_CLKSOURCE_PLL3R     =      CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,  RCC_D2CCIP2R_LPTIM1SEL_1),
    RCC_LPTIM1_CLKSOURCE_LSE       =      CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,  RCC_D2CCIP2R_LPTIM1SEL_0 | RCC_D2CCIP2R_LPTIM1SEL_1),
    RCC_LPTIM1_CLKSOURCE_LSI       =      CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,  RCC_D2CCIP2R_LPTIM1SEL_2),
    RCC_LPTIM1_CLKSOURCE_CLKP      =      CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,  RCC_D2CCIP2R_LPTIM1SEL_0 | RCC_D2CCIP2R_LPTIM1SEL_2),
    #else
    RCC_LPTIM1_CLKSOURCE_PCLK1     =      CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,  0x00000000U),
    RCC_LPTIM1_CLKSOURCE_PLL2P     =      CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,  RCC_CDCCIP2R_LPTIM1SEL_0),
    RCC_LPTIM1_CLKSOURCE_PLL3R     =      CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,  RCC_CDCCIP2R_LPTIM1SEL_1),
    RCC_LPTIM1_CLKSOURCE_LSE       =      CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,  RCC_CDCCIP2R_LPTIM1SEL_0 | RCC_CDCCIP2R_LPTIM1SEL_1),
    RCC_LPTIM1_CLKSOURCE_LSI       =      CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,  RCC_CDCCIP2R_LPTIM1SEL_2),
    RCC_LPTIM1_CLKSOURCE_CLKP      =      CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,  RCC_CDCCIP2R_LPTIM1SEL_0 | RCC_CDCCIP2R_LPTIM1SEL_2),
    #endif /* RCC_D2CCIP2R_LPTIM1SEL */
    #if defined(RCC_D3CCIPR_LPTIM2SEL)
    RCC_LPTIM2_CLKSOURCE_PCLK4     =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,   0x00000000U),
    RCC_LPTIM2_CLKSOURCE_PLL2P     =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,   RCC_D3CCIPR_LPTIM2SEL_0),
    RCC_LPTIM2_CLKSOURCE_PLL3R     =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,   RCC_D3CCIPR_LPTIM2SEL_1),
    RCC_LPTIM2_CLKSOURCE_LSE       =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,   RCC_D3CCIPR_LPTIM2SEL_0 | RCC_D3CCIPR_LPTIM2SEL_1),
    RCC_LPTIM2_CLKSOURCE_LSI       =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,   RCC_D3CCIPR_LPTIM2SEL_2),
    RCC_LPTIM2_CLKSOURCE_CLKP      =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,   RCC_D3CCIPR_LPTIM2SEL_0 | RCC_D3CCIPR_LPTIM2SEL_2),
    #else
    RCC_LPTIM2_CLKSOURCE_PCLK4     =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM2SEL,   RCC_SRDCCIPR_LPTIM2SEL_Pos,   0x00000000U),
    RCC_LPTIM2_CLKSOURCE_PLL2P     =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM2SEL,   RCC_SRDCCIPR_LPTIM2SEL_Pos,   RCC_SRDCCIPR_LPTIM2SEL_0),
    RCC_LPTIM2_CLKSOURCE_PLL3R     =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM2SEL,   RCC_SRDCCIPR_LPTIM2SEL_Pos,   RCC_SRDCCIPR_LPTIM2SEL_1),
    RCC_LPTIM2_CLKSOURCE_LSE       =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM2SEL,   RCC_SRDCCIPR_LPTIM2SEL_Pos,   RCC_SRDCCIPR_LPTIM2SEL_0 | RCC_SRDCCIPR_LPTIM2SEL_1),
    RCC_LPTIM2_CLKSOURCE_LSI       =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM2SEL,   RCC_SRDCCIPR_LPTIM2SEL_Pos,   RCC_SRDCCIPR_LPTIM2SEL_2),
    RCC_LPTIM2_CLKSOURCE_CLKP      =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM2SEL,   RCC_SRDCCIPR_LPTIM2SEL_Pos,   RCC_SRDCCIPR_LPTIM2SEL_0 | RCC_SRDCCIPR_LPTIM2SEL_2),
    #endif /* RCC_D3CCIPR_LPTIM2SEL */
    #if defined(RCC_D3CCIPR_LPTIM345SEL) 
    RCC_LPTIM345_CLKSOURCE_PCLK4   =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos, 0x00000000U),
    RCC_LPTIM345_CLKSOURCE_PLL2P   =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos, RCC_D3CCIPR_LPTIM345SEL_0),
    RCC_LPTIM345_CLKSOURCE_PLL3R   =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos, RCC_D3CCIPR_LPTIM345SEL_1),
    RCC_LPTIM345_CLKSOURCE_LSE     =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos, RCC_D3CCIPR_LPTIM345SEL_0 | RCC_D3CCIPR_LPTIM345SEL_1),
    RCC_LPTIM345_CLKSOURCE_LSI     =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos, RCC_D3CCIPR_LPTIM345SEL_2),
    RCC_LPTIM345_CLKSOURCE_CLKP    =      CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos, RCC_D3CCIPR_LPTIM345SEL_0 | RCC_D3CCIPR_LPTIM345SEL_2),
    #else
    RCC_LPTIM345_CLKSOURCE_PCLK4   =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos, 0x00000000U),
    RCC_LPTIM345_CLKSOURCE_PLL2P   =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos, RCC_SRDCCIPR_LPTIM3SEL_0),
    RCC_LPTIM345_CLKSOURCE_PLL3R   =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos, RCC_SRDCCIPR_LPTIM3SEL_1),
    RCC_LPTIM345_CLKSOURCE_LSE     =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos, RCC_SRDCCIPR_LPTIM3SEL_0 | RCC_SRDCCIPR_LPTIM3SEL_1),
    RCC_LPTIM345_CLKSOURCE_LSI     =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos, RCC_SRDCCIPR_LPTIM3SEL_2),
    RCC_LPTIM345_CLKSOURCE_CLKP    =      CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos, RCC_SRDCCIPR_LPTIM3SEL_0 | RCC_SRDCCIPR_LPTIM3SEL_2),
    /* aliases*/
    RCC_LPTIM3_CLKSOURCE_PCLK4     =      RCC_LPTIM345_CLKSOURCE_PCLK4,
    RCC_LPTIM3_CLKSOURCE_PLL2P     =      RCC_LPTIM345_CLKSOURCE_PLL2P,
    RCC_LPTIM3_CLKSOURCE_PLL3R     =      RCC_LPTIM345_CLKSOURCE_PLL3R,
    RCC_LPTIM3_CLKSOURCE_LSE       =      RCC_LPTIM345_CLKSOURCE_LSE,
    RCC_LPTIM3_CLKSOURCE_LSI       =      RCC_LPTIM345_CLKSOURCE_LSI,
    RCC_LPTIM3_CLKSOURCE_CLKP      =      RCC_LPTIM345_CLKSOURCE_CLKP,
    #endif /* RCC_D3CCIPR_LPTIM345SEL */
};
/** @defgroup RCC_EC_SAIx_CLKSOURCE  Peripheral SAI clock source selection
  * @{
  */
enum RCCSAIxClkSource
{
    #if defined(RCC_D2CCIP1R_SAI1SEL)
    RCC_SAI1_CLKSOURCE_PLL1Q       =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI1SEL,  RCC_D2CCIP1R_SAI1SEL_Pos,  0x00000000U),
    RCC_SAI1_CLKSOURCE_PLL2P       =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI1SEL,  RCC_D2CCIP1R_SAI1SEL_Pos,  RCC_D2CCIP1R_SAI1SEL_0),
    RCC_SAI1_CLKSOURCE_PLL3P       =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI1SEL,  RCC_D2CCIP1R_SAI1SEL_Pos,  RCC_D2CCIP1R_SAI1SEL_1),
    RCC_SAI1_CLKSOURCE_I2S_CKIN    =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI1SEL,  RCC_D2CCIP1R_SAI1SEL_Pos,  RCC_D2CCIP1R_SAI1SEL_0 | RCC_D2CCIP1R_SAI1SEL_1),
    RCC_SAI1_CLKSOURCE_CLKP        =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI1SEL,  RCC_D2CCIP1R_SAI1SEL_Pos,  RCC_D2CCIP1R_SAI1SEL_2),
    #else
    RCC_SAI1_CLKSOURCE_PLL1Q       =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SAI1SEL,  RCC_CDCCIP1R_SAI1SEL_Pos,  0x00000000U),
    RCC_SAI1_CLKSOURCE_PLL2P       =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SAI1SEL,  RCC_CDCCIP1R_SAI1SEL_Pos,  RCC_CDCCIP1R_SAI1SEL_0),
    RCC_SAI1_CLKSOURCE_PLL3P       =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SAI1SEL,  RCC_CDCCIP1R_SAI1SEL_Pos,  RCC_CDCCIP1R_SAI1SEL_1),
    RCC_SAI1_CLKSOURCE_I2S_CKIN    =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SAI1SEL,  RCC_CDCCIP1R_SAI1SEL_Pos,  RCC_CDCCIP1R_SAI1SEL_0 | RCC_CDCCIP1R_SAI1SEL_1),
    RCC_SAI1_CLKSOURCE_CLKP        =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SAI1SEL,  RCC_CDCCIP1R_SAI1SEL_Pos,  RCC_CDCCIP1R_SAI1SEL_2),
    #endif
    #if defined(SAI3)
    RCC_SAI23_CLKSOURCE_PLL1Q      =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI23SEL, RCC_D2CCIP1R_SAI23SEL_Pos, 0x00000000U),
    RCC_SAI23_CLKSOURCE_PLL2P      =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI23SEL, RCC_D2CCIP1R_SAI23SEL_Pos, RCC_D2CCIP1R_SAI23SEL_0),
    RCC_SAI23_CLKSOURCE_PLL3P      =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI23SEL, RCC_D2CCIP1R_SAI23SEL_Pos, RCC_D2CCIP1R_SAI23SEL_1),
    RCC_SAI23_CLKSOURCE_I2S_CKIN   =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI23SEL, RCC_D2CCIP1R_SAI23SEL_Pos, RCC_D2CCIP1R_SAI23SEL_0 | RCC_D2CCIP1R_SAI23SEL_1),
    RCC_SAI23_CLKSOURCE_CLKP       =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI23SEL, RCC_D2CCIP1R_SAI23SEL_Pos, RCC_D2CCIP1R_SAI23SEL_2),
    #endif /* SAI3 */
    #if defined(RCC_CDCCIP1R_SAI2ASEL)
    RCC_SAI2A_CLKSOURCE_PLL1Q      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  0x00000000U),
    RCC_SAI2A_CLKSOURCE_PLL2P      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  RCC_CDCCIP1R_SAI2ASEL_0),
    RCC_SAI2A_CLKSOURCE_PLL3P      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  RCC_CDCCIP1R_SAI2ASEL_1),
    RCC_SAI2A_CLKSOURCE_I2S_CKIN   =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  RCC_CDCCIP1R_SAI2ASEL_0 | RCC_CDCCIP1R_SAI2ASEL_1),
    RCC_SAI2A_CLKSOURCE_CLKP       =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  RCC_CDCCIP1R_SAI2ASEL_2),
    RCC_SAI2A_CLKSOURCE_SPDIF      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  RCC_CDCCIP1R_SAI2ASEL_0 | RCC_CDCCIP1R_SAI2ASEL_2),
    #endif /* RCC_CDCCIP1R_SAI2ASEL */
    #if defined(RCC_CDCCIP1R_SAI2BSEL)
    RCC_SAI2B_CLKSOURCE_PLL1Q      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  0x00000000U),
    RCC_SAI2B_CLKSOURCE_PLL2P      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  RCC_CDCCIP1R_SAI2BSEL_0),
    RCC_SAI2B_CLKSOURCE_PLL3P      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  RCC_CDCCIP1R_SAI2BSEL_1),
    RCC_SAI2B_CLKSOURCE_I2S_CKIN   =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  RCC_CDCCIP1R_SAI2BSEL_0 | RCC_CDCCIP1R_SAI2BSEL_1),
    RCC_SAI2B_CLKSOURCE_CLKP       =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  RCC_CDCCIP1R_SAI2BSEL_2),
    RCC_SAI2B_CLKSOURCE_SPDIF      =     CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  RCC_CDCCIP1R_SAI2BSEL_0 | RCC_CDCCIP1R_SAI2BSEL_2),
    #endif /* RCC_CDCCIP1R_SAI2BSEL */
    #if defined(SAI4_Block_A)
    RCC_SAI4A_CLKSOURCE_PLL1Q      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  0x00000000U),
    RCC_SAI4A_CLKSOURCE_PLL2P      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  RCC_D3CCIPR_SAI4ASEL_0),
    RCC_SAI4A_CLKSOURCE_PLL3P      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  RCC_D3CCIPR_SAI4ASEL_1),
    RCC_SAI4A_CLKSOURCE_I2S_CKIN   =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  RCC_D3CCIPR_SAI4ASEL_0 | RCC_D3CCIPR_SAI4ASEL_1),
    RCC_SAI4A_CLKSOURCE_CLKP       =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  RCC_D3CCIPR_SAI4ASEL_2),
    #if defined(RCC_VER_3_0)
    RCC_SAI4A_CLKSOURCE_SPDIF      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  RCC_D3CCIPR_SAI4ASEL_2 | RCC_D3CCIPR_SAI4ASEL_0),
    #endif /* RCC_VER_3_0 */
    #endif /* SAI4_Block_A */
    #if defined(SAI4_Block_B)
    RCC_SAI4B_CLKSOURCE_PLL1Q      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  0x00000000U),
    RCC_SAI4B_CLKSOURCE_PLL2P      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  RCC_D3CCIPR_SAI4BSEL_0),
    RCC_SAI4B_CLKSOURCE_PLL3P      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  RCC_D3CCIPR_SAI4BSEL_1),
    RCC_SAI4B_CLKSOURCE_I2S_CKIN   =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  RCC_D3CCIPR_SAI4BSEL_0 | RCC_D3CCIPR_SAI4BSEL_1),
    RCC_SAI4B_CLKSOURCE_CLKP       =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  RCC_D3CCIPR_SAI4BSEL_2),
    #if defined(RCC_VER_3_0)
    RCC_SAI4B_CLKSOURCE_SPDIF      =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  RCC_D3CCIPR_SAI4BSEL_2 | RCC_D3CCIPR_SAI4BSEL_0),
    #endif /* RCC_VER_3_0 */
    #endif /* SAI4_Block_B */
};
/** @defgroup RCC_EC_SDMMC_CLKSOURCE  Peripheral SDMMC clock source selection
  * @{
  */
enum RCCSDMMCClkSource
{
    #if defined(RCC_D1CCIPR_SDMMCSEL)
    RCC_SDMMC_CLKSOURCE_PLL1Q      =     (0x00000000U),
    RCC_SDMMC_CLKSOURCE_PLL2R      =     (RCC_D1CCIPR_SDMMCSEL),
    #else
    RCC_SDMMC_CLKSOURCE_PLL1Q      =     (0x00000000U),
    RCC_SDMMC_CLKSOURCE_PLL2R      =     (RCC_CDCCIPR_SDMMCSEL),
    #endif /* RCC_D1CCIPR_SDMMCSEL */
};
/** @defgroup RCC_EC_RNG_CLKSOURCE  Peripheral RNG clock source selection
  * @{
  */
enum RCCRNGClkSource
{
    #if defined(RCC_D2CCIP2R_RNGSEL)
    RCC_RNG_CLKSOURCE_HSI48       =     (0x00000000U),
    RCC_RNG_CLKSOURCE_PLL1Q       =     (RCC_D2CCIP2R_RNGSEL_0),
    RCC_RNG_CLKSOURCE_LSE         =     (RCC_D2CCIP2R_RNGSEL_1),
    RCC_RNG_CLKSOURCE_LSI         =     (RCC_D2CCIP2R_RNGSEL_1 | RCC_D2CCIP2R_RNGSEL_0),
    #else
    RCC_RNG_CLKSOURCE_HSI48       =     (0x00000000U),
    RCC_RNG_CLKSOURCE_PLL1Q       =     (RCC_CDCCIP2R_RNGSEL_0),
    RCC_RNG_CLKSOURCE_LSE         =     (RCC_CDCCIP2R_RNGSEL_1),
    RCC_RNG_CLKSOURCE_LSI         =     (RCC_CDCCIP2R_RNGSEL_1 | RCC_CDCCIP2R_RNGSEL_0),
    #endif /* RCC_D2CCIP2R_RNGSEL */
};
/** @defgroup RCC_EC_USB_CLKSOURCE  Peripheral USB clock source selection
  * @{
  */
enum RCCUSBClkSource
{
    #if defined(RCC_D2CCIP2R_USBSEL)
    RCC_USB_CLKSOURCE_DISABLE    =      (0x00000000U),
    RCC_USB_CLKSOURCE_PLL1Q      =      (RCC_D2CCIP2R_USBSEL_0),
    RCC_USB_CLKSOURCE_PLL3Q      =      (RCC_D2CCIP2R_USBSEL_1),
    RCC_USB_CLKSOURCE_HSI48      =      (RCC_D2CCIP2R_USBSEL_1 | RCC_D2CCIP2R_USBSEL_0),
    #else
    RCC_USB_CLKSOURCE_DISABLE    =      (0x00000000U),
    RCC_USB_CLKSOURCE_PLL1Q      =      (RCC_CDCCIP2R_USBSEL_0),
    RCC_USB_CLKSOURCE_PLL3Q      =      (RCC_CDCCIP2R_USBSEL_1),
    RCC_USB_CLKSOURCE_HSI48      =      (RCC_CDCCIP2R_USBSEL_1 | RCC_CDCCIP2R_USBSEL_0),
    #endif /* RCC_D2CCIP2R_USBSEL */
};
/** @defgroup RCC_EC_CEC_CLKSOURCE  Peripheral CEC clock source selection
  * @{
  */
enum RCCCECClkSource
{
    #if defined(RCC_D2CCIP2R_CECSEL)
    RCC_CEC_CLKSOURCE_LSE           =   (0x00000000U),
    RCC_CEC_CLKSOURCE_LSI           =   (RCC_D2CCIP2R_CECSEL_0),
    RCC_CEC_CLKSOURCE_CSI_DIV122    =   (RCC_D2CCIP2R_CECSEL_1),
    #else
    RCC_CEC_CLKSOURCE_LSE           =   (0x00000000U),
    RCC_CEC_CLKSOURCE_LSI           =   (RCC_CDCCIP2R_CECSEL_0),
    RCC_CEC_CLKSOURCE_CSI_DIV122    =   (RCC_CDCCIP2R_CECSEL_1),
    #endif
};
/** @defgroup RCC_EC_DSI_CLKSOURCE  Peripheral DSI clock source selection
  * @{
  */
enum RCCDSIClkSource
{
    #if defined(DSI)
    RCC_DSI_CLKSOURCE_PHY        =       (0x00000000U),
    RCC_DSI_CLKSOURCE_PLL2Q      =       (RCC_D1CCIPR_DSISEL),
    #endif /* DSI */
};
/** @defgroup RCC_EC_DFSDM_CLKSOURCE  Peripheral DFSDM clock source selection
  * @{
  */
enum RCCDFSDM1ClkSource
{
    #if defined(RCC_D2CCIP1R_DFSDM1SEL)
    RCC_DFSDM1_CLKSOURCE_PCLK2      =    (0x00000000U),
    RCC_DFSDM1_CLKSOURCE_SYSCLK     =    (RCC_D2CCIP1R_DFSDM1SEL),
    #else
    RCC_DFSDM1_CLKSOURCE_PCLK2      =    (0x00000000U),
    RCC_DFSDM1_CLKSOURCE_SYSCLK     =    (RCC_CDCCIP1R_DFSDM1SEL),
    #endif /* RCC_D2CCIP1R_DFSDM1SEL */
};
/** @defgroup RCC_EC_DFSDM2_CLKSOURCE  Peripheral DFSDM2 clock source selection
  * @{
  */
enum RCCDFSDM2ClkSource
{
    #if defined(DFSDM2_BASE)
    RCC_DFSDM2_CLKSOURCE_PCLK4      =    (0x00000000U),
    RCC_DFSDM2_CLKSOURCE_SYSCLK     =    (RCC_SRDCCIPR_DFSDM2SEL),
    #endif /* DFSDM2_BASE */
};
/** @defgroup RCC_EC_FMC_CLKSOURCE  Peripheral FMC clock source selection
  * @{
  */
enum RCCFMCClkSource
{
    #if defined(RCC_D1CCIPR_FMCSEL)
    RCC_FMC_CLKSOURCE_HCLK      =       (0x00000000U),
    RCC_FMC_CLKSOURCE_PLL1Q     =       (RCC_D1CCIPR_FMCSEL_0),
    RCC_FMC_CLKSOURCE_PLL2R     =       (RCC_D1CCIPR_FMCSEL_1),
    RCC_FMC_CLKSOURCE_CLKP      =       (RCC_D1CCIPR_FMCSEL_0 | RCC_D1CCIPR_FMCSEL_1),
    #else
    RCC_FMC_CLKSOURCE_HCLK      =       (0x00000000U),
    RCC_FMC_CLKSOURCE_PLL1Q     =       (RCC_CDCCIPR_FMCSEL_0),
    RCC_FMC_CLKSOURCE_PLL2R     =       (RCC_CDCCIPR_FMCSEL_1),
    RCC_FMC_CLKSOURCE_CLKP      =       (RCC_CDCCIPR_FMCSEL_0 | RCC_CDCCIPR_FMCSEL_1),
    #endif /* RCC_D1CCIPR_FMCSEL */
};
/** @defgroup RCC_EC_QSPI_CLKSOURCE  Peripheral QSPI clock source selection
  * @{
  */
enum RCCQSPIClkSource
{
    #if defined(QUADSPI)
    RCC_QSPI_CLKSOURCE_HCLK       =     (0x00000000U),
    RCC_QSPI_CLKSOURCE_PLL1Q      =     (RCC_D1CCIPR_QSPISEL_0),
    RCC_QSPI_CLKSOURCE_PLL2R      =     (RCC_D1CCIPR_QSPISEL_1),
    RCC_QSPI_CLKSOURCE_CLKP       =     (RCC_D1CCIPR_QSPISEL_0 | RCC_D1CCIPR_QSPISEL_1),
    #endif /* QUADSPI */
};
/** @defgroup RCC_EC_OSPI_CLKSOURCE  Peripheral OSPI clock source selection
  * @{
  */
enum RCCOSPIClkSource
{
    #if defined(OCTOSPI1) || defined(OCTOSPI2)
    #if defined(RCC_D1CCIPR_OCTOSPISEL)
    RCC_OSPI_CLKSOURCE_HCLK      =      (0x00000000U),
    RCC_OSPI_CLKSOURCE_PLL1Q     =      (RCC_D1CCIPR_OCTOSPISEL_0),
    RCC_OSPI_CLKSOURCE_PLL2R     =      (RCC_D1CCIPR_OCTOSPISEL_1),
    RCC_OSPI_CLKSOURCE_CLKP      =      (RCC_D1CCIPR_OCTOSPISEL_0 | RCC_D1CCIPR_OCTOSPISEL_1),
    #else
    RCC_OSPI_CLKSOURCE_HCLK      =      (0x00000000U),
    RCC_OSPI_CLKSOURCE_PLL1Q     =      (RCC_CDCCIPR_OCTOSPISEL_0),
    RCC_OSPI_CLKSOURCE_PLL2R     =      (RCC_CDCCIPR_OCTOSPISEL_1),
    RCC_OSPI_CLKSOURCE_CLKP      =      (RCC_CDCCIPR_OCTOSPISEL_0 | RCC_CDCCIPR_OCTOSPISEL_1),
    #endif /* RCC_D1CCIPR_OCTOSPISEL */
    #endif /* defined(OCTOSPI1) || defined(OCTOSPI2) */
};
/** @defgroup RCC_EC_CLKP_CLKSOURCE  Peripheral CLKP clock source selection
  * @{
  */
enum RCCCLKPClkSource
{
    #if defined(RCC_D1CCIPR_CKPERSEL)
    RCC_CLKP_CLKSOURCE_HSI        =     (0x00000000U),
    RCC_CLKP_CLKSOURCE_CSI        =     (RCC_D1CCIPR_CKPERSEL_0),
    RCC_CLKP_CLKSOURCE_HSE        =     (RCC_D1CCIPR_CKPERSEL_1),
    #else
    RCC_CLKP_CLKSOURCE_HSI        =     (0x00000000U),
    RCC_CLKP_CLKSOURCE_CSI        =     (RCC_CDCCIPR_CKPERSEL_0),
    RCC_CLKP_CLKSOURCE_HSE        =     (RCC_CDCCIPR_CKPERSEL_1),
    #endif /* RCC_D1CCIPR_CKPERSEL */
};
/** @defgroup RCC_EC_SPIx_CLKSOURCE  Peripheral SPI clock source selection
  * @{
  */
enum RCCSPIxClkSource
{
    #if defined(RCC_D2CCIP1R_SPI123SEL)
    RCC_SPI123_CLKSOURCE_PLL1Q     =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI123SEL, RCC_D2CCIP1R_SPI123SEL_Pos, 0x00000000U),
    RCC_SPI123_CLKSOURCE_PLL2P     =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI123SEL, RCC_D2CCIP1R_SPI123SEL_Pos, RCC_D2CCIP1R_SPI123SEL_0),
    RCC_SPI123_CLKSOURCE_PLL3P     =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI123SEL, RCC_D2CCIP1R_SPI123SEL_Pos, RCC_D2CCIP1R_SPI123SEL_1),
    RCC_SPI123_CLKSOURCE_I2S_CKIN  =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI123SEL, RCC_D2CCIP1R_SPI123SEL_Pos, RCC_D2CCIP1R_SPI123SEL_0 | RCC_D2CCIP1R_SPI123SEL_1),
    RCC_SPI123_CLKSOURCE_CLKP      =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI123SEL, RCC_D2CCIP1R_SPI123SEL_Pos, RCC_D2CCIP1R_SPI123SEL_2),
    #else
    RCC_SPI123_CLKSOURCE_PLL1Q     =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI123SEL, RCC_CDCCIP1R_SPI123SEL_Pos, 0x00000000U),
    RCC_SPI123_CLKSOURCE_PLL2P     =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI123SEL, RCC_CDCCIP1R_SPI123SEL_Pos, RCC_CDCCIP1R_SPI123SEL_0),
    RCC_SPI123_CLKSOURCE_PLL3P     =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI123SEL, RCC_CDCCIP1R_SPI123SEL_Pos, RCC_CDCCIP1R_SPI123SEL_1),
    RCC_SPI123_CLKSOURCE_I2S_CKIN  =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI123SEL, RCC_CDCCIP1R_SPI123SEL_Pos, RCC_CDCCIP1R_SPI123SEL_0 | RCC_CDCCIP1R_SPI123SEL_1),
    RCC_SPI123_CLKSOURCE_CLKP      =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI123SEL, RCC_CDCCIP1R_SPI123SEL_Pos, RCC_CDCCIP1R_SPI123SEL_2),
    #endif /* RCC_D2CCIP1R_SPI123SEL */
    #if defined(RCC_D2CCIP1R_SPI45SEL)
    RCC_SPI45_CLKSOURCE_PCLK2      =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  0x00000000U),
    RCC_SPI45_CLKSOURCE_PLL2Q      =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  RCC_D2CCIP1R_SPI45SEL_0),
    RCC_SPI45_CLKSOURCE_PLL3Q      =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  RCC_D2CCIP1R_SPI45SEL_1),
    RCC_SPI45_CLKSOURCE_HSI        =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  RCC_D2CCIP1R_SPI45SEL_0 | RCC_D2CCIP1R_SPI45SEL_1),
    RCC_SPI45_CLKSOURCE_CSI        =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  RCC_D2CCIP1R_SPI45SEL_2),
    RCC_SPI45_CLKSOURCE_HSE        =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  RCC_D2CCIP1R_SPI45SEL_0 | RCC_D2CCIP1R_SPI45SEL_2),
    #else
    RCC_SPI45_CLKSOURCE_PCLK2      =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  0x00000000U),
    RCC_SPI45_CLKSOURCE_PLL2Q      =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  RCC_CDCCIP1R_SPI45SEL_0),
    RCC_SPI45_CLKSOURCE_PLL3Q      =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  RCC_CDCCIP1R_SPI45SEL_1),
    RCC_SPI45_CLKSOURCE_HSI        =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  RCC_CDCCIP1R_SPI45SEL_0 | RCC_CDCCIP1R_SPI45SEL_1),
    RCC_SPI45_CLKSOURCE_CSI        =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  RCC_CDCCIP1R_SPI45SEL_2),
    RCC_SPI45_CLKSOURCE_HSE        =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  RCC_CDCCIP1R_SPI45SEL_0 | RCC_CDCCIP1R_SPI45SEL_2),
    #endif /* (RCC_D2CCIP1R_SPI45SEL */
    #if defined(RCC_D3CCIPR_SPI6SEL)
    RCC_SPI6_CLKSOURCE_PCLK4       =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    0x00000000U),
    RCC_SPI6_CLKSOURCE_PLL2Q       =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    RCC_D3CCIPR_SPI6SEL_0),
    RCC_SPI6_CLKSOURCE_PLL3Q       =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    RCC_D3CCIPR_SPI6SEL_1),
    RCC_SPI6_CLKSOURCE_HSI         =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    RCC_D3CCIPR_SPI6SEL_0 | RCC_D3CCIPR_SPI6SEL_1),
    RCC_SPI6_CLKSOURCE_CSI         =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    RCC_D3CCIPR_SPI6SEL_2),
    RCC_SPI6_CLKSOURCE_HSE         =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    RCC_D3CCIPR_SPI6SEL_0 | RCC_D3CCIPR_SPI6SEL_2),
    #else
    RCC_SPI6_CLKSOURCE_PCLK4       =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    0x00000000U),
    RCC_SPI6_CLKSOURCE_PLL2Q       =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    RCC_SRDCCIPR_SPI6SEL_0),
    RCC_SPI6_CLKSOURCE_PLL3Q       =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    RCC_SRDCCIPR_SPI6SEL_1),
    RCC_SPI6_CLKSOURCE_HSI         =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    RCC_SRDCCIPR_SPI6SEL_0 | RCC_SRDCCIPR_SPI6SEL_1),
    RCC_SPI6_CLKSOURCE_CSI         =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    RCC_SRDCCIPR_SPI6SEL_2),
    RCC_SPI6_CLKSOURCE_HSE         =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    RCC_SRDCCIPR_SPI6SEL_0 | RCC_SRDCCIPR_SPI6SEL_2),
    RCC_SPI6_CLKSOURCE_I2S_CKIN    =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,    RCC_SRDCCIPR_SPI6SEL_Pos,    RCC_SRDCCIPR_SPI6SEL_1 | RCC_SRDCCIPR_SPI6SEL_2),
    #endif /* RCC_D3CCIPR_SPI6SEL */
};
/** @defgroup RCC_EC_SPDIF_CLKSOURCE  Peripheral SPDIF clock source selection
  * @{
  */
enum RCCSPDIFClkSource
{
    #if defined(RCC_D2CCIP1R_SPDIFSEL)
    RCC_SPDIF_CLKSOURCE_PLL1Q     =     (0x00000000U),
    RCC_SPDIF_CLKSOURCE_PLL2R     =     (RCC_D2CCIP1R_SPDIFSEL_0),
    RCC_SPDIF_CLKSOURCE_PLL3R     =     (RCC_D2CCIP1R_SPDIFSEL_1),
    RCC_SPDIF_CLKSOURCE_HSI       =     (RCC_D2CCIP1R_SPDIFSEL_0 | RCC_D2CCIP1R_SPDIFSEL_1),
    #else
    RCC_SPDIF_CLKSOURCE_PLL1Q     =     (0x00000000U),
    RCC_SPDIF_CLKSOURCE_PLL2R     =     (RCC_CDCCIP1R_SPDIFSEL_0),
    RCC_SPDIF_CLKSOURCE_PLL3R     =     (RCC_CDCCIP1R_SPDIFSEL_1),
    RCC_SPDIF_CLKSOURCE_HSI       =     (RCC_CDCCIP1R_SPDIFSEL_0 | RCC_CDCCIP1R_SPDIFSEL_1),
    #endif /* RCC_D2CCIP1R_SPDIFSEL */
};
/** @defgroup RCC_EC_FDCAN_CLKSOURCE  Peripheral FDCAN clock source selection
  * @{
  */
enum RCCFDCANClkSource
{
    #if defined(FDCAN1) || defined(FDCAN2)
    #if defined(RCC_D2CCIP1R_FDCANSEL)
    RCC_FDCAN_CLKSOURCE_HSE       =     (0x00000000U),
    RCC_FDCAN_CLKSOURCE_PLL1Q     =     (RCC_D2CCIP1R_FDCANSEL_0),
    RCC_FDCAN_CLKSOURCE_PLL2Q     =     (RCC_D2CCIP1R_FDCANSEL_1),
    #else
    RCC_FDCAN_CLKSOURCE_HSE       =     (0x00000000U),
    RCC_FDCAN_CLKSOURCE_PLL1Q     =     (RCC_CDCCIP1R_FDCANSEL_0),
    RCC_FDCAN_CLKSOURCE_PLL2Q     =     (RCC_CDCCIP1R_FDCANSEL_1),
    #endif /* RCC_D2CCIP1R_FDCANSEL */
    #endif /*FDCAN1 || FDCAN2*/
};
/** @defgroup RCC_EC_SWP_CLKSOURCE  Peripheral SWP clock source selection
  * @{
  */
enum RCCSWPClkSource
{
    #if defined(RCC_D2CCIP1R_SWPSEL)
    RCC_SWP_CLKSOURCE_PCLK1       =     (0x00000000U),
    RCC_SWP_CLKSOURCE_HSI         =     (RCC_D2CCIP1R_SWPSEL),
    #else
    RCC_SWP_CLKSOURCE_PCLK1       =     (0x00000000U),
    RCC_SWP_CLKSOURCE_HSI         =     (RCC_CDCCIP1R_SWPSEL),
    #endif /* RCC_D2CCIP1R_SWPSEL */
};
/** @defgroup RCC_EC_ADC_CLKSOURCE  Peripheral ADC clock source selection
  * @{
  */
enum RCCADCClkSource
{
    #if defined(RCC_D3CCIPR_ADCSEL)
    RCC_ADC_CLKSOURCE_PLL2P       =     (0x00000000U),
    RCC_ADC_CLKSOURCE_PLL3R       =     (RCC_D3CCIPR_ADCSEL_0),
    RCC_ADC_CLKSOURCE_CLKP        =     (RCC_D3CCIPR_ADCSEL_1),
    #else
    RCC_ADC_CLKSOURCE_PLL2P       =     (0x00000000U),
    RCC_ADC_CLKSOURCE_PLL3R       =     (RCC_SRDCCIPR_ADCSEL_0),
    RCC_ADC_CLKSOURCE_CLKP        =     (RCC_SRDCCIPR_ADCSEL_1),
    #endif /* RCC_D3CCIPR_ADCSEL */
};
/** @defgroup RCC_EC_USARTx  Peripheral USART get clock source
  * @{
  */
enum RCCUSARTxGetClkSource
{
    #if defined (RCC_D2CCIP2R_USART16SEL)
    RCC_USART16_CLKSOURCE     =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16SEL, RCC_D2CCIP2R_USART16SEL_Pos, 0x00000000U),
    #elif defined (RCC_D2CCIP2R_USART16910SEL)
    RCC_USART16_CLKSOURCE     =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART16910SEL, RCC_D2CCIP2R_USART16910SEL_Pos, 0x00000000U),
    /* alias*/
    RCC_USART16910_CLKSOURCE  =    RCC_USART16_CLKSOURCE,
    #else
    RCC_USART16_CLKSOURCE     =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART16910SEL, RCC_CDCCIP2R_USART16910SEL_Pos, 0x00000000U),
    /* alias*/
    RCC_USART16910_CLKSOURCE  =    RCC_USART16_CLKSOURCE,
    #endif /* RCC_D2CCIP2R_USART16SEL */
    #if defined (RCC_D2CCIP2R_USART28SEL)
    RCC_USART234578_CLKSOURCE =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_USART28SEL, RCC_D2CCIP2R_USART28SEL_Pos, 0x00000000U),
    #else
    RCC_USART234578_CLKSOURCE =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_USART234578SEL, RCC_CDCCIP2R_USART234578SEL_Pos, 0x00000000U),
    #endif /* RCC_D2CCIP2R_USART28SEL */
};
/** @defgroup RCC_EC_LPUARTx  Peripheral LPUART get clock source
  * @{
  */
enum RCCLPUARTxGetClkSource
{
  #if defined(RCC_D3CCIPR_LPUART1SEL)
  RCC_LPUART1_CLKSOURCE    =     RCC_D3CCIPR_LPUART1SEL,
  #else
  RCC_LPUART1_CLKSOURCE    =     RCC_SRDCCIPR_LPUART1SEL,
  #endif /* RCC_D3CCIPR_LPUART1SEL */
};
/** @defgroup RCC_EC_I2Cx  Peripheral I2C get clock source
  * @{
  */
enum RCCI2CxGetClkSource
{
    #if defined(RCC_D2CCIP2R_I2C123SEL)
    RCC_I2C123_CLKSOURCE     =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C123SEL, RCC_D2CCIP2R_I2C123SEL_Pos, 0x00000000U),
    /* alias */
    RCC_I2C1235_CLKSOURCE    =     RCC_I2C123_CLKSOURCE,
    #elif defined(RCC_D2CCIP2R_I2C1235SEL)
    RCC_I2C1235_CLKSOURCE    =     CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_I2C1235SEL, RCC_D2CCIP2R_I2C1235SEL_Pos, 0x00000000U),
    /* alias */
    RCC_I2C123_CLKSOURCE     =     RCC_I2C1235_CLKSOURCE,
    #else
    RCC_I2C123_CLKSOURCE     =     CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_I2C123SEL, RCC_CDCCIP2R_I2C123SEL_Pos, 0x00000000U),
    /* alias */
    RCC_I2C1235_CLKSOURCE    =     RCC_I2C123_CLKSOURCE,
    #endif /* RCC_D2CCIP2R_I2C123SEL */
    #if defined(RCC_D3CCIPR_I2C4SEL)
    RCC_I2C4_CLKSOURCE       =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_I2C4SEL,    RCC_D3CCIPR_I2C4SEL_Pos,    0x00000000U),
    #else
    RCC_I2C4_CLKSOURCE       =     CLKSOURCE(SRDCCIP, RCC_SRDCCIPR_I2C4SEL,   RCC_SRDCCIPR_I2C4SEL_Pos,   0x00000000U),
    #endif /* RCC_D3CCIPR_I2C4SEL */
};
/** @defgroup RCC_EC_LPTIMx  Peripheral LPTIM get clock source
  * @{
  */
enum RCCLPTIMxGetClkSource
{
    #if defined(RCC_D2CCIP2R_LPTIM1SEL)
    RCC_LPTIM1_CLKSOURCE      =    CLKSOURCE(D2CCIP2, RCC_D2CCIP2R_LPTIM1SEL,  RCC_D2CCIP2R_LPTIM1SEL_Pos,      0x00000000U),
    #else
    RCC_LPTIM1_CLKSOURCE      =    CLKSOURCE(CDCCIP2, RCC_CDCCIP2R_LPTIM1SEL,  RCC_CDCCIP2R_LPTIM1SEL_Pos,      0x00000000U),
    #endif /* RCC_D2CCIP2R_LPTIM1SEL) */
    #if defined(RCC_D3CCIPR_LPTIM2SEL)
    RCC_LPTIM2_CLKSOURCE      =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM2SEL,   RCC_D3CCIPR_LPTIM2SEL_Pos,       0x00000000U),
    #else
    RCC_LPTIM2_CLKSOURCE      =    CLKSOURCE(SRDCCIP, RCC_SRDCCIPR_LPTIM2SEL,  RCC_SRDCCIPR_LPTIM2SEL_Pos,      0x00000000U),
    #endif /* RCC_D3CCIPR_LPTIM2SEL */
    #if defined(RCC_D3CCIPR_LPTIM345SEL)
    RCC_LPTIM345_CLKSOURCE    =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_LPTIM345SEL, RCC_D3CCIPR_LPTIM345SEL_Pos,     0x00000000U),
    #else
    RCC_LPTIM345_CLKSOURCE    =    CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_LPTIM3SEL, RCC_SRDCCIPR_LPTIM3SEL_Pos,      0x00000000U),
    RCC_LPTIM3_CLKSOURCE      =    RCC_LPTIM345_CLKSOURCE,  /* alias */
    #endif /* RCC_D3CCIPR_LPTIM345SEL */
};
/** @defgroup RCC_EC_SAIx  Peripheral SAI get clock source
  * @{
  */
enum RCCSAIxGetClkSource
{
    #if defined(RCC_D2CCIP1R_SAI1SEL)
    RCC_SAI1_CLKSOURCE        =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI1SEL,  RCC_D2CCIP1R_SAI1SEL_Pos,  0x00000000U),
    #else
    RCC_SAI1_CLKSOURCE        =    CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SAI1SEL,  RCC_CDCCIP1R_SAI1SEL_Pos,  0x00000000U),
    #endif /* RCC_D2CCIP1R_SAI1SEL */
    #if defined(RCC_D2CCIP1R_SAI23SEL)
    RCC_SAI23_CLKSOURCE       =    CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SAI23SEL, RCC_D2CCIP1R_SAI23SEL_Pos, 0x00000000U),
    #endif /* RCC_D2CCIP1R_SAI23SEL */
    #if defined(RCC_CDCCIP1R_SAI2ASEL)
    RCC_SAI2A_CLKSOURCE       =    CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2ASEL,  RCC_CDCCIP1R_SAI2ASEL_Pos,  0x00000000U),
    #endif /* RCC_CDCCIP1R_SAI2ASEL */
    #if defined(RCC_CDCCIP1R_SAI2BSEL)
    RCC_SAI2B_CLKSOURCE       =    CLKSOURCE(CDCCIP1,  RCC_CDCCIP1R_SAI2BSEL,  RCC_CDCCIP1R_SAI2BSEL_Pos,  0x00000000U),
    #endif /*  RCC_CDCCIP1R_SAI2BSEL */
    #if defined(RCC_D3CCIPR_SAI4ASEL)
    RCC_SAI4A_CLKSOURCE       =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4ASEL,  RCC_D3CCIPR_SAI4ASEL_Pos,  0x00000000U),
    #endif /* RCC_D3CCIPR_SAI4ASEL */
    #if defined(RCC_D3CCIPR_SAI4BSEL)
    RCC_SAI4B_CLKSOURCE       =    CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SAI4BSEL,  RCC_D3CCIPR_SAI4BSEL_Pos,  0x00000000U),
    #endif /*  RCC_D3CCIPR_SAI4BSEL */
};
/** @defgroup RCC_EC_SDMMC  Peripheral SDMMC get clock source
  * @{
  */
enum RCCSDMMCGetClkSource
{
    #if defined(RCC_D1CCIPR_SDMMCSEL)
    RCC_SDMMC_CLKSOURCE      =     RCC_D1CCIPR_SDMMCSEL,
    #else
    RCC_SDMMC_CLKSOURCE      =     RCC_CDCCIPR_SDMMCSEL,
    #endif /* RCC_D1CCIPR_SDMMCSEL */
};
/** @defgroup RCC_EC_RNG Peripheral RNG get clock source
  * @{
  */
enum RCCRNGGetClkSource
{
    #if (RCC_D2CCIP2R_RNGSEL)
    RCC_RNG_CLKSOURCE        =     RCC_D2CCIP2R_RNGSEL,
    #else
    RCC_RNG_CLKSOURCE        =     RCC_CDCCIP2R_RNGSEL,
    #endif /* RCC_D2CCIP2R_RNGSEL */
};
/** @defgroup RCC_EC_USB  Peripheral USB get clock source
  * @{
  */
enum RCCUSBGetClkSource
{
    #if (RCC_D2CCIP2R_USBSEL)
    RCC_USB_CLKSOURCE        =     RCC_D2CCIP2R_USBSEL,
    #else
    RCC_USB_CLKSOURCE        =     RCC_CDCCIP2R_USBSEL,
    #endif  /* RCC_D2CCIP2R_USBSEL */
};
/** @defgroup RCC_EC_CEC  Peripheral CEC get clock source
  * @{
  */
enum RCCCECGetClkSource
{
    #if (RCC_D2CCIP2R_CECSEL)
    RCC_CEC_CLKSOURCE        =     RCC_D2CCIP2R_CECSEL,
    #else
    RCC_CEC_CLKSOURCE        =     RCC_CDCCIP2R_CECSEL,
    #endif /* RCC_D2CCIP2R_CECSEL */
};
/** @defgroup RCC_EC_DSI  Peripheral DSI get clock source
  * @{
  */
enum RCCDSIGetClkSource
{
    #if defined(DSI)
    RCC_DSI_CLKSOURCE       =      RCC_D1CCIPR_DSISEL,
    #endif /* DSI */
};
/** @defgroup RCC_EC_DFSDM  Peripheral DFSDM get clock source
  * @{
  */
enum RCCDFSDM1GetClkSource
{
    #if defined(RCC_D2CCIP1R_DFSDM1SEL)
    RCC_DFSDM1_CLKSOURCE     =     RCC_D2CCIP1R_DFSDM1SEL,
    #else
    RCC_DFSDM1_CLKSOURCE     =     RCC_CDCCIP1R_DFSDM1SEL,
    #endif /* RCC_D2CCIP1R_DFSDM1SEL */
};
/** @defgroup RCC_EC_DFSDM2  Peripheral DFSDM2 get clock source
  * @{
  */
enum RCCDFSDM2GetClkSource
{
    #if defined(DFSDM2_BASE)
    RCC_DFSDM2_CLKSOURCE     =     RCC_SRDCCIPR_DFSDM2SEL,
    #endif /* DFSDM2_BASE */
};
/** @defgroup RCC_EC_FMC  Peripheral FMC get clock source
  * @{
  */
enum RCCFMCGetClkSource
{
    #if defined(RCC_D1CCIPR_FMCSEL)
    RCC_FMC_CLKSOURCE       =      RCC_D1CCIPR_FMCSEL,
    #else
    RCC_FMC_CLKSOURCE       =      RCC_CDCCIPR_FMCSEL,
    #endif
};
/** @defgroup RCC_EC_QSPI  Peripheral QSPI get clock source
  * @{
  */
enum RCCQSPIGetClkSource
{
    #if defined(QUADSPI)
    RCC_QSPI_CLKSOURCE       =     RCC_D1CCIPR_QSPISEL,
    #endif /* QUADSPI */
};
/** @defgroup RCC_EC_OSPI Peripheral OSPI get clock source
  * @{
  */
enum RCCOSPIGetClkSource
{
    #if defined(OCTOSPI1) || defined(OCTOSPI2)
    #if defined(RCC_CDCCIPR_OCTOSPISEL)
    RCC_OSPI_CLKSOURCE      =      RCC_CDCCIPR_OCTOSPISEL,
    #else
    RCC_OSPI_CLKSOURCE      =      RCC_D1CCIPR_OCTOSPISEL,
    #endif /* RCC_CDCCIPR_OCTOSPISEL */
    #endif /* OCTOSPI1 || OCTOSPI2 */
};
/** @defgroup RCC_EC_CLKP Peripheral CLKP get clock source
  * @{
  */
enum RCCCLKPGetClkSource
{
    #if defined(RCC_D1CCIPR_CKPERSEL)
    RCC_CLKP_CLKSOURCE       =     RCC_D1CCIPR_CKPERSEL,
    #else
    RCC_CLKP_CLKSOURCE       =     RCC_CDCCIPR_CKPERSEL,
    #endif /* RCC_D1CCIPR_CKPERSEL */
};
/** @defgroup RCC_EC_SPIx  Peripheral SPI get clock source
  * @{
  */
enum RCCSPIxGetClkSource
{
    #if defined(RCC_D2CCIP1R_SPI123SEL)
    RCC_SPI123_CLKSOURCE     =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI123SEL, RCC_D2CCIP1R_SPI123SEL_Pos, 0x00000000U),
    #else
    RCC_SPI123_CLKSOURCE     =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI123SEL, RCC_CDCCIP1R_SPI123SEL_Pos, 0x00000000U),
    #endif /* RCC_D2CCIP1R_SPI123SEL */
    #if defined(RCC_D2CCIP1R_SPI45SEL)
    RCC_SPI45_CLKSOURCE      =     CLKSOURCE(D2CCIP1, RCC_D2CCIP1R_SPI45SEL,  RCC_D2CCIP1R_SPI45SEL_Pos,  0x00000000U),
    #else
    RCC_SPI45_CLKSOURCE      =     CLKSOURCE(CDCCIP1, RCC_CDCCIP1R_SPI45SEL,  RCC_CDCCIP1R_SPI45SEL_Pos,  0x00000000U),
    #endif /* RCC_D2CCIP1R_SPI45SEL */
    #if defined(RCC_D3CCIPR_SPI6SEL)
    RCC_SPI6_CLKSOURCE       =     CLKSOURCE(D3CCIP,  RCC_D3CCIPR_SPI6SEL,    RCC_D3CCIPR_SPI6SEL_Pos,    0x00000000U),
    #else
    RCC_SPI6_CLKSOURCE       =     CLKSOURCE(SRDCCIP,  RCC_SRDCCIPR_SPI6SEL,   RCC_SRDCCIPR_SPI6SEL_Pos,  0x00000000U),
    #endif /* RCC_D3CCIPR_SPI6SEL */
};
/** @defgroup RCC_EC_SPDIF  Peripheral SPDIF get clock source
  * @{
  */
enum RCCSPDIFGetClkSource
{
    #if defined(RCC_D2CCIP1R_SPDIFSEL)
    RCC_SPDIF_CLKSOURCE      =     RCC_D2CCIP1R_SPDIFSEL,
    #else
    RCC_SPDIF_CLKSOURCE      =     RCC_CDCCIP1R_SPDIFSEL,
    #endif /* RCC_D2CCIP1R_SPDIFSEL */
};
/** @defgroup RCC_EC_FDCAN  Peripheral FDCAN get clock source
  * @{
  */
enum RCCFDCANGetClkSource
{
    #if defined(FDCAN1) || defined(FDCAN2)
    #if defined(RCC_D2CCIP1R_FDCANSEL)
    RCC_FDCAN_CLKSOURCE      =     RCC_D2CCIP1R_FDCANSEL,
    #else
    RCC_FDCAN_CLKSOURCE      =     RCC_CDCCIP1R_FDCANSEL,
    #endif
    #endif /*FDCAN1 || FDCAN2*/
};
/** @defgroup RCC_EC_SWP  Peripheral SWP get clock source
  * @{
  */
enum RCCSWPGetClkSource
{
    #if defined(RCC_D2CCIP1R_SWPSEL)
    RCC_SWP_CLKSOURCE      =       RCC_D2CCIP1R_SWPSEL,
    #else
    RCC_SWP_CLKSOURCE      =       RCC_CDCCIP1R_SWPSEL,
    #endif /* RCC_D2CCIP1R_SWPSEL */
};
/** @defgroup RCC_EC_ADC  Peripheral ADC get clock source
  * @{
  */
enum RCCADCGetClkSource
{
    #if defined(RCC_D3CCIPR_ADCSEL)
    RCC_ADC_CLKSOURCE     =       RCC_D3CCIPR_ADCSEL,
    #else
    RCC_ADC_CLKSOURCE     =       RCC_SRDCCIPR_ADCSEL,
    #endif /* RCC_D3CCIPR_ADCSEL */
};
/** @defgroup RCC_EC_RTC_CLKSOURCE  RTC clock source selection
  * @{
  */
enum RCCRTCGetClkSource
{
    RCC_RTC_CLKSOURCE_NONE    =      (uint32_t)(0x00000000U),
    RCC_RTC_CLKSOURCE_LSE     =      (uint32_t)(RCC_BDCR_RTCSEL_0),
    RCC_RTC_CLKSOURCE_LSI     =      (uint32_t)(RCC_BDCR_RTCSEL_1),
    RCC_RTC_CLKSOURCE_HSE     =      (uint32_t)(RCC_BDCR_RTCSEL_0 | RCC_BDCR_RTCSEL_1),
};
/** @defgroup RCC_EC_TIM_CLKPRESCALER  Timers clocks prescalers selection
  * @{
  */
enum RCCTIMClkPrescaler
{
    RCC_TIM_PRESCALER_TWICE        =  (uint32_t)(0x00000000U),
    RCC_TIM_PRESCALER_FOUR_TIMES   =  (uint32_t)(RCC_CFGR_TIMPRE),
};
/** @defgroup RCC_EC_HRTIM_CLKSOURCE  High Resolution Timers clock selection
  * @{
  */
enum RCCHRTIMClkSource
{
    #if defined(HRTIM1)
    RCC_HRTIM_CLKSOURCE_TIM     =     (uint32_t)(0x00000000U),           /* HRTIM Clock source is same as other timers */
    RCC_HRTIM_CLKSOURCE_CPU     =     (uint32_t)(RCC_CFGR_HRTIMSEL),     /* HRTIM Clock source is the CPU clock */
    #endif /* HRTIM1 */
};
/** @defgroup RCC_EC_PLLSOURCE   All PLLs entry clock source
  * @{
  */
enum RCCPLLClkSource
{
    RCC_PLLSOURCE_HSI        =       RCC_PLLCKSELR_PLLSRC_HSI,
    RCC_PLLSOURCE_CSI        =       RCC_PLLCKSELR_PLLSRC_CSI,
    RCC_PLLSOURCE_HSE        =       RCC_PLLCKSELR_PLLSRC_HSE,
    RCC_PLLSOURCE_NONE       =       RCC_PLLCKSELR_PLLSRC_NONE,
};
/** @defgroup RCC_EC_PLLINPUTRANGE   All PLLs input range
  * @{
  */
enum RCCPLLInputRange
{
    RCC_PLLINPUTRANGE_1_2      =     (uint32_t)(0x00000000U),
    RCC_PLLINPUTRANGE_2_4      =     (uint32_t)(0x00000001),
    RCC_PLLINPUTRANGE_4_8      =     (uint32_t)(0x00000002),
    RCC_PLLINPUTRANGE_8_16     =     (uint32_t)(0x00000003),
};
/** @defgroup RCC_EC_PLLVCORANGE   All PLLs VCO range
  * @{
  */
enum RCCPLLVocRange
{
    RCC_PLLVCORANGE_WIDE       =    (uint32_t)(0x00000000U),      /* VCO output range: 192 to 836 MHz   OR  128 to 544 MHz (*) */
    RCC_PLLVCORANGE_MEDIUM     =    (uint32_t)(0x00000001),       /* VCO output range: 150 to 420 MHz */
};

enum RCCRTCClkSrc
{
    RCC_RTC_CLK_SRC_NONE    =   0,
    RCC_RTC_CLK_SRC_LSE     =   RCC_BDCR_RTCSEL_0,
    RCC_RTC_CLK_SRC_LSI     =   RCC_BDCR_RTCSEL_1,
    RCC_RTC_CLK_SRC_HSE     =   RCC_BDCR_RTCSEL
};
enum RCCPLLCLKType
{
    RCC_PLL1_CLK_FREQ_P,
    RCC_PLL1_CLK_FREQ_Q,
    RCC_PLL1_CLK_FREQ_R,
    RCC_PLL2_CLK_FREQ_P,
    RCC_PLL2_CLK_FREQ_Q,
    RCC_PLL2_CLK_FREQ_R,
    RCC_PLL3_CLK_FREQ_P,
    RCC_PLL3_CLK_FREQ_Q,
    RCC_PLL3_CLK_FREQ_R,
};

/** @defgroup EC_AHB3_GRP1_PERIPH  AHB3 GRP1 PERIPH
  * @{
  */
enum RCCAHB3GRP1PerClkType
{
    RCC_AHB3_GRP1_PERIPH_MDMA       =    RCC_AHB3ENR_MDMAEN,
    RCC_AHB3_GRP1_PERIPH_DMA2D      =    RCC_AHB3ENR_DMA2DEN,

    #if defined(JPEG)
    RCC_AHB3_GRP1_PERIPH_JPGDEC     =    RCC_AHB3ENR_JPGDECEN,
    #endif /* JPEG */

    RCC_AHB3_GRP1_PERIPH_FMC        =    RCC_AHB3ENR_FMCEN,
    #if defined(QUADSPI)
    RCC_AHB3_GRP1_PERIPH_QSPI       =    RCC_AHB3ENR_QSPIEN,
    #endif /* QUADSPI */
    #if defined(OCTOSPI1) || defined(OCTOSPI2)
    RCC_AHB3_GRP1_PERIPH_OSPI1      =    RCC_AHB3ENR_OSPI1EN,
    RCC_AHB3_GRP1_PERIPH_OSPI2      =    RCC_AHB3ENR_OSPI2EN,
    #endif /*(OCTOSPI1) || (OCTOSPI2)*/
    #if defined(OCTOSPIM)
    RCC_AHB3_GRP1_PERIPH_OCTOSPIM   =    RCC_AHB3ENR_IOMNGREN,
    #endif /* OCTOSPIM */
    #if defined(OTFDEC1) || defined(OTFDEC2)
    RCC_AHB3_GRP1_PERIPH_OTFDEC1    =    RCC_AHB3ENR_OTFDEC1EN,
    RCC_AHB3_GRP1_PERIPH_OTFDEC2    =    RCC_AHB3ENR_OTFDEC2EN,
    #endif /* (OTFDEC1) || (OTFDEC2) */
    #if defined(GFXMMU)
    RCC_AHB3_GRP1_PERIPH_GFXMMU     =    RCC_AHB3ENR_GFXMMUEN,
    #endif /* GFXMMU */
    RCC_AHB3_GRP1_PERIPH_SDMMC1     =    RCC_AHB3ENR_SDMMC1EN,
    RCC_AHB3_GRP1_PERIPH_FLASH      =    RCC_AHB3LPENR_FLASHLPEN,
    RCC_AHB3_GRP1_PERIPH_DTCM1      =    RCC_AHB3LPENR_DTCM1LPEN,
    RCC_AHB3_GRP1_PERIPH_DTCM2      =    RCC_AHB3LPENR_DTCM2LPEN,
    RCC_AHB3_GRP1_PERIPH_ITCM       =    RCC_AHB3LPENR_ITCMLPEN,
    #if defined(RCC_AHB3LPENR_AXISRAMLPEN)
    RCC_AHB3_GRP1_PERIPH_AXISRAM    =    RCC_AHB3LPENR_AXISRAMLPEN,
    #else
    RCC_AHB3_GRP1_PERIPH_AXISRAM1   =    RCC_AHB3LPENR_AXISRAM1LPEN,
    RCC_AHB3_GRP1_PERIPH_AXISRAM    =    LL_AHB3_GRP1_PERIPH_AXISRAM1,   /* for backward compatibility*/
    #endif /* RCC_AHB3LPENR_AXISRAMLPEN */
    #if defined(CD_AXISRAM2_BASE)
    RCC_AHB3_GRP1_PERIPH_AXISRAM2   =    RCC_AHB3LPENR_AXISRAM2LPEN,
    #endif /* CD_AXISRAM2_BASE */
    #if defined(CD_AXISRAM3_BASE)
    RCC_AHB3_GRP1_PERIPH_AXISRAM3   =    RCC_AHB3LPENR_AXISRAM3LPEN
    #endif /* CD_AXISRAM3_BASE */
};

/** @defgroup BUS_LL_EC_AHB1_GRP1_PERIPH  AHB1 GRP1 PERIPH
  * @{
  */
enum RCCAHB1GRP1PerClkType
{
    RCC_AHB1_GRP1_PERIPH_DMA1          = RCC_AHB1ENR_DMA1EN,
    RCC_AHB1_GRP1_PERIPH_DMA2          = RCC_AHB1ENR_DMA2EN,
    RCC_AHB1_GRP1_PERIPH_ADC12         = RCC_AHB1ENR_ADC12EN,
    #if defined(DUAL_CORE)
    RCC_AHB1_GRP1_PERIPH_ART           = RCC_AHB1ENR_ARTEN,
    #endif /* DUAL_CORE */
    #if defined(RCC_AHB1ENR_CRCEN)
    RCC_AHB1_GRP1_PERIPH_CRC           = RCC_AHB1ENR_CRCEN,
    #endif /* RCC_AHB1ENR_CRCEN */
    #if defined(ETH)
    RCC_AHB1_GRP1_PERIPH_ETH1MAC       = RCC_AHB1ENR_ETH1MACEN,
    RCC_AHB1_GRP1_PERIPH_ETH1TX        = RCC_AHB1ENR_ETH1TXEN,
    RCC_AHB1_GRP1_PERIPH_ETH1RX        = RCC_AHB1ENR_ETH1RXEN,
    #endif /* ETH */
    RCC_AHB1_GRP1_PERIPH_USB1OTGHS     = RCC_AHB1ENR_USB1OTGHSEN,
    RCC_AHB1_GRP1_PERIPH_USB1OTGHSULPI = RCC_AHB1ENR_USB1OTGHSULPIEN,
    #if defined(USB2_OTG_FS)
    RCC_AHB1_GRP1_PERIPH_USB2OTGHS     = RCC_AHB1ENR_USB2OTGHSEN,
    RCC_AHB1_GRP1_PERIPH_USB2OTGHSULPI = RCC_AHB1ENR_USB2OTGHSULPIEN
    #endif /* USB2_OTG_FS */
};

/** @defgroup EC_AHB2_GRP1_PERIPH  AHB2 GRP1 PERIPH
  * @{
  */
enum RCCAHB2GRP1PerClkType
{
    RCC_AHB2_GRP1_PERIPH_DCMI      =     RCC_AHB2ENR_DCMIEN,
    #if defined(HSEM) && defined(RCC_AHB2ENR_HSEMEN)
    RCC_AHB2_GRP1_PERIPH_HSEM      =     RCC_AHB2ENR_HSEMEN,
    #endif /* HSEM && RCC_AHB2ENR_HSEMEN */
    #if defined(CRYP)
    RCC_AHB2_GRP1_PERIPH_CRYP      =     RCC_AHB2ENR_CRYPEN,
    #endif /* CRYP */
    #if defined(HASH)
    RCC_AHB2_GRP1_PERIPH_HASH      =     RCC_AHB2ENR_HASHEN,
    #endif /* HASH */
    RCC_AHB2_GRP1_PERIPH_RNG       =     RCC_AHB2ENR_RNGEN,
    RCC_AHB2_GRP1_PERIPH_SDMMC2    =     RCC_AHB2ENR_SDMMC2EN,
    #if defined(FMAC)
    RCC_AHB2_GRP1_PERIPH_FMAC      =     RCC_AHB2ENR_FMACEN,
    #endif /* FMAC */
    #if defined(CORDIC)
    RCC_AHB2_GRP1_PERIPH_CORDIC    =     RCC_AHB2ENR_CORDICEN,
    #endif /* CORDIC */
    #if defined(BDMA1)
    RCC_AHB2_GRP1_PERIPH_BDMA1     =     RCC_AHB2ENR_BDMA1EN,
    #endif /* BDMA1 */
    #if defined(RCC_AHB2ENR_D2SRAM1EN)
    RCC_AHB2_GRP1_PERIPH_D2SRAM1   =     RCC_AHB2ENR_D2SRAM1EN,
    #else
    RCC_AHB2_GRP1_PERIPH_AHBSRAM1  =     RCC_AHB2ENR_AHBSRAM1EN,
    RCC_AHB2_GRP1_PERIPH_D2SRAM1   =     LL_AHB2_GRP1_PERIPH_AHBSRAM1,    /* for backward compatibility*/
    #endif /* RCC_AHB2ENR_D2SRAM1EN */
    #if defined(RCC_AHB2ENR_D2SRAM2EN)
    RCC_AHB2_GRP1_PERIPH_D2SRAM2   =     RCC_AHB2ENR_D2SRAM2EN,
    #else
    RCC_AHB2_GRP1_PERIPH_AHBSRAM2  =     RCC_AHB2ENR_AHBSRAM2EN,
    RCC_AHB2_GRP1_PERIPH_D2SRAM2   =     LL_AHB2_GRP1_PERIPH_AHBSRAM2,    /* for backward compatibility*/
    #endif /* RCC_AHB2ENR_D2SRAM2EN */
    #if defined(RCC_AHB2ENR_D2SRAM3EN)
    RCC_AHB2_GRP1_PERIPH_D2SRAM3   =     RCC_AHB2ENR_D2SRAM3EN
    #endif /* RCC_AHB2ENR_D2SRAM3EN */
};

/** @defgroup BUS_LL_EC_AHB4_GRP1_PERIPH  AHB4 GRP1 PERIPH
  * @{
  */
enum RCCAHB4GRP1PerClkType
{
    RCC_AHB4_GRP1_PERIPH_GPIOA     =     RCC_AHB4ENR_GPIOAEN,
    RCC_AHB4_GRP1_PERIPH_GPIOB     =     RCC_AHB4ENR_GPIOBEN,
    RCC_AHB4_GRP1_PERIPH_GPIOC     =     RCC_AHB4ENR_GPIOCEN,
    RCC_AHB4_GRP1_PERIPH_GPIOD     =     RCC_AHB4ENR_GPIODEN,
    RCC_AHB4_GRP1_PERIPH_GPIOE     =     RCC_AHB4ENR_GPIOEEN,
    RCC_AHB4_GRP1_PERIPH_GPIOF     =     RCC_AHB4ENR_GPIOFEN,
    RCC_AHB4_GRP1_PERIPH_GPIOG     =     RCC_AHB4ENR_GPIOGEN,
    RCC_AHB4_GRP1_PERIPH_GPIOH     =     RCC_AHB4ENR_GPIOHEN,
    #if defined(GPIOI)
    RCC_AHB4_GRP1_PERIPH_GPIOI     =     RCC_AHB4ENR_GPIOIEN,
    #endif /* GPIOI */
    RCC_AHB4_GRP1_PERIPH_GPIOJ     =     RCC_AHB4ENR_GPIOJEN,
    RCC_AHB4_GRP1_PERIPH_GPIOK     =     RCC_AHB4ENR_GPIOKEN,
    #if defined(RCC_AHB4ENR_CRCEN)
    RCC_AHB4_GRP1_PERIPH_CRC       =     RCC_AHB4ENR_CRCEN,
    #endif /* RCC_AHB4ENR_CRCEN */
    #if defined(BDMA2)
    RCC_AHB4_GRP1_PERIPH_BDMA2     =     RCC_AHB4ENR_BDMA2EN,
    RCC_AHB4_GRP1_PERIPH_BDMA      =     LL_AHB4_GRP1_PERIPH_BDMA2, /* for backward compatibility*/
    #else
    RCC_AHB4_GRP1_PERIPH_BDMA      =     RCC_AHB4ENR_BDMAEN,
    #endif /* BDMA2 */
    #if defined(ADC3)
    RCC_AHB4_GRP1_PERIPH_ADC3      =     RCC_AHB4ENR_ADC3EN,
    #endif /* ADC3 */
    #if defined(HSEM) && defined(RCC_AHB4ENR_HSEMEN)
    RCC_AHB4_GRP1_PERIPH_HSEM      =     RCC_AHB4ENR_HSEMEN,
    #endif /* HSEM && RCC_AHB4ENR_HSEMEN*/
    RCC_AHB4_GRP1_PERIPH_BKPRAM    =     RCC_AHB4ENR_BKPRAMEN,
    #if defined(RCC_AHB4LPENR_SRAM4LPEN)
    RCC_AHB4_GRP1_PERIPH_SRAM4     =     RCC_AHB4LPENR_SRAM4LPEN,
    RCC_AHB4_GRP1_PERIPH_D3SRAM1   =     RCC_AHB4_GRP1_PERIPH_SRAM4,
    #else
    RCC_AHB4_GRP1_PERIPH_SRDSRAM   =     RCC_AHB4ENR_SRDSRAMEN,
    RCC_AHB4_GRP1_PERIPH_SRAM4     =     RCC_AHB4_GRP1_PERIPH_SRDSRAM,  /* for backward compatibility*/
    RCC_AHB4_GRP1_PERIPH_D3SRAM1   =     RCC_AHB4_GRP1_PERIPH_SRDSRAM  /* for backward compatibility*/
    #endif /* RCC_AHB4ENR_D3SRAM1EN */
};
/** @defgroup EC_APB3_GRP1_PERIPH  APB3 GRP1 PERIPH
  * @{
  */
enum RCCAPB3GRP1PerClkType
{
    #if defined(LTDC)
    RCC_APB3_GRP1_PERIPH_LTDC       =    RCC_APB3ENR_LTDCEN,
    #endif /* LTDC */
    #if defined(DSI)
    RCC_APB3_GRP1_PERIPH_DSI        =    RCC_APB3ENR_DSIEN,
    #endif /* DSI */
    RCC_APB3_GRP1_PERIPH_WWDG1      =    RCC_APB3ENR_WWDG1EN,
    #if defined(RCC_APB3ENR_WWDGEN)
    RCC_APB3_GRP1_PERIPH_WWDG       =    LL_APB3_GRP1_PERIPH_WWDG1   /* for backward compatibility*/
    #endif /* RCC_APB3ENR_WWDGEN */
};
/** @defgroup EC_APB1_GRP1_PERIPH  APB1 GRP1 PERIPH
  * @{
  */
enum RCCAPB1GRP1PerClkType
{
    RCC_APB1_GRP1_PERIPH_TIM2      =     RCC_APB1LENR_TIM2EN,
    RCC_APB1_GRP1_PERIPH_TIM3      =     RCC_APB1LENR_TIM3EN,
    RCC_APB1_GRP1_PERIPH_TIM4      =     RCC_APB1LENR_TIM4EN,
    RCC_APB1_GRP1_PERIPH_TIM5      =     RCC_APB1LENR_TIM5EN,
    RCC_APB1_GRP1_PERIPH_TIM6      =     RCC_APB1LENR_TIM6EN,
    RCC_APB1_GRP1_PERIPH_TIM7      =     RCC_APB1LENR_TIM7EN,
    RCC_APB1_GRP1_PERIPH_TIM12     =     RCC_APB1LENR_TIM12EN,
    RCC_APB1_GRP1_PERIPH_TIM13     =     RCC_APB1LENR_TIM13EN,
    RCC_APB1_GRP1_PERIPH_TIM14     =     RCC_APB1LENR_TIM14EN,
    RCC_APB1_GRP1_PERIPH_LPTIM1    =     RCC_APB1LENR_LPTIM1EN,
#if defined(DUAL_CORE)
    RCC_APB1_GRP1_PERIPH_WWDG2     =     RCC_APB1LENR_WWDG2EN,
#endif /*DUAL_CORE*/
    RCC_APB1_GRP1_PERIPH_SPI2      =     RCC_APB1LENR_SPI2EN,
    RCC_APB1_GRP1_PERIPH_SPI3      =     RCC_APB1LENR_SPI3EN,
    RCC_APB1_GRP1_PERIPH_SPDIFRX   =     RCC_APB1LENR_SPDIFRXEN,
    RCC_APB1_GRP1_PERIPH_USART2    =     RCC_APB1LENR_USART2EN,
    RCC_APB1_GRP1_PERIPH_USART3    =     RCC_APB1LENR_USART3EN,
    RCC_APB1_GRP1_PERIPH_UART4     =     RCC_APB1LENR_UART4EN,
    RCC_APB1_GRP1_PERIPH_UART5     =     RCC_APB1LENR_UART5EN,
    RCC_APB1_GRP1_PERIPH_I2C1      =     RCC_APB1LENR_I2C1EN,
    RCC_APB1_GRP1_PERIPH_I2C2      =     RCC_APB1LENR_I2C2EN,
    RCC_APB1_GRP1_PERIPH_I2C3      =     RCC_APB1LENR_I2C3EN,
#if defined(I2C5)
    RCC_APB1_GRP1_PERIPH_I2C5      =     RCC_APB1LENR_I2C5EN,
#endif /* I2C5 */
#if defined(RCC_APB1LENR_CECEN)
    RCC_APB1_GRP1_PERIPH_CEC       =     RCC_APB1LENR_CECEN,
#else
    RCC_APB1_GRP1_PERIPH_HDMICEC   =     RCC_APB1LENR_HDMICECEN,
    RCC_APB1_GRP1_PERIPH_CEC       =     LL_APB1_GRP1_PERIPH_HDMICEC,   /* for backward compatibility*/
#endif /* RCC_APB1LENR_CECEN */
    RCC_APB1_GRP1_PERIPH_DAC12     =     RCC_APB1LENR_DAC12EN,
    RCC_APB1_GRP1_PERIPH_UART7     =     RCC_APB1LENR_UART7EN,
    RCC_APB1_GRP1_PERIPH_UART8     =     RCC_APB1LENR_UART8EN
};

/** @defgroup BUS_LL_EC_APB1_GRP2_PERIPH  APB1 GRP2 PERIPH
  * @{
  */
enum RCCAPB1GRP2PerClkType
{
    RCC_APB1_GRP2_PERIPH_CRS       =     RCC_APB1HENR_CRSEN,
    RCC_APB1_GRP2_PERIPH_SWPMI1    =     RCC_APB1HENR_SWPMIEN,
    RCC_APB1_GRP2_PERIPH_OPAMP     =     RCC_APB1HENR_OPAMPEN,
    RCC_APB1_GRP2_PERIPH_MDIOS     =     RCC_APB1HENR_MDIOSEN,
    RCC_APB1_GRP2_PERIPH_FDCAN     =     RCC_APB1HENR_FDCANEN,
    #if defined(TIM23)
    RCC_APB1_GRP2_PERIPH_TIM23     =     RCC_APB1HENR_TIM23EN,
    #endif /* TIM23 */
    #if defined(TIM24)
    RCC_APB1_GRP2_PERIPH_TIM24     =     RCC_APB1HENR_TIM24EN
    #endif /* TIM24 */
};

/** @defgroup BUS_LL_EC_APB2_GRP1_PERIPH  APB2 GRP1 PERIPH
  * @{
  */
enum RCCAPB2GRP1PerClkType
{
    RCC_APB2_GRP1_PERIPH_TIM1       =    RCC_APB2ENR_TIM1EN,
    RCC_APB2_GRP1_PERIPH_TIM8       =    RCC_APB2ENR_TIM8EN,
    RCC_APB2_GRP1_PERIPH_USART1     =    RCC_APB2ENR_USART1EN,
    RCC_APB2_GRP1_PERIPH_USART6     =    RCC_APB2ENR_USART6EN,
    #if defined(UART9)
    RCC_APB2_GRP1_PERIPH_UART9      =    RCC_APB2ENR_UART9EN,
    #endif /* UART9 */
    #if defined(USART10)
    RCC_APB2_GRP1_PERIPH_USART10    =    RCC_APB2ENR_USART10EN,
    #endif /* USART10 */
    RCC_APB2_GRP1_PERIPH_SPI1       =    RCC_APB2ENR_SPI1EN,
    RCC_APB2_GRP1_PERIPH_SPI4       =    RCC_APB2ENR_SPI4EN,
    RCC_APB2_GRP1_PERIPH_TIM15      =    RCC_APB2ENR_TIM15EN,
    RCC_APB2_GRP1_PERIPH_TIM16      =    RCC_APB2ENR_TIM16EN,
    RCC_APB2_GRP1_PERIPH_TIM17      =    RCC_APB2ENR_TIM17EN,
    RCC_APB2_GRP1_PERIPH_SPI5       =    RCC_APB2ENR_SPI5EN,
    RCC_APB2_GRP1_PERIPH_SAI1       =    RCC_APB2ENR_SAI1EN,
    #if defined(SAI2)
    RCC_APB2_GRP1_PERIPH_SAI2       =    RCC_APB2ENR_SAI2EN,
    #endif /* SAI2 */
    #if defined(SAI3)
    RCC_APB2_GRP1_PERIPH_SAI3       =    RCC_APB2ENR_SAI3EN,
    #endif /* SAI3 */
    RCC_APB2_GRP1_PERIPH_DFSDM1     =    RCC_APB2ENR_DFSDM1EN,
    #if defined(HRTIM1)
    RCC_APB2_GRP1_PERIPH_HRTIM      =    RCC_APB2ENR_HRTIMEN
    #endif /* HRTIM1 */
};

/** @defgroup BUS_LL_EC_APB4_GRP1_PERIPH  APB4 GRP1 PERIPH
  * @{
  */
enum RCCAPB4GRP1PerClkType
{
    RCC_APB4_GRP1_PERIPH_SYSCFG     =    RCC_APB4ENR_SYSCFGEN,
    RCC_APB4_GRP1_PERIPH_LPUART1    =    RCC_APB4ENR_LPUART1EN,
    RCC_APB4_GRP1_PERIPH_SPI6       =    RCC_APB4ENR_SPI6EN,
    RCC_APB4_GRP1_PERIPH_I2C4       =    RCC_APB4ENR_I2C4EN,
    RCC_APB4_GRP1_PERIPH_LPTIM2     =    RCC_APB4ENR_LPTIM2EN,
    RCC_APB4_GRP1_PERIPH_LPTIM3     =    RCC_APB4ENR_LPTIM3EN,
    #if defined(LPTIM4)
    RCC_APB4_GRP1_PERIPH_LPTIM4     =    RCC_APB4ENR_LPTIM4EN,
    #endif /* LPTIM4 */
    #if defined(LPTIM5)
    RCC_APB4_GRP1_PERIPH_LPTIM5     =    RCC_APB4ENR_LPTIM5EN,
    #endif /* LPTIM5 */
    #if defined(DAC2)
    RCC_APB4_GRP1_PERIPH_DAC2       =    RCC_APB4ENR_DAC2EN,
    #endif /* DAC2 */
    RCC_APB4_GRP1_PERIPH_COMP12     =    RCC_APB4ENR_COMP12EN,
    RCC_APB4_GRP1_PERIPH_VREF       =    RCC_APB4ENR_VREFEN,
    RCC_APB4_GRP1_PERIPH_RTCAPB     =    RCC_APB4ENR_RTCAPBEN,
    #if defined(SAI4)
    RCC_APB4_GRP1_PERIPH_SAI4       =    RCC_APB4ENR_SAI4EN,
    #endif /* SAI4 */
    #if defined(DTS)
    RCC_APB4_GRP1_PERIPH_DTS        =    RCC_APB4ENR_DTSEN,
    #endif /*DTS*/
    #if defined(DFSDM2_BASE)
    RCC_APB4_GRP1_PERIPH_DFSDM2     =    RCC_APB4ENR_DFSDM2EN
    #endif /* DFSDM2_BASE */
};
/** @defgroup BUS_LL_EC_CLKAM_PERIPH  CLKAM PERIPH
  * @{
  */
enum RCCAMPerClkType
{
    #if defined(RCC_D3AMR_BDMAAMEN)
    RCC_CLKAM_PERIPH_BDMA     =     RCC_D3AMR_BDMAAMEN,
    #else
    RCC_CLKAM_PERIPH_BDMA2    =     RCC_SRDAMR_BDMA2AMEN,
    RCC_CLKAM_PERIPH_BDMA     =     RCC_CLKAM_PERIPH_BDMA2, /* for backward compatibility*/
    #endif /* RCC_D3AMR_BDMAAMEN */
    #if defined(RCC_SRDAMR_GPIOAMEN)
    RCC_CLKAM_PERIPH_GPIO     =     RCC_SRDAMR_GPIOAMEN,
    #endif /* RCC_SRDAMR_GPIOAMEN */
    #if defined(RCC_D3AMR_LPUART1AMEN)
    RCC_CLKAM_PERIPH_LPUART1  =     RCC_D3AMR_LPUART1AMEN,
    #else
    RCC_CLKAM_PERIPH_LPUART1  =     RCC_SRDAMR_LPUART1AMEN,
    #endif /* RCC_D3AMR_LPUART1AMEN */
    #if defined(RCC_D3AMR_SPI6AMEN)
    RCC_CLKAM_PERIPH_SPI6     =     RCC_D3AMR_SPI6AMEN,
    #else
    RCC_CLKAM_PERIPH_SPI6     =     RCC_SRDAMR_SPI6AMEN,
    #endif /* RCC_D3AMR_SPI6AMEN */
    #if defined(RCC_D3AMR_I2C4AMEN)
    RCC_CLKAM_PERIPH_I2C4     =     RCC_D3AMR_I2C4AMEN,
    #else
    RCC_CLKAM_PERIPH_I2C4     =     RCC_SRDAMR_I2C4AMEN,
    #endif /* RCC_D3AMR_I2C4AMEN */
    #if defined(RCC_D3AMR_LPTIM2AMEN)
    RCC_CLKAM_PERIPH_LPTIM2   =     RCC_D3AMR_LPTIM2AMEN,
    #else
    RCC_CLKAM_PERIPH_LPTIM2   =     RCC_SRDAMR_LPTIM2AMEN,
    #endif /* RCC_D3AMR_LPTIM2AMEN */
    #if defined(RCC_D3AMR_LPTIM3AMEN)
    RCC_CLKAM_PERIPH_LPTIM3   =     RCC_D3AMR_LPTIM3AMEN,
    #else
    RCC_CLKAM_PERIPH_LPTIM3   =     RCC_SRDAMR_LPTIM3AMEN,
    #endif /* RCC_D3AMR_LPTIM3AMEN */
    #if defined(RCC_D3AMR_LPTIM4AMEN)
    RCC_CLKAM_PERIPH_LPTIM4   =     RCC_D3AMR_LPTIM4AMEN,
    #endif /* RCC_D3AMR_LPTIM4AMEN */
    #if defined(RCC_D3AMR_LPTIM5AMEN)
    RCC_CLKAM_PERIPH_LPTIM5   =     RCC_D3AMR_LPTIM5AMEN,
    #endif /* RCC_D3AMR_LPTIM5AMEN */
    #if defined(DAC2)
    RCC_CLKAM_PERIPH_DAC2     =     RCC_SRDAMR_DAC2AMEN,
    #endif /* DAC2 */
    #if defined(RCC_D3AMR_COMP12AMEN)
    RCC_CLKAM_PERIPH_COMP12   =     RCC_D3AMR_COMP12AMEN,
    #else
    RCC_CLKAM_PERIPH_COMP12   =     RCC_SRDAMR_COMP12AMEN,
    #endif /* RCC_D3AMR_COMP12AMEN */
    #if defined(RCC_D3AMR_VREFAMEN)
    RCC_CLKAM_PERIPH_VREF     =     RCC_D3AMR_VREFAMEN,
    #else
    RCC_CLKAM_PERIPH_VREF     =     RCC_SRDAMR_VREFAMEN,
    #endif /* RCC_D3AMR_VREFAMEN */
    #if defined(RCC_D3AMR_RTCAMEN)
    RCC_CLKAM_PERIPH_RTC      =     RCC_D3AMR_RTCAMEN,
    #else
    RCC_CLKAM_PERIPH_RTC      =     RCC_SRDAMR_RTCAMEN,
    #endif /* RCC_D3AMR_RTCAMEN */
    #if defined(RCC_D3AMR_CRCAMEN)
    RCC_CLKAM_PERIPH_CRC      =     RCC_D3AMR_CRCAMEN,
    #endif /* RCC_D3AMR_CRCAMEN */
    #if defined(SAI4)
    RCC_CLKAM_PERIPH_SAI4     =      RCC_D3AMR_SAI4AMEN,
    #endif /* SAI4 */
    #if defined(ADC3)
    RCC_CLKAM_PERIPH_ADC3     =     RCC_D3AMR_ADC3AMEN,
    #endif /* ADC3 */
    #if defined(RCC_SRDAMR_DTSAMEN)
    RCC_CLKAM_PERIPH_DTS      =     RCC_SRDAMR_DTSAMEN,
    #endif /* RCC_SRDAMR_DTSAMEN */
    #if defined(RCC_D3AMR_DTSAMEN)
    RCC_CLKAM_PERIPH_DTS      =     RCC_D3AMR_DTSAMEN,
    #endif /* RCC_D3AMR_DTSAMEN */
    #if defined(DFSDM2_BASE)
    RCC_CLKAM_PERIPH_DFSDM2   =     RCC_SRDAMR_DFSDM2AMEN,
    #endif /* DFSDM2_BASE */
    #if defined(RCC_D3AMR_BKPRAMAMEN)
    RCC_CLKAM_PERIPH_BKPRAM   =     RCC_D3AMR_BKPRAMAMEN,
    #else
    RCC_CLKAM_PERIPH_BKPRAM   =     RCC_SRDAMR_BKPRAMAMEN,
    #endif /* RCC_D3AMR_BKPRAMAMEN */
    #if defined(RCC_D3AMR_SRAM4AMEN)
    RCC_CLKAM_PERIPH_SRAM4    =     RCC_D3AMR_SRAM4AMEN,
    #else
    RCC_CLKAM_PERIPH_SRDSRAM  =     RCC_SRDAMR_SRDSRAMAMEN,
    RCC_CLKAM_PERIPH_SRAM4    =     RCC_CLKAM_PERIPH_SRDSRAM
    #endif /* RCC_D3AMR_SRAM4AMEN */
};

/** @defgroup EC_CKGA_PERIPH  CKGA (AXI Clocks Gating) PERIPH
  * @{
  */
enum RCCCKGAPerType
{
    #if defined(RCC_CKGAENR_AXICKG)
    RCC_CKGA_PERIPH_AXI        =    RCC_CKGAENR_AXICKG,
    RCC_CKGA_PERIPH_AHB        =    RCC_CKGAENR_AHBCKG,
    RCC_CKGA_PERIPH_CPU        =    RCC_CKGAENR_CPUCKG,
    RCC_CKGA_PERIPH_SDMMC      =    RCC_CKGAENR_SDMMCCKG,
    RCC_CKGA_PERIPH_MDMA       =    RCC_CKGAENR_MDMACKG,
    RCC_CKGA_PERIPH_DMA2D      =    RCC_CKGAENR_DMA2DCKG,
    RCC_CKGA_PERIPH_LTDC       =    RCC_CKGAENR_LTDCCKG,
    RCC_CKGA_PERIPH_GFXMMUM    =    RCC_CKGAENR_GFXMMUMCKG,
    RCC_CKGA_PERIPH_AHB12      =    RCC_CKGAENR_AHB12CKG,
    RCC_CKGA_PERIPH_AHB34      =    RCC_CKGAENR_AHB34CKG,
    RCC_CKGA_PERIPH_FLIFT      =    RCC_CKGAENR_FLIFTCKG,
    RCC_CKGA_PERIPH_OCTOSPI2   =    RCC_CKGAENR_OCTOSPI2CKG,
    RCC_CKGA_PERIPH_FMC        =    RCC_CKGAENR_FMCCKG,
    RCC_CKGA_PERIPH_OCTOSPI1   =    RCC_CKGAENR_OCTOSPI1CKG,
    RCC_CKGA_PERIPH_AXIRAM1    =    RCC_CKGAENR_AXIRAM1CKG,
    RCC_CKGA_PERIPH_AXIRAM2    =    RCC_CKGAENR_AXIRAM2CKG,
    RCC_CKGA_PERIPH_AXIRAM3    =    RCC_CKGAENR_AXIRAM3CKG,
    RCC_CKGA_PERIPH_GFXMMUS    =    RCC_CKGAENR_GFXMMUSCKG,
    RCC_CKGA_PERIPH_ECCRAM     =    RCC_CKGAENR_ECCRAMCKG,
    RCC_CKGA_PERIPH_EXTI       =    RCC_CKGAENR_EXTICKG,
    RCC_CKGA_PERIPH_JTAG       =    RCC_CKGAENR_JTAGCKG
    #endif
};

class RCCControl
{
public:
    static RCCControl* getInstance()
    {
        static RCCControl rcc_;
        return &rcc_;
    }
    void HSEEnableCSS(void)
    {
        SET_BIT(RCC->CR, RCC_CR_CSSHSEON);
    }

    /**
      * @brief  Enable HSE external oscillator (HSE Bypass)
      * @rmtoll CR           HSEBYP        HSEEnableBypass
      * @retval None
      */
    void HSEEnableBypass(void)
    {
        SET_BIT(RCC->CR, RCC_CR_HSEBYP);
    }

    /**
      * @brief  Disable HSE external oscillator (HSE Bypass)
      * @rmtoll CR           HSEBYP        HSEDisableBypass
      * @retval None
      */
    void HSEDisableBypass(void)
    {
        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
    }

    #if defined(RCC_CR_HSEEXT)
    /**
      * @brief  Select the Analog HSE external clock type in Bypass mode
      * @rmtoll CR           HSEEXT        HSESelectAnalogClock
      * @retval None
      */
    void HSESelectAnalogClock(void)
    {
        CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);
    }

    /**
      * @brief  Select the Digital HSE external clock type in Bypass mode
      * @rmtoll CR           HSEEXT        HSESelectDigitalClock
      * @retval None
      */
    void HSESelectDigitalClock(void)
    {
        SET_BIT(RCC->CR, RCC_CR_HSEEXT);
    }
    #endif /* RCC_CR_HSEEXT */

    /**
      * @brief  Enable HSE crystal oscillator (HSE ON)
      * @rmtoll CR           HSEON         HSEEnable
      * @retval None
      */
    void HSEEnable(void)
    {
        SET_BIT(RCC->CR, RCC_CR_HSEON);
    }

    /**
      * @brief  Disable HSE crystal oscillator (HSE ON)
      * @rmtoll CR           HSEON         HSEDisable
      * @retval None
      */
    void HSEDisable(void)
    {
        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
    }

    /**
      * @brief  Check if HSE oscillator Ready
      * @rmtoll CR           HSERDY        HSEIsReady
      * @retval State of bit (1 or 0).
      */
    bool HSEIsReady(void)
    {
        return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? true : false);
    }

    /** @defgroup RCC_EF_HSI HSI
      * @{
      */

    /**
      * @brief  Enable HSI oscillator
      * @rmtoll CR           HSION         HSIEnable
      * @retval None
      */
    void HSIEnable(void)
    {
        SET_BIT(RCC->CR, RCC_CR_HSION);
    }

    /**
      * @brief  Disable HSI oscillator
      * @rmtoll CR           HSION         HSIDisable
      * @retval None
      */
    void HSIDisable(void)
    {
        CLEAR_BIT(RCC->CR, RCC_CR_HSION);
    }

    /**
      * @brief  Check if HSI clock is ready
      * @rmtoll CR           HSIRDY        HSIIsReady
      * @retval State of bit (1 or 0).
      */
    bool HSIIsReady(void)
    {
        return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? true : false);
    }

    /**
      * @brief  Check if HSI new divider applied and ready
      * @rmtoll CR           HSIDIVF        HSIIsDividerReady
      * @retval State of bit (1 or 0).
      */
    bool HSIIsDividerReady(void)
    {
        return ((READ_BIT(RCC->CR, RCC_CR_HSIDIVF) == (RCC_CR_HSIDIVF)) ? true : false);
    }

    /**
      * @brief  Set HSI divider
      * @rmtoll CR           HSIDIV        HSISetDivider
      * @param  Divider This parameter can be one of the following values:
      *         @arg @ref HSI_DIV1
      *         @arg @ref HSI_DIV2
      *         @arg @ref HSI_DIV4
      *         @arg @ref HSI_DIV8
      * @retval None.
      */
    void HSISetDivider(RCCHSIOscillatorDivider Divider)
    {
        MODIFY_REG(RCC->CR, RCC_CR_HSIDIV, Divider);
    }

    /**
      * @brief  Get HSI divider
      * @rmtoll CR           HSIDIV        HSIGetDivider
      * @retval can be one of the following values:
      *         @arg @ref HSI_DIV1
      *         @arg @ref HSI_DIV2
      *         @arg @ref HSI_DIV4
      *         @arg @ref HSI_DIV8
      */
    RCCHSIOscillatorDivider HSIGetDivider(void)
    {
        return (RCCHSIOscillatorDivider)(READ_BIT(RCC->CR, RCC_CR_HSIDIV));
    }

    /**
      * @brief  Enable HSI oscillator in Stop mode
      * @rmtoll CR           HSIKERON         HSIEnableStopMode
      * @retval None
      */
    void HSIEnableStopMode(void)
    {
        SET_BIT(RCC->CR, RCC_CR_HSIKERON);
    }

    /**
      * @brief  Disable HSI oscillator in Stop mode
      * @rmtoll CR           HSION         HSIDisableStopMode
      * @retval None
      */
    void HSIDisableStopMode(void)
    {
        CLEAR_BIT(RCC->CR, RCC_CR_HSIKERON);
    }

    /**
      * @brief  Get HSI Calibration value
      * @note When HSITRIM is written, HSICAL is updated with the sum of
      *       HSITRIM and the factory trim value
      * @rmtoll HSICFGR        HSICAL        HSIGetCalibration
      * @retval A value between 0 and 4095 (0xFFF)
      */
    uint32_t HSIGetCalibration(void)
    {
        return (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSICAL) >> RCC_HSICFGR_HSICAL_Pos);
    }

    /**
      * @brief  Set HSI Calibration trimming
      * @note user-programmable trimming value that is added to the HSICAL
      * @note Default value is 64 (32 for Cut1.x), which, when added to the HSICAL value,
      *       should trim the HSI to 64 MHz +/- 1 %
      * @rmtoll HSICFGR        HSITRIM       HSISetCalibTrimming
      * @param  Value can be a value between 0 and 127 (63 for Cut1.x)
      * @retval None
      */
    void HSISetCalibTrimming(uint32_t Value)
    {
    #if defined(RCC_VER_X)
        if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
        {
            /* STM32H7 Rev.Y */
            MODIFY_REG(RCC->HSICFGR, 0x3F000U, Value << 12U);
        }
        else
        {
            /* STM32H7 Rev.V */
            MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
        }
    #else
          MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
    #endif /* RCC_VER_X */
    }

    /**
      * @brief  Get HSI Calibration trimming
      * @rmtoll HSICFGR        HSITRIM       HSIGetCalibTrimming
      * @retval A value between 0 and 127 (63 for Cut1.x)
      */
    uint32_t HSIGetCalibTrimming(void)
    {
    #if defined(RCC_VER_X)
        if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
        {
            /* STM32H7 Rev.Y */
            return (uint32_t)(READ_BIT(RCC->HSICFGR, 0x3F000U) >> 12U);
        }
        else
        {
            /* STM32H7 Rev.V */
            return (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
        }
    #else
        return (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
    #endif /* RCC_VER_X */
    }

    /** @defgroup RCC_EF_CSI CSI
      * @{
      */

    /**
      * @brief  Enable CSI oscillator
      * @rmtoll CR           CSION         CSIEnable
      * @retval None
      */
    void CSIEnable(void)
    {
        SET_BIT(RCC->CR, RCC_CR_CSION);
    }

    /**
      * @brief  Disable CSI oscillator
      * @rmtoll CR           CSION         CSIDisable
      * @retval None
      */
    void CSIDisable(void)
    {
        CLEAR_BIT(RCC->CR, RCC_CR_CSION);
    }

    /**
      * @brief  Check if CSI clock is ready
      * @rmtoll CR           CSIRDY        CSIIsReady
      * @retval State of bit (1 or 0).
      */
    bool CSIIsReady(void)
    {
        return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? true : false);
    }

    /**
      * @brief  Enable CSI oscillator in Stop mode
      * @rmtoll CR           CSIKERON         CSIEnableStopMode
      * @retval None
      */
    void CSIEnableStopMode(void)
    {
        SET_BIT(RCC->CR, RCC_CR_CSIKERON);
    }

    /**
      * @brief  Disable CSI oscillator in Stop mode
      * @rmtoll CR           CSIKERON         CSIDisableStopMode
      * @retval None
      */
    void CSIDisableStopMode(void)
    {
      CLEAR_BIT(RCC->CR, RCC_CR_CSIKERON);
    }

    /**
      * @brief  Get CSI Calibration value
      * @note When CSITRIM is written, CSICAL is updated with the sum of
      *       CSITRIM and the factory trim value
      * @rmtoll CSICFGR        CSICAL        CSIGetCalibration
      * @retval A value between 0 and 255 (0xFF)
      */
    uint32_t CSIGetCalibration(void)
    {
    #if defined(RCC_VER_X)
      if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
      {
        /* STM32H7 Rev.Y */
        return (uint32_t)(READ_BIT(RCC->HSICFGR, 0x3FC0000U) >> 18U);
      }
      else
      {
        /* STM32H7 Rev.V */
        return (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSICAL) >> RCC_CSICFGR_CSICAL_Pos);
      }
    #else
      return (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSICAL) >> RCC_CSICFGR_CSICAL_Pos);
    #endif /* RCC_VER_X */
    }

    /**
      * @brief  Set CSI Calibration trimming
      * @note user-programmable trimming value that is added to the CSICAL
      * @note Default value is 16, which, when added to the CSICAL value,
      *       should trim the CSI to 4 MHz +/- 1 %
      * @rmtoll CSICFGR        CSITRIM       CSISetCalibTrimming
      * @param  Value can be a value between 0 and 31
      * @retval None
      */
    void CSISetCalibTrimming(uint32_t Value)
    {
    #if defined(RCC_VER_X)
      if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
      {
        /* STM32H7 Rev.Y */
        MODIFY_REG(RCC->HSICFGR, 0x7C000000U, Value << 26U);
      }
      else
      {
        /* STM32H7 Rev.V */
        MODIFY_REG(RCC->CSICFGR, RCC_CSICFGR_CSITRIM, Value << RCC_CSICFGR_CSITRIM_Pos);
      }
    #else
      MODIFY_REG(RCC->CSICFGR, RCC_CSICFGR_CSITRIM, Value << RCC_CSICFGR_CSITRIM_Pos);
    #endif /* RCC_VER_X */
    }

    /**
      * @brief  Get CSI Calibration trimming
      * @rmtoll CSICFGR        CSITRIM       CSIGetCalibTrimming
      * @retval A value between 0 and 31
      */
    uint32_t CSIGetCalibTrimming(void)
    {
    #if defined(RCC_VER_X)
      if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
      {
        /* STM32H7 Rev.Y */
        return (uint32_t)(READ_BIT(RCC->HSICFGR, 0x7C000000U) >> 26U);
      }
      else
      {
        /* STM32H7 Rev.V */
        return (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
      }
    #else
      return (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
    #endif /* RCC_VER_X */
    }

    /** @defgroup RCC_EF_HSI48 HSI48
      * @{
      */

    /**
      * @brief  Enable HSI48 oscillator
      * @rmtoll CR           HSI48ON         HSI48Enable
      * @retval None
      */
    void HSI48Enable(void)
    {
      SET_BIT(RCC->CR, RCC_CR_HSI48ON);
    }

    /**
      * @brief  Disable HSI48 oscillator
      * @rmtoll CR           HSI48ON         HSI48Disable
      * @retval None
      */
    void HSI48Disable(void)
    {
      CLEAR_BIT(RCC->CR, RCC_CR_HSI48ON);
    }

    /**
      * @brief  Check if HSI48 clock is ready
      * @rmtoll CR           HSI48RDY        HSI48IsReady
      * @retval State of bit (1 or 0).
      */
    bool HSI48IsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == (RCC_CR_HSI48RDY)) ? true : false);
    }

    /**
      * @brief  Get HSI48 Calibration value
      * @note When HSI48TRIM is written, HSI48CAL is updated with the sum of
      *       HSI48TRIM and the factory trim value
      * @rmtoll CRRCR        HSI48CAL        HSI48GetCalibration
      * @retval A value between 0 and 1023 (0x3FF)
      */
    uint32_t HSI48GetCalibration(void)
    {
      return (uint32_t)(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48CAL) >> RCC_CRRCR_HSI48CAL_Pos);
    }
    /**
      * @}
      */

    #if defined(RCC_CR_D1CKRDY)

    /** @defgroup RCC_LL_EF_D1CLK D1CKREADY
      * @{
      */

    /**
      * @brief  Check if D1 clock is ready
      * @rmtoll CR           D1CKRDY        D1CKIsReady
      * @retval State of bit (1 or 0).
      */
    bool D1CKIsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_D1CKRDY) == (RCC_CR_D1CKRDY)) ? true : false);
    }

    /**
      * @}
      */
    #else

    /** @defgroup RCC_LL_EF_CPUCLK CPUCKREADY
      * @{
      */

    /**
      * @brief  Check if CPU clock is ready
      * @rmtoll CR           CPUCKRDY        CPUCKIsReady
      * @retval State of bit (1 or 0).
      */
    bool CPUCKIsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_CPUCKRDY) == (RCC_CR_CPUCKRDY)) ? true : false);
    }
    /* alias */
    #define D1CKIsReady  CPUCKIsReady
    /**
      * @}
      */
    #endif /* RCC_CR_D1CKRDY */

    #if defined(RCC_CR_D2CKRDY)

    /** @defgroup RCC_LL_EF_D2CLK D2CKREADY
      * @{
      */

    /**
      * @brief  Check if D2 clock is ready
      * @rmtoll CR           D2CKRDY        D2CKIsReady
      * @retval State of bit (1 or 0).
      */
    bool D2CKIsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_D2CKRDY) == (RCC_CR_D2CKRDY)) ? true : false);
    }
    /**
      * @}
      */
    #else

    /** @defgroup RCC_LL_EF_CDCLK CDCKREADY
      * @{
      */

    /**
      * @brief  Check if CD clock is ready
      * @rmtoll CR           CDCKRDY        CDCKIsReady
      * @retval State of bit (1 or 0).
      */
    bool CDCKIsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_CDCKRDY) == (RCC_CR_CDCKRDY)) ? true : false);
    }
    #define D2CKIsReady CDCKIsReady
    /**
      * @}
      */
    #endif /* RCC_CR_D2CKRDY */

    /** @defgroup RCC_EF_SYSTEM_WIDE_RESET RESET
      * @{
      */
    #if defined(RCC_GCR_WW1RSC)

    /**
      * @brief  Enable system wide reset for Window Watch Dog 1
      * @rmtoll GCR          WW1RSC        WWDG1EnableSystemReset
      * @retval None.
      */
    void WWDG1EnableSystemReset(void)
    {
      SET_BIT(RCC->GCR, RCC_GCR_WW1RSC);
    }

    /**
      * @brief  Check if Window Watch Dog 1 reset is system wide
      * @rmtoll GCR          WW1RSC        WWDG1IsSystemReset
      * @retval State of bit (1 or 0).
      */
    bool WWDG1IsSystemReset(void)
    {
      return ((READ_BIT(RCC->GCR, RCC_GCR_WW1RSC) == RCC_GCR_WW1RSC) ? true : false);
    }
    #endif  /* RCC_GCR_WW1RSC */

    #if defined(DUAL_CORE)
    /**
      * @brief  Enable system wide reset for Window Watch Dog 2
      * @rmtoll GCR          WW1RSC        WWDG2EnableSystemReset
      * @retval None.
      */
    void WWDG2EnableSystemReset(void)
    {
      SET_BIT(RCC->GCR, RCC_GCR_WW2RSC);
    }

    /**
      * @brief  Check if Window Watch Dog 2 reset is system wide
      * @rmtoll GCR          WW2RSC        WWDG2IsSystemReset
      * @retval State of bit (1 or 0).
      */
    bool WWDG2IsSystemReset(void)
    {
      return ((READ_BIT(RCC->GCR, RCC_GCR_WW2RSC) == RCC_GCR_WW2RSC) ? true : false);
    }
    #endif  /*DUAL_CORE*/
    /**
      * @}
      */

    #if defined(DUAL_CORE)
    /** @defgroup RCC_LL_EF_BOOT_CPU CPU
      * @{
      */

    /**
      * @brief  Force CM4 boot (if hold by option byte BCM4 = 0)
      * @rmtoll GCR          BOOT_C2        ForceCM4Boot
      * @retval None.
      */
    void ForceCM4Boot(void)
    {
      SET_BIT(RCC->GCR, RCC_GCR_BOOT_C2);
    }

    /**
      * @brief  Check if CM4 boot is forced
      * @rmtoll GCR          BOOT_C2        IsCM4BootForced
      * @retval State of bit (1 or 0).
      */
    bool IsCM4BootForced(void)
    {
      return ((READ_BIT(RCC->GCR, RCC_GCR_BOOT_C2) == RCC_GCR_BOOT_C2) ? true : false);
    }

    /**
      * @brief  Force CM7 boot (if hold by option byte BCM7 = 0)
      * @rmtoll GCR          BOOT_C1        ForceCM7Boot
      * @retval None.
      */
    void ForceCM7Boot(void)
    {
      SET_BIT(RCC->GCR, RCC_GCR_BOOT_C1);
    }

    /**
      * @brief  Check if CM7 boot is forced
      * @rmtoll GCR          BOOT_C1        IsCM7BootForced
      * @retval State of bit (1 or 0).
      */
    bool IsCM7BootForced(void)
    {
      return ((READ_BIT(RCC->GCR, RCC_GCR_BOOT_C1) == RCC_GCR_BOOT_C1) ? true : false);
    }

    /**
      * @}
      */
    #endif  /*DUAL_CORE*/

    /** @defgroup RCC_EF_LSE LSE
      * @{
      */

    /**
      * @brief  Enable the Clock Security System on LSE.
      * @note Once LSE Clock Security System is enabled it cannot be changed anymore unless
      *       a clock failure is detected.
      * @rmtoll BDCR          LSECSSON         LSEEnableCSS
      * @retval None
      */
    void LSEEnableCSS(void)
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
    }

    /**
      * @brief  Check if LSE failure is detected by Clock Security System
      * @rmtoll BDCR         LSECSSD       LSEIsFailureDetected
      * @retval State of bit (1 or 0).
      */
    bool LSEIsFailureDetected(void)
    {
      return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSECSSD) == (RCC_BDCR_LSECSSD)) ? true : false);
    }

    /**
      * @brief  Enable  Low Speed External (LSE) crystal.
      * @rmtoll BDCR         LSEON         LSEEnable
      * @retval None
      */
    void LSEEnable(void)
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
    }

    /**
      * @brief  Disable  Low Speed External (LSE) crystal.
      * @rmtoll BDCR         LSEON         LSEDisable
      * @retval None
      */
    void LSEDisable(void)
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
    }

    /**
      * @brief  Enable external clock source (LSE bypass).
      * @rmtoll BDCR         LSEBYP        LSEEnableBypass
      * @retval None
      */
    void LSEEnableBypass(void)
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }

    /**
      * @brief  Disable external clock source (LSE bypass).
      * @rmtoll BDCR         LSEBYP        LSEDisableBypass
      * @retval None
      */
    void LSEDisableBypass(void)
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }

    #if defined(RCC_BDCR_LSEEXT)
    /**
      * @brief  Enable Low-speed external DIGITAL clock type in Bypass mode (not to be used if RTC is active).
      * @note   The external clock must be enabled with the LSEON bit, to be used by the device.
      *         The LSEEXT bit can be written only if the LSE oscillator is disabled.
      * @rmtoll BDCR         LSEEXT        LSESelectDigitalClock
      * @retval None
      */
    void LSESelectDigitalClock(void)
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEEXT);
    }

    /**
      * @brief  Enable Low-speed external ANALOG clock type in Bypass mode (default after Backup domain reset).
      * @note   The external clock must be enabled with the LSEON bit, to be used by the device.
      *         The LSEEXT bit can be written only if the LSE oscillator is disabled.
      * @rmtoll BDCR         LSEEXT        LSESelectAnalogClock
      * @retval None
      */
    void LSESelectAnalogClock(void)
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEEXT);
    }
    #endif /* RCC_BDCR_LSEEXT */

    /**
      * @brief  Set LSE oscillator drive capability
      * @note The oscillator is in Xtal mode when it is not in bypass mode.
      * @rmtoll BDCR         LSEDRV        LSESetDriveCapability
      * @param  LSEDrive This parameter can be one of the following values:
      *         @arg @ref LSEDRIVE_LOW
      *         @arg @ref LSEDRIVE_MEDIUMLOW
      *         @arg @ref LSEDRIVE_MEDIUMHIGH
      *         @arg @ref LSEDRIVE_HIGH
      * @retval None
      */
    void LSESetDriveCapability(RCCLSEOscillatorDriveCapability LSEDrive)
    {
      MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
    }

    /**
      * @brief  Get LSE oscillator drive capability
      * @rmtoll BDCR         LSEDRV        LSE_GetDriveCapability
      * @retval Returned value can be one of the following values:
      *         @arg @ref LSEDRIVE_LOW
      *         @arg @ref LSEDRIVE_MEDIUMLOW
      *         @arg @ref LSEDRIVE_MEDIUMHIGH
      *         @arg @ref LSEDRIVE_HIGH
      */
    RCCLSEOscillatorDriveCapability LSE_GetDriveCapability(void)
    {
      return (RCCLSEOscillatorDriveCapability)(READ_BIT(RCC->BDCR, RCC_BDCR_LSEDRV));
    }

    /**
      * @brief  Check if LSE oscillator Ready
      * @rmtoll BDCR         LSERDY        LSEIsReady
      * @retval State of bit (1 or 0).
      */
    bool LSEIsReady(void)
    {
      return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? true : false);
    }

    /** @defgroup RCC_EF_LSI LSI
      * @{
      */

    /**
      * @brief  Enable LSI Oscillator
      * @rmtoll CSR          LSION         LSIEnable
      * @retval None
      */
    void LSIEnable(void)
    {
      SET_BIT(RCC->CSR, RCC_CSR_LSION);
    }

    /**
      * @brief  Disable LSI Oscillator
      * @rmtoll CSR          LSION         LSIDisable
      * @retval None
      */
    void LSIDisable(void)
    {
      CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
    }

    /**
      * @brief  Check if LSI is Ready
      * @rmtoll CSR          LSIRDY        LSIIsReady
      * @retval State of bit (1 or 0).
      */
    bool LSIIsReady(void)
    {
      return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? true : false);
    }

    /** @defgroup RCC_LL_EF_System System
      * @{
      */

    /**
      * @brief  Configure the system clock source
      * @rmtoll CFGR         SW            SetSysClkSource
      * @param  Source This parameter can be one of the following values:
      *         @arg @ref SYS_CLKSOURCE_HSI
      *         @arg @ref SYS_CLKSOURCE_CSI
      *         @arg @ref SYS_CLKSOURCE_HSE
      *         @arg @ref SYS_CLKSOURCE_PLL1
      * @retval None
      */
    void SetSysClkSource(RCCSYSClkSource Source)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
    }

    /**
      * @brief  Get the system clock source
      * @rmtoll CFGR         SWS           GetSysClkSource
      * @retval Returned value can be one of the following values:
      *         @arg @ref SYS_CLKSOURCE_STATUS_HSI
      *         @arg @ref SYS_CLKSOURCE_STATUS_CSI
      *         @arg @ref SYS_CLKSOURCE_STATUS_HSE
      *         @arg @ref SYS_CLKSOURCE_STATUS_PLL1
      */
    RCCSYSClkSourceStatus GetSysClkSource(void)
    {
      return (RCCSYSClkSourceStatus)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
    }

    /**
      * @brief  Configure the system wakeup clock source
      * @rmtoll CFGR         STOPWUCK       SetSysWakeUpClkSource
      * @param  Source This parameter can be one of the following values:
      *         @arg @ref SYSWAKEUP_CLKSOURCE_HSI
      *         @arg @ref SYSWAKEUP_CLKSOURCE_CSI
      * @retval None
      */
    void SetSysWakeUpClkSource(RCCSYSWakeupClkSource Source)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Source);
    }

    /**
      * @brief  Get the system wakeup clock source
      * @rmtoll CFGR         STOPWUCK           GetSysWakeUpClkSource
      * @retval Returned value can be one of the following values:
      *         @arg @ref SYSWAKEUP_CLKSOURCE_HSI
      *         @arg @ref SYSWAKEUP_CLKSOURCE_CSI
      */
    RCCSYSWakeupClkSource GetSysWakeUpClkSource(void)
    {
      return (RCCSYSWakeupClkSource)(READ_BIT(RCC->CFGR, RCC_CFGR_STOPWUCK));
    }

    /**
      * @brief  Configure the kernel wakeup clock source
      * @rmtoll CFGR         STOPKERWUCK       SetKerWakeUpClkSource
      * @param  Source This parameter can be one of the following values:
      *         @arg @ref KERWAKEUP_CLKSOURCE_HSI
      *         @arg @ref KERWAKEUP_CLKSOURCE_CSI
      * @retval None
      */
    void SetKerWakeUpClkSource(RCCKERWakeupClkSource Source)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPKERWUCK, Source);
    }

    /**
      * @brief  Get the kernel wakeup clock source
      * @rmtoll CFGR         STOPKERWUCK           GetKerWakeUpClkSource
      * @retval Returned value can be one of the following values:
      *         @arg @ref KERWAKEUP_CLKSOURCE_HSI
      *         @arg @ref KERWAKEUP_CLKSOURCE_CSI
      */
    RCCKERWakeupClkSource GetKerWakeUpClkSource(void)
    {
      return (RCCKERWakeupClkSource)(READ_BIT(RCC->CFGR, RCC_CFGR_STOPKERWUCK));
    }

    /**
      * @brief  Set System prescaler
      * @rmtoll D1CFGR/CDCFGR1        D1CPRE/CDCPRE          SetSysPrescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref SYSCLK_DIV_1
      *         @arg @ref SYSCLK_DIV_2
      *         @arg @ref SYSCLK_DIV_4
      *         @arg @ref SYSCLK_DIV_8
      *         @arg @ref SYSCLK_DIV_16
      *         @arg @ref SYSCLK_DIV_64
      *         @arg @ref SYSCLK_DIV_128
      *         @arg @ref SYSCLK_DIV_256
      *         @arg @ref SYSCLK_DIV_512
      * @retval None
      */
    void SetSysPrescaler(RCCSysClkPrescaler Prescaler)
    {
    #if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, Prescaler);
    #else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, Prescaler);
    #endif /* RCC_D1CFGR_D1CPRE */
    }

    /**
      * @brief  Set AHB prescaler
      * @rmtoll D1CFGR/CDCFGR1        HPRE         SetAHBPrescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref AHB_DIV_1
      *         @arg @ref AHB_DIV_2
      *         @arg @ref AHB_DIV_4
      *         @arg @ref AHB_DIV_8
      *         @arg @ref AHB_DIV_16
      *         @arg @ref AHB_DIV_64
      *         @arg @ref AHB_DIV_128
      *         @arg @ref AHB_DIV_256
      *         @arg @ref AHB_DIV_512
      * @retval None
      */
    void SetAHBPrescaler(RCCAHBPrescaler Prescaler)
    {
    #if defined(RCC_D1CFGR_HPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, Prescaler);
    #else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, Prescaler);
    #endif /* RCC_D1CFGR_HPRE */
    }

    /**
      * @brief  Set APB1 prescaler
      * @rmtoll D2CFGR/CDCFGR2         D2PPRE1/CDPPRE1         SetAPB1Prescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref APB1_DIV_1
      *         @arg @ref APB1_DIV_2
      *         @arg @ref APB1_DIV_4
      *         @arg @ref APB1_DIV_8
      *         @arg @ref APB1_DIV_16
      * @retval None
      */
    void SetAPB1Prescaler(RCCAPB1Prescaler Prescaler)
    {
    #if defined(RCC_D2CFGR_D2PPRE1)
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, Prescaler);
    #else
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, Prescaler);
    #endif /* RCC_D2CFGR_D2PPRE1 */
    }

    /**
      * @brief  Set APB2 prescaler
      * @rmtoll D2CFGR/CDCFGR2         D2PPRE2/CDPPRE2         SetAPB2Prescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref APB2_DIV_1
      *         @arg @ref APB2_DIV_2
      *         @arg @ref APB2_DIV_4
      *         @arg @ref APB2_DIV_8
      *         @arg @ref APB2_DIV_16
      * @retval None
      */
    void SetAPB2Prescaler(RCCAPB2Prescaler Prescaler)
    {
    #if defined(RCC_D2CFGR_D2PPRE2)
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, Prescaler);
    #else
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, Prescaler);
    #endif /* RCC_D2CFGR_D2PPRE2 */
    }

    /**
      * @brief  Set APB3 prescaler
      * @rmtoll D1CFGR/CDCFGR1         D1PPRE/CDPPRE         SetAPB3Prescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref APB3_DIV_1
      *         @arg @ref APB3_DIV_2
      *         @arg @ref APB3_DIV_4
      *         @arg @ref APB3_DIV_8
      *         @arg @ref APB3_DIV_16
      * @retval None
      */
    void SetAPB3Prescaler(RCCAPB3Prescaler Prescaler)
    {
    #if defined(RCC_D1CFGR_D1PPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, Prescaler);
    #else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, Prescaler);
    #endif /* RCC_D1CFGR_D1PPRE */
    }

    /**
      * @brief  Set APB4 prescaler
      * @rmtoll D3CFGR/SRDCFGR         D3PPRE/SRDPPRE         SetAPB4Prescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref APB4_DIV_1
      *         @arg @ref APB4_DIV_2
      *         @arg @ref APB4_DIV_4
      *         @arg @ref APB4_DIV_8
      *         @arg @ref APB4_DIV_16
      * @retval None
      */
    void SetAPB4Prescaler(RCCAPB4Prescaler Prescaler)
    {
    #if defined(RCC_D3CFGR_D3PPRE)
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, Prescaler);
    #else
      MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, Prescaler);
    #endif /* RCC_D3CFGR_D3PPRE */
    }

    /**
      * @brief  Get System prescaler
      * @rmtoll D1CFGR/CDCFGR1        D1CPRE/CDCPRE          GetSysPrescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref SYSCLK_DIV_1
      *         @arg @ref SYSCLK_DIV_2
      *         @arg @ref SYSCLK_DIV_4
      *         @arg @ref SYSCLK_DIV_8
      *         @arg @ref SYSCLK_DIV_16
      *         @arg @ref SYSCLK_DIV_64
      *         @arg @ref SYSCLK_DIV_128
      *         @arg @ref SYSCLK_DIV_256
      *         @arg @ref SYSCLK_DIV_512
      */
    RCCSysClkPrescaler GetSysPrescaler(void)
    {
    #if defined(RCC_D1CFGR_D1CPRE)
      return (RCCSysClkPrescaler)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_D1CPRE));
    #else
      return (RCCSysClkPrescaler)(READ_BIT(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE));
    #endif /* RCC_D1CFGR_D1CPRE */
    }

    /**
      * @brief  Get AHB prescaler
      * @rmtoll D1CFGR/ CDCFGR1       HPRE         GetAHBPrescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref AHB_DIV_1
      *         @arg @ref AHB_DIV_2
      *         @arg @ref AHB_DIV_4
      *         @arg @ref AHB_DIV_8
      *         @arg @ref AHB_DIV_16
      *         @arg @ref AHB_DIV_64
      *         @arg @ref AHB_DIV_128
      *         @arg @ref AHB_DIV_256
      *         @arg @ref AHB_DIV_512
      */
    RCCAHBPrescaler GetAHBPrescaler(void)
    {
    #if defined(RCC_D1CFGR_HPRE)
      return (RCCAHBPrescaler)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_HPRE));
    #else
      return (RCCAHBPrescaler)(READ_BIT(RCC->CDCFGR1, RCC_CDCFGR1_HPRE));
    #endif /* RCC_D1CFGR_HPRE */
    }

    /**
      * @brief  Get APB1 prescaler
      * @rmtoll D2CFGR/CDCFGR2         D2PPRE1/CDPPRE1         GetAPB1Prescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref APB1_DIV_1
      *         @arg @ref APB1_DIV_2
      *         @arg @ref APB1_DIV_4
      *         @arg @ref APB1_DIV_8
      *         @arg @ref APB1_DIV_16
      */
    RCCAPB1Prescaler GetAPB1Prescaler(void)
    {
    #if defined(RCC_D2CFGR_D2PPRE1)
      return (RCCAPB1Prescaler)(READ_BIT(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1));
    #else
      return (RCCAPB1Prescaler)(READ_BIT(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1));
    #endif /* RCC_D2CFGR_D2PPRE1 */
    }

    /**
      * @brief  Get APB2 prescaler
      * @rmtoll D2CFGR/CDCFGR2         D2PPRE2/CDPPRE2         GetAPB2Prescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref APB2_DIV_1
      *         @arg @ref APB2_DIV_2
      *         @arg @ref APB2_DIV_4
      *         @arg @ref APB2_DIV_8
      *         @arg @ref APB2_DIV_16
      */
    RCCAPB2Prescaler GetAPB2Prescaler(void)
    {
    #if defined(RCC_D2CFGR_D2PPRE2)
      return (RCCAPB2Prescaler)(READ_BIT(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2));
    #else
      return (RCCAPB2Prescaler)(READ_BIT(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2));
    #endif /* RCC_D2CFGR_D2PPRE2 */
    }

    /**
      * @brief  Get APB3 prescaler
      * @rmtoll D1CFGR/CDCFGR1         D1PPRE/CDPPRE         GetAPB3Prescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref APB3_DIV_1
      *         @arg @ref APB3_DIV_2
      *         @arg @ref APB3_DIV_4
      *         @arg @ref APB3_DIV_8
      *         @arg @ref APB3_DIV_16
      */
    RCCAPB3Prescaler GetAPB3Prescaler(void)
    {
    #if defined(RCC_D1CFGR_D1PPRE)
      return (RCCAPB3Prescaler)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_D1PPRE));
    #else
      return (RCCAPB3Prescaler)(READ_BIT(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE));
    #endif /* RCC_D1CFGR_D1PPRE */
    }

    /**
      * @brief  Get APB4 prescaler
      * @rmtoll D3CFGR/SRDCFGR         D3PPRE/SRDPPRE         GetAPB4Prescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref APB4_DIV_1
      *         @arg @ref APB4_DIV_2
      *         @arg @ref APB4_DIV_4
      *         @arg @ref APB4_DIV_8
      *         @arg @ref APB4_DIV_16
      */
    RCCAPB4Prescaler GetAPB4Prescaler(void)
    {
    #if defined(RCC_D3CFGR_D3PPRE)
      return (RCCAPB4Prescaler)(READ_BIT(RCC->D3CFGR, RCC_D3CFGR_D3PPRE));
    #else
      return (RCCAPB4Prescaler)(READ_BIT(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE));
    #endif /* RCC_D3CFGR_D3PPRE */
    }

    /** @defgroup RCC_EF_MCO MCO
      * @{
      */

    /**
      * @brief  Configure MCOx
      * @rmtoll CFGR         MCO1          ConfigMCO\n
      *         CFGR         MCO1PRE       ConfigMCO\n
      *         CFGR         MCO2          ConfigMCO\n
      *         CFGR         MCO2PRE       ConfigMCO
      * @param  MCOxSource This parameter can be one of the following values:
      *         @arg @ref MCO1SOURCE_HSI
      *         @arg @ref MCO1SOURCE_LSE
      *         @arg @ref MCO1SOURCE_HSE
      *         @arg @ref MCO1SOURCE_PLL1QCLK
      *         @arg @ref MCO1SOURCE_HSI48
      *         @arg @ref MCO2SOURCE_SYSCLK
      *         @arg @ref MCO2SOURCE_PLL2PCLK
      *         @arg @ref MCO2SOURCE_HSE
      *         @arg @ref MCO2SOURCE_PLL1PCLK
      *         @arg @ref MCO2SOURCE_CSI
      *         @arg @ref MCO2SOURCE_LSI
      * @param  MCOxPrescaler This parameter can be one of the following values:
      *         @arg @ref MCO1_DIV_1
      *         @arg @ref MCO1_DIV_2
      *         @arg @ref MCO1_DIV_3
      *         @arg @ref MCO1_DIV_4
      *         @arg @ref MCO1_DIV_5
      *         @arg @ref MCO1_DIV_6
      *         @arg @ref MCO1_DIV_7
      *         @arg @ref MCO1_DIV_8
      *         @arg @ref MCO1_DIV_9
      *         @arg @ref MCO1_DIV_10
      *         @arg @ref MCO1_DIV_11
      *         @arg @ref MCO1_DIV_12
      *         @arg @ref MCO1_DIV_13
      *         @arg @ref MCO1_DIV_14
      *         @arg @ref MCO1_DIV_15
      *         @arg @ref MCO2_DIV_1
      *         @arg @ref MCO2_DIV_2
      *         @arg @ref MCO2_DIV_3
      *         @arg @ref MCO2_DIV_4
      *         @arg @ref MCO2_DIV_5
      *         @arg @ref MCO2_DIV_6
      *         @arg @ref MCO2_DIV_7
      *         @arg @ref MCO2_DIV_8
      *         @arg @ref MCO2_DIV_9
      *         @arg @ref MCO2_DIV_10
      *         @arg @ref MCO2_DIV_11
      *         @arg @ref MCO2_DIV_12
      *         @arg @ref MCO2_DIV_13
      *         @arg @ref MCO2_DIV_14
      *         @arg @ref MCO2_DIV_15
      * @retval None
      */
    void ConfigMCO(RCCMCOxSource MCOxSource, RCCMCOxPrescaler MCOxPrescaler)
    {
      MODIFY_REG(RCC->CFGR, (MCOxSource << 16U) | (MCOxPrescaler << 16U), (MCOxSource & 0xFFFF0000U) | (MCOxPrescaler & 0xFFFF0000U));
    }
    /** @defgroup RCC_EF_Peripheral_Clock_Source Peripheral Clock Source
      * @{
      */

    /**
      * @brief  Configure periph clock source
      * @rmtoll D2CCIP1R/CDCCIP1R        *     SetClockSource\n
      *         D2CCIP2R/CDCCIP2R        *     SetClockSource\n
      *         D3CCIPR/SRDCCIPR         *     SetClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref USART16_CLKSOURCE_PCLK2
      *         @arg @ref USART16_CLKSOURCE_PLL2Q
      *         @arg @ref USART16_CLKSOURCE_PLL3Q
      *         @arg @ref USART16_CLKSOURCE_HSI
      *         @arg @ref USART16_CLKSOURCE_CSI
      *         @arg @ref USART16_CLKSOURCE_LSE
      *         @arg @ref USART234578_CLKSOURCE_PCLK1
      *         @arg @ref USART234578_CLKSOURCE_PLL2Q
      *         @arg @ref USART234578_CLKSOURCE_PLL3Q
      *         @arg @ref USART234578_CLKSOURCE_HSI
      *         @arg @ref USART234578_CLKSOURCE_CSI
      *         @arg @ref USART234578_CLKSOURCE_LSE
      *         @arg @ref I2C123_CLKSOURCE_PCLK1
      *         @arg @ref I2C123_CLKSOURCE_PLL3R
      *         @arg @ref I2C123_CLKSOURCE_HSI
      *         @arg @ref I2C123_CLKSOURCE_CSI
      *         @arg @ref I2C4_CLKSOURCE_PCLK4
      *         @arg @ref I2C4_CLKSOURCE_PLL3R
      *         @arg @ref I2C4_CLKSOURCE_HSI
      *         @arg @ref I2C4_CLKSOURCE_CSI
      *         @arg @ref LPTIM1_CLKSOURCE_PCLK1
      *         @arg @ref LPTIM1_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM1_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM1_CLKSOURCE_LSE
      *         @arg @ref LPTIM1_CLKSOURCE_LSI
      *         @arg @ref LPTIM1_CLKSOURCE_CLKP
      *         @arg @ref LPTIM2_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM2_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM2_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM2_CLKSOURCE_LSE
      *         @arg @ref LPTIM2_CLKSOURCE_LSI
      *         @arg @ref LPTIM2_CLKSOURCE_CLKP
      *         @arg @ref LPTIM345_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM345_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM345_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM345_CLKSOURCE_LSE
      *         @arg @ref LPTIM345_CLKSOURCE_LSI
      *         @arg @ref LPTIM345_CLKSOURCE_CLKP
      *         @arg @ref SAI1_CLKSOURCE_PLL1Q
      *         @arg @ref SAI1_CLKSOURCE_PLL2P
      *         @arg @ref SAI1_CLKSOURCE_PLL3P
      *         @arg @ref SAI1_CLKSOURCE_I2S_CKIN
      *         @arg @ref SAI1_CLKSOURCE_CLKP
      *         @arg @ref SAI23_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI23_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI23_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL2P  (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL3P  (*)
      *         @arg @ref SAI4A_CLKSOURCE_I2S_CKIN  (*)
      *         @arg @ref SAI4A_CLKSOURCE_SPDIF  (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL1Q  (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL2P  (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL3P  (*)
      *         @arg @ref SAI2A_CLKSOURCE_I2S_CKIN  (*)
      *         @arg @ref SAI2A_CLKSOURCE_CLKP  (*)
      *         @arg @ref SAI2A_CLKSOURCE_SPDIF  (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL1Q  (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI4B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI4B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4B_CLKSOURCE_SPDIF (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI2B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI2B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2B_CLKSOURCE_SPDIF  (*)
      *         @arg @ref SPI123_CLKSOURCE_PLL1Q
      *         @arg @ref SPI123_CLKSOURCE_PLL2P
      *         @arg @ref SPI123_CLKSOURCE_PLL3P
      *         @arg @ref SPI123_CLKSOURCE_I2S_CKIN
      *         @arg @ref SPI123_CLKSOURCE_CLKP
      *         @arg @ref SPI45_CLKSOURCE_PCLK2
      *         @arg @ref SPI45_CLKSOURCE_PLL2Q
      *         @arg @ref SPI45_CLKSOURCE_PLL3Q
      *         @arg @ref SPI45_CLKSOURCE_HSI
      *         @arg @ref SPI45_CLKSOURCE_CSI
      *         @arg @ref SPI45_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_PCLK4
      *         @arg @ref SPI6_CLKSOURCE_PLL2Q
      *         @arg @ref SPI6_CLKSOURCE_PLL3Q
      *         @arg @ref SPI6_CLKSOURCE_HSI
      *         @arg @ref SPI6_CLKSOURCE_CSI
      *         @arg @ref SPI6_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_I2S_CKIN (*)
      *
      *         (*) value not defined in all devices.
      * @retval None
      */
    void SetClockSource(uint32_t ClkSource)
    {
    #if defined(RCC_D1CCIPR_FMCSEL)
      uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->D1CCIPR + CLKSOURCE_REG(ClkSource));
    #else
      uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CDCCIPR + CLKSOURCE_REG(ClkSource));
    #endif /*  */
      MODIFY_REG(*pReg, CLKSOURCE_MASK(ClkSource), CLKSOURCE_CONFIG(ClkSource));
    }

    /**
      * @brief  Configure USARTx clock source
      * @rmtoll D2CCIP2R / D2CCIP2R        USART16SEL     SetUSARTClockSource\n
      *         D2CCIP2R / D2CCIP2R        USART28SEL     SetUSARTClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref USART16_CLKSOURCE_PCLK2
      *         @arg @ref USART16_CLKSOURCE_PLL2Q
      *         @arg @ref USART16_CLKSOURCE_PLL3Q
      *         @arg @ref USART16_CLKSOURCE_HSI
      *         @arg @ref USART16_CLKSOURCE_CSI
      *         @arg @ref USART16_CLKSOURCE_LSE
      *         @arg @ref USART234578_CLKSOURCE_PCLK1
      *         @arg @ref USART234578_CLKSOURCE_PLL2Q
      *         @arg @ref USART234578_CLKSOURCE_PLL3Q
      *         @arg @ref USART234578_CLKSOURCE_HSI
      *         @arg @ref USART234578_CLKSOURCE_CSI
      *         @arg @ref USART234578_CLKSOURCE_LSE
      * @retval None
      */
    void SetUSARTClockSource(RCCUSARTxClkSource ClkSource)
    {
      SetClockSource(ClkSource);
    }

    /**
      * @brief  Configure LPUARTx clock source
      * @rmtoll D3CCIPR / SRDCCIPR        LPUART1SEL     SetLPUARTClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref LPUART1_CLKSOURCE_PCLK4
      *         @arg @ref LPUART1_CLKSOURCE_PLL2Q
      *         @arg @ref LPUART1_CLKSOURCE_PLL3Q
      *         @arg @ref LPUART1_CLKSOURCE_HSI
      *         @arg @ref LPUART1_CLKSOURCE_CSI
      *         @arg @ref LPUART1_CLKSOURCE_LSE
      * @retval None
      */
    void SetLPUARTClockSource(RCCLPUARTxClkSource ClkSource)
    {
    #if defined(RCC_D3CCIPR_LPUART1SEL)
      MODIFY_REG(RCC->D3CCIPR, RCC_D3CCIPR_LPUART1SEL, ClkSource);
    #else
      MODIFY_REG(RCC->SRDCCIPR, RCC_SRDCCIPR_LPUART1SEL, ClkSource);
    #endif /* RCC_D3CCIPR_LPUART1SEL */
    }

    /**
      * @brief  Configure I2Cx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R       I2C123SEL       SetI2CClockSource\n
      *         D3CCIPR / SRDCCIPR        I2C4SEL         SetI2CClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref I2C123_CLKSOURCE_PCLK1
      *         @arg @ref I2C123_CLKSOURCE_PLL3R
      *         @arg @ref I2C123_CLKSOURCE_HSI
      *         @arg @ref I2C123_CLKSOURCE_CSI
      *         @arg @ref I2C4_CLKSOURCE_PCLK4
      *         @arg @ref I2C4_CLKSOURCE_PLL3R
      *         @arg @ref I2C4_CLKSOURCE_HSI
      *         @arg @ref I2C4_CLKSOURCE_CSI
      * @retval None
      */
    void SetI2CClockSource(RCCI2CxClkSource ClkSource)
    {
      SetClockSource(ClkSource);
    }

    /**
      * @brief  Configure LPTIMx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R      LPTIM1SEL     SetLPTIMClockSource
      *         D3CCIPR  / SRDCCIPR      LPTIM2SEL     SetLPTIMClockSource\n
      *         D3CCIPR  / SRDCCIPR      LPTIM345SEL   SetLPTIMClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref LPTIM1_CLKSOURCE_PCLK1
      *         @arg @ref LPTIM1_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM1_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM1_CLKSOURCE_LSE
      *         @arg @ref LPTIM1_CLKSOURCE_LSI
      *         @arg @ref LPTIM1_CLKSOURCE_CLKP
      *         @arg @ref LPTIM2_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM2_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM2_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM2_CLKSOURCE_LSE
      *         @arg @ref LPTIM2_CLKSOURCE_LSI
      *         @arg @ref LPTIM2_CLKSOURCE_CLKP
      *         @arg @ref LPTIM345_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM345_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM345_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM345_CLKSOURCE_LSE
      *         @arg @ref LPTIM345_CLKSOURCE_LSI
      *         @arg @ref LPTIM345_CLKSOURCE_CLKP
      * @retval None
      */
    void SetLPTIMClockSource(RCCLPTIMxClkSource ClkSource)
    {
      SetClockSource(ClkSource);
    }

    /**
      * @brief  Configure SAIx clock source
      * @rmtoll D2CCIP1R / CDCCIP1R       SAI1SEL       SetSAIClockSource\n
      *         D2CCIP1R / CDCCIP1R       SAI23SEL      SetSAIClockSource
      *         D3CCIPR  / SRDCCIPR       SAI4ASEL      SetSAI4xClockSource\n
      *         D3CCIPR  / SRDCCIPR       SAI4BSEL      SetSAI4xClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref SAI1_CLKSOURCE_PLL1Q
      *         @arg @ref SAI1_CLKSOURCE_PLL2P
      *         @arg @ref SAI1_CLKSOURCE_PLL3P
      *         @arg @ref SAI1_CLKSOURCE_I2S_CKIN
      *         @arg @ref SAI1_CLKSOURCE_CLKP
      *         @arg @ref SAI23_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI23_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI23_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL2P  (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL3P  (*)
      *         @arg @ref SAI4A_CLKSOURCE_I2S_CKIN  (*)
      *         @arg @ref SAI4A_CLKSOURCE_SPDIF  (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL1Q  (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL2P  (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL3P  (*)
      *         @arg @ref SAI2A_CLKSOURCE_I2S_CKIN  (*)
      *         @arg @ref SAI2A_CLKSOURCE_CLKP  (*)
      *         @arg @ref SAI2A_CLKSOURCE_SPDIF  (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL1Q  (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI4B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI4B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4B_CLKSOURCE_SPDIF  (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI2B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI2B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2B_CLKSOURCE_SPDIF  (*)
      *
      *         (*) value not defined in all devices.
      * @retval None
      */
    void SetSAIClockSource(RCCSAIxClkSource ClkSource)
    {
      SetClockSource(ClkSource);
    }

    /**
      * @brief  Configure SDMMCx clock source
      * @rmtoll D1CCIPR / CDCCIPR       SDMMCSEL      SetSDMMCClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref SDMMC_CLKSOURCE_PLL1Q
      *         @arg @ref SDMMC_CLKSOURCE_PLL2R
      * @retval None
      */
    void SetSDMMCClockSource(RCCSDMMCClkSource ClkSource)
    {
    #if defined(RCC_D1CCIPR_SDMMCSEL)
      MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_SDMMCSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIPR, RCC_CDCCIPR_SDMMCSEL, ClkSource);
    #endif /* RCC_D1CCIPR_SDMMCSEL */
    }

    /**
      * @brief  Configure RNGx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R       RNGSEL      SetRNGClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref RNG_CLKSOURCE_HSI48
      *         @arg @ref RNG_CLKSOURCE_PLL1Q
      *         @arg @ref RNG_CLKSOURCE_LSE
      *         @arg @ref RNG_CLKSOURCE_LSI
      * @retval None
      */
    void SetRNGClockSource(RCCRNGClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP2R_RNGSEL)
      MODIFY_REG(RCC->D2CCIP2R, RCC_D2CCIP2R_RNGSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP2R, RCC_CDCCIP2R_RNGSEL, ClkSource);
    #endif /* RCC_D2CCIP2R_RNGSEL */
    }

    /**
      * @brief  Configure USBx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R      USBSEL      SetUSBClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref USB_CLKSOURCE_DISABLE
      *         @arg @ref USB_CLKSOURCE_PLL1Q
      *         @arg @ref USB_CLKSOURCE_PLL3Q
      *         @arg @ref USB_CLKSOURCE_HSI48
      * @retval None
      */
    void SetUSBClockSource(RCCUSBClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP2R_USBSEL)
      MODIFY_REG(RCC->D2CCIP2R, RCC_D2CCIP2R_USBSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP2R, RCC_CDCCIP2R_USBSEL, ClkSource);
    #endif /* RCC_D2CCIP2R_USBSEL */
    }

    /**
      * @brief  Configure CECx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R         CECSEL        SetCECClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref CEC_CLKSOURCE_LSE
      *         @arg @ref CEC_CLKSOURCE_LSI
      *         @arg @ref CEC_CLKSOURCE_CSI_DIV122
      * @retval None
      */
    void SetCECClockSource(RCCCECClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP2R_CECSEL)
      MODIFY_REG(RCC->D2CCIP2R, RCC_D2CCIP2R_CECSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP2R, RCC_CDCCIP2R_CECSEL, ClkSource);
    #endif /* RCC_D2CCIP2R_CECSEL */
    }

    #if defined(DSI)
    /**
      * @brief  Configure DSIx clock source
      * @rmtoll D1CCIPR         DSISEL        SetDSIClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref DSI_CLKSOURCE_PHY
      *         @arg @ref DSI_CLKSOURCE_PLL2Q
      * @retval None
      */
    void SetDSIClockSource(RCCDSIClkSource ClkSource)
    {
      MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_DSISEL, ClkSource);
    }
    #endif /* DSI */

    /**
      * @brief  Configure DFSDMx Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R         DFSDM1SEL        SetDFSDMClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref DFSDM1_CLKSOURCE_PCLK2
      *         @arg @ref DFSDM1_CLKSOURCE_SYSCLK
      * @retval None
      */
    void SetDFSDMClockSource(RCCDFSDM1ClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP1R_DFSDM1SEL)
      MODIFY_REG(RCC->D2CCIP1R, RCC_D2CCIP1R_DFSDM1SEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP1R, RCC_CDCCIP1R_DFSDM1SEL, ClkSource);
    #endif /* RCC_D2CCIP1R_DFSDM1SEL */
    }

    #if defined(DFSDM2_BASE)
    /**
      * @brief  Configure DFSDMx Kernel clock source
      * @rmtoll SRDCCIPR                   DFSDM2SEL        SetDFSDM2ClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref DFSDM2_CLKSOURCE_PCLK4
      *         @arg @ref DFSDM2_CLKSOURCE_SYSCLK
      * @retval None
      */
    void SetDFSDM2ClockSource(RCCDFSDM2ClkSource ClkSource)
    {
      MODIFY_REG(RCC->SRDCCIPR, RCC_SRDCCIPR_DFSDM2SEL, ClkSource);
    }
    #endif /* DFSDM2_BASE */

    /**
      * @brief  Configure FMCx Kernel clock source
      * @rmtoll D1CCIPR /  CDCCIPR        FMCSEL        SetFMCClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref FMC_CLKSOURCE_HCLK
      *         @arg @ref FMC_CLKSOURCE_PLL1Q
      *         @arg @ref FMC_CLKSOURCE_PLL2R
      *         @arg @ref FMC_CLKSOURCE_CLKP
      * @retval None
      */
    void SetFMCClockSource(RCCFMCClkSource ClkSource)
    {
    #if defined(RCC_D1CCIPR_FMCSEL)
      MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_FMCSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIPR, RCC_CDCCIPR_FMCSEL, ClkSource);
    #endif /* RCC_D1CCIPR_FMCSEL */
    }

    #if defined(QUADSPI)
    /**
      * @brief  Configure QSPIx Kernel clock source
      * @rmtoll D1CCIPR         QSPISEL        SetQSPIClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref QSPI_CLKSOURCE_HCLK
      *         @arg @ref QSPI_CLKSOURCE_PLL1Q
      *         @arg @ref QSPI_CLKSOURCE_PLL2R
      *         @arg @ref QSPI_CLKSOURCE_CLKP
      * @retval None
      */
    void SetQSPIClockSource(RCCQSPIClkSource ClkSource)
    {
      MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_QSPISEL, ClkSource);
    }
    #endif /* QUADSPI */

    #if defined(OCTOSPI1) || defined(OCTOSPI2)
    /**
      * @brief  Configure OSPIx Kernel clock source
      * @rmtoll D1CCIPR         OPISEL        SetOSPIClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref OSPI_CLKSOURCE_HCLK
      *         @arg @ref OSPI_CLKSOURCE_PLL1Q
      *         @arg @ref OSPI_CLKSOURCE_PLL2R
      *         @arg @ref OSPI_CLKSOURCE_CLKP
      * @retval None
      */
    void SetOSPIClockSource(RCCOSPIClkSource ClkSource)
    {
    #if defined(RCC_D1CCIPR_OCTOSPISEL)
      MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_OCTOSPISEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIPR, RCC_CDCCIPR_OCTOSPISEL, ClkSource);
    #endif /* RCC_D1CCIPR_OCTOSPISEL */
    }
    #endif /* OCTOSPI1 || OCTOSPI2 */

    /**
      * @brief  Configure CLKP Kernel clock source
      * @rmtoll D1CCIPR / CDCCIPR         CKPERSEL        SetCLKPClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref CLKP_CLKSOURCE_HSI
      *         @arg @ref CLKP_CLKSOURCE_CSI
      *         @arg @ref CLKP_CLKSOURCE_HSE
      * @retval None
      */
    void SetCLKPClockSource(RCCCLKPClkSource ClkSource)
    {
    #if defined(RCC_D1CCIPR_CKPERSEL)
      MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_CKPERSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIPR, RCC_CDCCIPR_CKPERSEL, ClkSource);
    #endif /* RCC_D1CCIPR_CKPERSEL */
    }

    /**
      * @brief  Configure SPIx Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R       SPI123SEL        SetSPIClockSource\n
      *         D2CCIP1R / CDCCIP1R       SPI45SEL         SetSPIClockSource\n
      *         D3CCIPR  / SRDCCIPR       SPI6SEL          SetSPIClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref SPI123_CLKSOURCE_PLL1Q
      *         @arg @ref SPI123_CLKSOURCE_PLL2P
      *         @arg @ref SPI123_CLKSOURCE_PLL3P
      *         @arg @ref SPI123_CLKSOURCE_I2S_CKIN
      *         @arg @ref SPI123_CLKSOURCE_CLKP
      *         @arg @ref SPI45_CLKSOURCE_PCLK2
      *         @arg @ref SPI45_CLKSOURCE_PLL2Q
      *         @arg @ref SPI45_CLKSOURCE_PLL3Q
      *         @arg @ref SPI45_CLKSOURCE_HSI
      *         @arg @ref SPI45_CLKSOURCE_CSI
      *         @arg @ref SPI45_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_PCLK4
      *         @arg @ref SPI6_CLKSOURCE_PLL2Q
      *         @arg @ref SPI6_CLKSOURCE_PLL3Q
      *         @arg @ref SPI6_CLKSOURCE_HSI
      *         @arg @ref SPI6_CLKSOURCE_CSI
      *         @arg @ref SPI6_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_I2S_CKIN (*)
      *
      *         (*) value not defined in all devices.
      * @retval None
      */
    void SetSPIClockSource(RCCSPIxClkSource ClkSource)
    {
      SetClockSource(ClkSource);
    }

    /**
      * @brief  Configure SPDIFx Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R       SPDIFSEL        SetSPDIFClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref SPDIF_CLKSOURCE_PLL1Q
      *         @arg @ref SPDIF_CLKSOURCE_PLL2R
      *         @arg @ref SPDIF_CLKSOURCE_PLL3R
      *         @arg @ref SPDIF_CLKSOURCE_HSI
      * @retval None
      */
    void SetSPDIFClockSource(RCCSPDIFClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP1R_SPDIFSEL)
      MODIFY_REG(RCC->D2CCIP1R, RCC_D2CCIP1R_SPDIFSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP1R, RCC_CDCCIP1R_SPDIFSEL, ClkSource);
    #endif /* RCC_D2CCIP1R_SPDIFSEL */
    }

    /**
      * @brief  Configure FDCANx Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R      FDCANSEL        SetFDCANClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref FDCAN_CLKSOURCE_HSE
      *         @arg @ref FDCAN_CLKSOURCE_PLL1Q
      *         @arg @ref FDCAN_CLKSOURCE_PLL2Q
      * @retval None
      */
    void SetFDCANClockSource(RCCFDCANClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP1R_FDCANSEL)
      MODIFY_REG(RCC->D2CCIP1R, RCC_D2CCIP1R_FDCANSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP1R, RCC_CDCCIP1R_FDCANSEL, ClkSource);
    #endif /* RCC_D2CCIP1R_FDCANSEL */
    }

    /**
      * @brief  Configure SWPx Kernel clock source
      * @rmtoll D2CCIP1R /  CDCCIP1R       SWPSEL        SetSWPClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref SWP_CLKSOURCE_PCLK1
      *         @arg @ref SWP_CLKSOURCE_HSI
      * @retval None
      */
    void SetSWPClockSource(RCCSWPClkSource ClkSource)
    {
    #if defined(RCC_D2CCIP1R_SWPSEL)
      MODIFY_REG(RCC->D2CCIP1R, RCC_D2CCIP1R_SWPSEL, ClkSource);
    #else
      MODIFY_REG(RCC->CDCCIP1R, RCC_CDCCIP1R_SWPSEL, ClkSource);
    #endif /* RCC_D2CCIP1R_SWPSEL */
    }

    /**
      * @brief  Configure ADCx Kernel clock source
      * @rmtoll D3CCIPR / SRDCCIPR        ADCSEL        SetADCClockSource
      * @param  ClkSource This parameter can be one of the following values:
      *         @arg @ref ADC_CLKSOURCE_PLL2P
      *         @arg @ref ADC_CLKSOURCE_PLL3R
      *         @arg @ref ADC_CLKSOURCE_CLKP
      * @retval None
      */
    void SetADCClockSource(RCCADCClkSource ClkSource)
    {
    #if defined(RCC_D3CCIPR_ADCSEL)
      MODIFY_REG(RCC->D3CCIPR, RCC_D3CCIPR_ADCSEL, ClkSource);
    #else
      MODIFY_REG(RCC->SRDCCIPR, RCC_SRDCCIPR_ADCSEL, ClkSource);
    #endif /* RCC_D3CCIPR_ADCSEL */
    }

    /**
      * @brief  Get periph clock source
      * @rmtoll D1CCIPR  / CDCCIPR       *     GetClockSource\n
      *         D2CCIP1R / CDCCIP1R      *     GetClockSource\n
      *         D2CCIP2R / CDCCIP2R      *     GetClockSource\n
      *         D3CCIPR  / SRDCCIPR      *     GetClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref USART16_CLKSOURCE
      *         @arg @ref USART234578_CLKSOURCE
      *         @arg @ref I2C123_CLKSOURCE
      *         @arg @ref I2C4_CLKSOURCE
      *         @arg @ref LPTIM1_CLKSOURCE
      *         @arg @ref LPTIM2_CLKSOURCE
      *         @arg @ref LPTIM345_CLKSOURCE
      *         @arg @ref SAI1_CLKSOURCE
      *         @arg @ref SAI23_CLKSOURCE
      *         @arg @ref SAI4A_CLKSOURCE (*)
      *         @arg @ref SAI4B_CLKSOURCE (*)
      *         @arg @ref SAI2A_CLKSOURCE (*)
      *         @arg @ref SAI2B_CLKSOURCE (*)
      *         @arg @ref SPI123_CLKSOURCE (*)
      *         @arg @ref SPI45_CLKSOURCE (*)
      *         @arg @ref SPI6_CLKSOURCE (*)
      * @retval Returned value can be one of the following values:
      *         @arg @ref USART16_CLKSOURCE_PCLK2
      *         @arg @ref USART16_CLKSOURCE_PLL2Q
      *         @arg @ref USART16_CLKSOURCE_PLL3Q
      *         @arg @ref USART16_CLKSOURCE_HSI
      *         @arg @ref USART16_CLKSOURCE_CSI
      *         @arg @ref USART16_CLKSOURCE_LSE
      *         @arg @ref USART234578_CLKSOURCE_PCLK1
      *         @arg @ref USART234578_CLKSOURCE_PLL2Q
      *         @arg @ref USART234578_CLKSOURCE_PLL3Q
      *         @arg @ref USART234578_CLKSOURCE_HSI
      *         @arg @ref USART234578_CLKSOURCE_CSI
      *         @arg @ref USART234578_CLKSOURCE_LSE
      *         @arg @ref I2C123_CLKSOURCE_PCLK1
      *         @arg @ref I2C123_CLKSOURCE_PLL3R
      *         @arg @ref I2C123_CLKSOURCE_HSI
      *         @arg @ref I2C123_CLKSOURCE_CSI
      *         @arg @ref I2C4_CLKSOURCE_PCLK4
      *         @arg @ref I2C4_CLKSOURCE_PLL3R
      *         @arg @ref I2C4_CLKSOURCE_HSI
      *         @arg @ref I2C4_CLKSOURCE_CSI
      *         @arg @ref LPTIM1_CLKSOURCE_PCLK1
      *         @arg @ref LPTIM1_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM1_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM1_CLKSOURCE_LSE
      *         @arg @ref LPTIM1_CLKSOURCE_LSI
      *         @arg @ref LPTIM1_CLKSOURCE_CLKP
      *         @arg @ref LPTIM2_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM2_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM2_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM2_CLKSOURCE_LSE
      *         @arg @ref LPTIM2_CLKSOURCE_LSI
      *         @arg @ref LPTIM2_CLKSOURCE_CLKP
      *         @arg @ref LPTIM345_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM345_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM345_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM345_CLKSOURCE_LSE
      *         @arg @ref LPTIM345_CLKSOURCE_LSI
      *         @arg @ref LPTIM345_CLKSOURCE_CLKP
      *         @arg @ref SAI1_CLKSOURCE_PLL1Q
      *         @arg @ref SAI1_CLKSOURCE_PLL2P
      *         @arg @ref SAI1_CLKSOURCE_PLL3P
      *         @arg @ref SAI1_CLKSOURCE_I2S_CKIN
      *         @arg @ref SAI1_CLKSOURCE_CLKP
      *         @arg @ref SAI23_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI23_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI23_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI4A_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI4A_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI4B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI4B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI2A_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI2A_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2B_CLKSOURCE_SPDIF (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI2B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI2B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2B_CLKSOURCE_SPDIF (*)
      *         @arg @ref SPI123_CLKSOURCE_PLL1Q
      *         @arg @ref SPI123_CLKSOURCE_PLL2P
      *         @arg @ref SPI123_CLKSOURCE_PLL3P
      *         @arg @ref SPI123_CLKSOURCE_I2S_CKIN
      *         @arg @ref SPI123_CLKSOURCE_CLKP
      *         @arg @ref SPI45_CLKSOURCE_PCLK2
      *         @arg @ref SPI45_CLKSOURCE_PLL2Q
      *         @arg @ref SPI45_CLKSOURCE_PLL3Q
      *         @arg @ref SPI45_CLKSOURCE_HSI
      *         @arg @ref SPI45_CLKSOURCE_CSI
      *         @arg @ref SPI45_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_PCLK4
      *         @arg @ref SPI6_CLKSOURCE_PLL2Q
      *         @arg @ref SPI6_CLKSOURCE_PLL3Q
      *         @arg @ref SPI6_CLKSOURCE_HSI
      *         @arg @ref SPI6_CLKSOURCE_CSI
      *         @arg @ref SPI6_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_I2S_CKIN (*)
      *
      *         (*) value not defined in all devices.
      * @retval None
      */
    uint32_t GetClockSource(uint32_t Periph)
    {
    #if defined(RCC_D1CCIPR_FMCSEL)
      const uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->D1CCIPR) + CLKSOURCE_REG(Periph)));
    #else
      const uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CDCCIPR) + CLKSOURCE_REG(Periph)));
    #endif /* RCC_D1CCIPR_FMCSEL */
      return (uint32_t)(Periph | (((READ_BIT(*pReg, CLKSOURCE_MASK(Periph))) >> CLKSOURCE_SHIFT(Periph)) << RCC_CONFIG_SHIFT));
    }

    /**
      * @brief  Get USARTx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R      USART16SEL     GetUSARTClockSource\n
      *         D2CCIP2R / CDCCIP2R      USART28SEL     GetUSARTClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref USART16_CLKSOURCE
      *         @arg @ref USART234578_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref USART16_CLKSOURCE_PCLK2
      *         @arg @ref USART16_CLKSOURCE_PLL2Q
      *         @arg @ref USART16_CLKSOURCE_PLL3Q
      *         @arg @ref USART16_CLKSOURCE_HSI
      *         @arg @ref USART16_CLKSOURCE_CSI
      *         @arg @ref USART16_CLKSOURCE_LSE
      *         @arg @ref USART234578_CLKSOURCE_PCLK1
      *         @arg @ref USART234578_CLKSOURCE_PLL2Q
      *         @arg @ref USART234578_CLKSOURCE_PLL3Q
      *         @arg @ref USART234578_CLKSOURCE_HSI
      *         @arg @ref USART234578_CLKSOURCE_CSI
      *         @arg @ref USART234578_CLKSOURCE_LSE
      */
    RCCUSARTxClkSource GetUSARTClockSource(RCCUSARTxGetClkSource Periph)
    {
      return (RCCUSARTxClkSource)GetClockSource(Periph);
    }

    /**
      * @brief  Get LPUART clock source
      * @rmtoll D3CCIPR / SRDCCIPR       LPUART1SEL     GetLPUARTClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref LPUART1_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref LPUART1_CLKSOURCE_PCLK4
      *         @arg @ref LPUART1_CLKSOURCE_PLL2Q
      *         @arg @ref LPUART1_CLKSOURCE_PLL3Q
      *         @arg @ref LPUART1_CLKSOURCE_HSI
      *         @arg @ref LPUART1_CLKSOURCE_CSI
      *         @arg @ref LPUART1_CLKSOURCE_LSE
      */
    RCCLPUARTxClkSource GetLPUARTClockSource(RCCLPUARTxGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D3CCIPR_LPUART1SEL)
      return (RCCLPUARTxClkSource)(READ_BIT(RCC->D3CCIPR, RCC_D3CCIPR_LPUART1SEL));
    #else
      return (RCCLPUARTxClkSource)(READ_BIT(RCC->SRDCCIPR, RCC_SRDCCIPR_LPUART1SEL));
    #endif  /* RCC_D3CCIPR_LPUART1SEL */
    }

    /**
      * @brief  Get I2Cx clock source
      * @rmtoll D2CCIP2R / CDCCIP2R     I2C123SEL       GetI2CClockSource\n
      *         D3CCIPR  / SRDCCIPR     I2C4SEL         GetI2CClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref I2C123_CLKSOURCE
      *         @arg @ref I2C4_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref I2C123_CLKSOURCE_PCLK1
      *         @arg @ref I2C123_CLKSOURCE_PLL3R
      *         @arg @ref I2C123_CLKSOURCE_HSI
      *         @arg @ref I2C123_CLKSOURCE_CSI
      *         @arg @ref I2C4_CLKSOURCE_PCLK4
      *         @arg @ref I2C4_CLKSOURCE_PLL3R
      *         @arg @ref I2C4_CLKSOURCE_HSI
      *         @arg @ref I2C4_CLKSOURCE_CSI
      */
    RCCI2CxClkSource GetI2CClockSource(RCCI2CxGetClkSource Periph)
    {
      return (RCCI2CxClkSource)GetClockSource(Periph);
    }

    /**
      * @brief  Get LPTIM clock source
      * @rmtoll D2CCIP2R / CDCCIP2R      LPTIM1SEL     GetLPTIMClockSource\n
      *         D3CCIPR  / SRDCCIPR      LPTIM2SEL     GetLPTIMClockSource\n
      *         D3CCIPR  / SRDCCIPR      LPTIM345SEL   GetLPTIMClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref LPTIM1_CLKSOURCE
      *         @arg @ref LPTIM2_CLKSOURCE
      *         @arg @ref LPTIM345_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref LPTIM1_CLKSOURCE_PCLK1
      *         @arg @ref LPTIM1_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM1_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM1_CLKSOURCE_LSE
      *         @arg @ref LPTIM1_CLKSOURCE_LSI
      *         @arg @ref LPTIM1_CLKSOURCE_CLKP
      *         @arg @ref LPTIM2_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM2_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM2_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM2_CLKSOURCE_LSE
      *         @arg @ref LPTIM2_CLKSOURCE_LSI
      *         @arg @ref LPTIM2_CLKSOURCE_CLKP
      *         @arg @ref LPTIM345_CLKSOURCE_PCLK4
      *         @arg @ref LPTIM345_CLKSOURCE_PLL2P
      *         @arg @ref LPTIM345_CLKSOURCE_PLL3R
      *         @arg @ref LPTIM345_CLKSOURCE_LSE
      *         @arg @ref LPTIM345_CLKSOURCE_LSI
      *         @arg @ref LPTIM345_CLKSOURCE_CLKP
      * @retval None
      */
    RCCLPTIMxClkSource GetLPTIMClockSource(RCCLPTIMxGetClkSource Periph)
    {
      return (RCCLPTIMxClkSource)GetClockSource(Periph);
    }

    /**
      * @brief  Get SAIx clock source
      * @rmtoll D2CCIP1R / CDCCIP1R     SAI1SEL       GetSAIClockSource\n
      *         D2CCIP1R / CDCCIP1R     SAI23SEL      GetSAIClockSource
      *         D3CCIPR  / SRDCCIPR     SAI4ASEL      GetSAIClockSource\n
      *         D3CCIPR  / SRDCCIPR     SAI4BSEL      GetSAIClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref SAI1_CLKSOURCE    (*)
      *         @arg @ref SAI2A_CLKSOURCE  (*)
      *         @arg @ref SAI2B_CLKSOURCE  (*)
      *         @arg @ref SAI23_CLKSOURCE   (*)
      *         @arg @ref SAI4A_CLKSOURCE   (*)
      *         @arg @ref SAI4B_CLKSOURCE   (*)
      * @retval Returned value can be one of the following values:
      *         @arg @ref SAI1_CLKSOURCE_PLL1Q
      *         @arg @ref SAI1_CLKSOURCE_PLL2P
      *         @arg @ref SAI1_CLKSOURCE_PLL3P
      *         @arg @ref SAI1_CLKSOURCE_I2S_CKIN
      *         @arg @ref SAI1_CLKSOURCE_CLKP
      *         @arg @ref SAI23_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI23_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI23_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI23_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI2A_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI2A_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI2A_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2A_CLKSOURCE_SPDIF (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI2B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI2B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI2B_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI2B_CLKSOURCE_SPDIF (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI4A_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI4A_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI4A_CLKSOURCE_CLKP (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL1Q (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL2P (*)
      *         @arg @ref SAI4B_CLKSOURCE_PLL3P (*)
      *         @arg @ref SAI4B_CLKSOURCE_I2S_CKIN (*)
      *         @arg @ref SAI4B_CLKSOURCE_CLKP (*)
      *
      *  (*) value not defined in all devices.
      */
    RCCSAIxClkSource GetSAIClockSource(RCCSAIxGetClkSource Periph)
    {
      return (RCCSAIxClkSource)GetClockSource(Periph);
    }

    /**
      * @brief  Get SDMMC clock source
      * @rmtoll D1CCIPR / CDCCIPR      SDMMCSEL      GetSDMMCClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref SDMMC_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref SDMMC_CLKSOURCE_PLL1Q
      *         @arg @ref SDMMC_CLKSOURCE_PLL2R
      */
    RCCSDMMCClkSource GetSDMMCClockSource(RCCSDMMCGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D1CCIPR_SDMMCSEL)
      return (RCCSDMMCClkSource)(READ_BIT(RCC->D1CCIPR, RCC_D1CCIPR_SDMMCSEL));
    #else
      return (RCCSDMMCClkSource)(READ_BIT(RCC->CDCCIPR, RCC_CDCCIPR_SDMMCSEL));
    #endif /* RCC_D1CCIPR_SDMMCSEL */
    }

    /**
      * @brief  Get RNG clock source
      * @rmtoll D2CCIP2R        RNGSEL      GetRNGClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref RNG_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref RNG_CLKSOURCE_HSI48
      *         @arg @ref RNG_CLKSOURCE_PLL1Q
      *         @arg @ref RNG_CLKSOURCE_LSE
      *         @arg @ref RNG_CLKSOURCE_LSI
      */
    RCCRNGClkSource GetRNGClockSource(RCCRNGGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP2R_RNGSEL)
      return (RCCRNGClkSource)(READ_BIT(RCC->D2CCIP2R, RCC_D2CCIP2R_RNGSEL));
    #else
      return (RCCRNGClkSource)(READ_BIT(RCC->CDCCIP2R, RCC_CDCCIP2R_RNGSEL));
    #endif /* RCC_D2CCIP2R_RNGSEL */
    }

    /**
      * @brief  Get USB clock source
      * @rmtoll D2CCIP2R / CDCCIP2R      USBSEL      GetUSBClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref USB_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref USB_CLKSOURCE_DISABLE
      *         @arg @ref USB_CLKSOURCE_PLL1Q
      *         @arg @ref USB_CLKSOURCE_PLL3Q
      *         @arg @ref USB_CLKSOURCE_HSI48
      */
    RCCUSBClkSource GetUSBClockSource(RCCUSBGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP2R_USBSEL)
      return (RCCUSBClkSource)(READ_BIT(RCC->D2CCIP2R, RCC_D2CCIP2R_USBSEL));
    #else
      return (RCCUSBClkSource)(READ_BIT(RCC->CDCCIP2R, RCC_CDCCIP2R_USBSEL));
    #endif /* RCC_D2CCIP2R_USBSEL */
    }

    /**
      * @brief  Get CEC clock source
      * @rmtoll D2CCIP2R / CDCCIP2R        CECSEL        GetCECClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref CEC_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref CEC_CLKSOURCE_LSE
      *         @arg @ref CEC_CLKSOURCE_LSI
      *         @arg @ref CEC_CLKSOURCE_CSI_DIV122
      */
    RCCCECClkSource GetCECClockSource(RCCCECGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP2R_CECSEL)
      return (RCCCECClkSource)(READ_BIT(RCC->D2CCIP2R, RCC_D2CCIP2R_CECSEL));
    #else
      return (RCCCECClkSource)(READ_BIT(RCC->CDCCIP2R, RCC_CDCCIP2R_CECSEL));
    #endif  /* RCC_D2CCIP2R_CECSEL */
    }

    #if defined(DSI)
    /**
      * @brief  Get DSI clock source
      * @rmtoll D1CCIPR         DSISEL        GetDSIClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref DSI_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref DSI_CLKSOURCE_PHY
      *         @arg @ref DSI_CLKSOURCE_PLL2Q
      */
    uint32_t GetDSIClockSource(RCCDSIClkSource Periph)
    {
      UNUSED(Periph);
      return (uint32_t)(READ_BIT(RCC->D1CCIPR, RCC_D1CCIPR_DSISEL));
    }
    #endif /* DSI */

    /**
      * @brief  Get DFSDM Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R         DFSDM1SEL        GetDFSDMClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref DFSDM1_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref DFSDM1_CLKSOURCE_PCLK2
      *         @arg @ref DFSDM1_CLKSOURCE_SYSCLK
      */
    RCCDFSDM1ClkSource GetDFSDMClockSource(RCCDFSDM1GetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP1R_DFSDM1SEL)
      return (RCCDFSDM1ClkSource)(READ_BIT(RCC->D2CCIP1R, RCC_D2CCIP1R_DFSDM1SEL));
    #else
      return (RCCDFSDM1ClkSource)(READ_BIT(RCC->CDCCIP1R, RCC_CDCCIP1R_DFSDM1SEL));
    #endif /* RCC_D2CCIP1R_DFSDM1SEL */
    }

    #if defined(DFSDM2_BASE)
    /**
      * @brief  Get DFSDM2 Kernel clock source
      * @rmtoll SRDCCIPR         DFSDM2SEL        GetDFSDM2ClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref DFSDM2_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref DFSDM2_CLKSOURCE_PCLK4
      *         @arg @ref DFSDM2_CLKSOURCE_SYSCLK
      */
    RCCDFSDM2ClkSource GetDFSDM2ClockSource(RCCDFSDM2GetClkSource Periph)
    {
      UNUSED(Periph);
      return (RCCDFSDM1ClkSource)(READ_BIT(RCC->SRDCCIPR, RCC_SRDCCIPR_DFSDM2SEL));
    }
    #endif /* DFSDM2_BASE */

    /**
      * @brief  Get FMC Kernel clock source
      * @rmtoll D1CCIPR / D1CCIPR         FMCSEL        GetFMCClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref FMC_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref FMC_CLKSOURCE_HCLK
      *         @arg @ref FMC_CLKSOURCE_PLL1Q
      *         @arg @ref FMC_CLKSOURCE_PLL2R
      *         @arg @ref FMC_CLKSOURCE_CLKP
      */
    RCCFMCClkSource GetFMCClockSource(RCCFMCGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D1CCIPR_FMCSEL)
      return (RCCFMCClkSource)(READ_BIT(RCC->D1CCIPR, RCC_D1CCIPR_FMCSEL));
    #else
      return (RCCFMCClkSource)(READ_BIT(RCC->CDCCIPR, RCC_CDCCIPR_FMCSEL));
    #endif /* RCC_D1CCIPR_FMCSEL */
    }

    #if defined(QUADSPI)
    /**
      * @brief  Get QSPI Kernel clock source
      * @rmtoll D1CCIPR  /  CDCCIPR      QSPISEL        GetQSPIClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref QSPI_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref QSPI_CLKSOURCE_HCLK
      *         @arg @ref QSPI_CLKSOURCE_PLL1Q
      *         @arg @ref QSPI_CLKSOURCE_PLL2R
      *         @arg @ref QSPI_CLKSOURCE_CLKP
      */
    RCCQSPIClkSource GetQSPIClockSource(RCCQSPIGetClkSource Periph)
    {
      UNUSED(Periph);
      return (RCCQSPIClkSource)(READ_BIT(RCC->D1CCIPR, RCC_D1CCIPR_QSPISEL));
    }
    #endif /* QUADSPI */

    #if defined(OCTOSPI1) || defined(OCTOSPI2)
    /**
      * @brief  Get OSPI Kernel clock source
      * @rmtoll CDCCIPR      OSPISEL        GetOSPIClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref OSPI_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref OSPI_CLKSOURCE_HCLK
      *         @arg @ref OSPI_CLKSOURCE_PLL1Q
      *         @arg @ref OSPI_CLKSOURCE_PLL2R
      *         @arg @ref OSPI_CLKSOURCE_CLKP
      */
    RCCOSPIClkSource GetOSPIClockSource(RCCOSPIGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D1CCIPR_OCTOSPISEL)
      return (RCCOSPIClkSource)(READ_BIT(RCC->D1CCIPR, RCC_D1CCIPR_OCTOSPISEL));
    #else
      return (RCCOSPIClkSource)(READ_BIT(RCC->CDCCIPR, RCC_CDCCIPR_OCTOSPISEL));
    #endif /* RCC_D1CCIPR_OCTOSPISEL */
    }
    #endif /* defined(OCTOSPI1) || defined(OCTOSPI2) */

    /**
      * @brief  Get CLKP Kernel clock source
      * @rmtoll D1CCIPR /  CDCCIPR       CKPERSEL        GetCLKPClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref CLKP_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref CLKP_CLKSOURCE_HSI
      *         @arg @ref CLKP_CLKSOURCE_CSI
      *         @arg @ref CLKP_CLKSOURCE_HSE
      */
    RCCCLKPClkSource GetCLKPClockSource(RCCCLKPGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D1CCIPR_CKPERSEL)
      return (RCCCLKPClkSource)(READ_BIT(RCC->D1CCIPR, RCC_D1CCIPR_CKPERSEL));
    #else
      return (RCCCLKPClkSource)(READ_BIT(RCC->CDCCIPR, RCC_CDCCIPR_CKPERSEL));
    #endif /* RCC_D1CCIPR_CKPERSEL */
    }

    /**
      * @brief  Get SPIx Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R     SPI123SEL       GetSPIClockSource\n
      *         D2CCIP1R / CDCCIP1R     SPI45SEL        GetSPIClockSource\n
      *         D3CCIPR  / SRDCCIPR     SPI6SEL         GetSPIClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref SPI123_CLKSOURCE
      *         @arg @ref SPI45_CLKSOURCE
      *         @arg @ref SPI6_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref SPI123_CLKSOURCE_PLL1Q
      *         @arg @ref SPI123_CLKSOURCE_PLL2P
      *         @arg @ref SPI123_CLKSOURCE_PLL3P
      *         @arg @ref SPI123_CLKSOURCE_I2S_CKIN
      *         @arg @ref SPI123_CLKSOURCE_CLKP
      *         @arg @ref SPI45_CLKSOURCE_PCLK2
      *         @arg @ref SPI45_CLKSOURCE_PLL2Q
      *         @arg @ref SPI45_CLKSOURCE_PLL3Q
      *         @arg @ref SPI45_CLKSOURCE_HSI
      *         @arg @ref SPI45_CLKSOURCE_CSI
      *         @arg @ref SPI45_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_PCLK4
      *         @arg @ref SPI6_CLKSOURCE_PLL2Q
      *         @arg @ref SPI6_CLKSOURCE_PLL3Q
      *         @arg @ref SPI6_CLKSOURCE_HSI
      *         @arg @ref SPI6_CLKSOURCE_CSI
      *         @arg @ref SPI6_CLKSOURCE_HSE
      *         @arg @ref SPI6_CLKSOURCE_I2S_CKIN (*)
      *
      *         (*) value not defined in all stm32h7xx lines.
      */
    RCCSPIxClkSource GetSPIClockSource(RCCSPIxGetClkSource Periph)
    {
      return (RCCSPIxClkSource)GetClockSource(Periph);
    }

    /**
      * @brief  Get SPDIF Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R      SPDIFSEL        GetSPDIFClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref SPDIF_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref SPDIF_CLKSOURCE_PLL1Q
      *         @arg @ref SPDIF_CLKSOURCE_PLL2R
      *         @arg @ref SPDIF_CLKSOURCE_PLL3R
      *         @arg @ref SPDIF_CLKSOURCE_HSI
      */
    RCCSPDIFClkSource GetSPDIFClockSource(RCCSPDIFGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP1R_SPDIFSEL)
      return (RCCSPDIFClkSource)(READ_BIT(RCC->D2CCIP1R, RCC_D2CCIP1R_SPDIFSEL));
    #else
      return (RCCSPDIFClkSource)(READ_BIT(RCC->CDCCIP1R, RCC_CDCCIP1R_SPDIFSEL));
    #endif /* RCC_D2CCIP1R_SPDIFSEL */
    }

    /**
      * @brief  Get FDCAN Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R       FDCANSEL        GetFDCANClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref FDCAN_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref FDCAN_CLKSOURCE_HSE
      *         @arg @ref FDCAN_CLKSOURCE_PLL1Q
      *         @arg @ref FDCAN_CLKSOURCE_PLL2Q
      */
    RCCFDCANClkSource GetFDCANClockSource(RCCFDCANGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP1R_FDCANSEL)
      return (RCCFDCANClkSource)(READ_BIT(RCC->D2CCIP1R, RCC_D2CCIP1R_FDCANSEL));
    #else
      return (RCCFDCANClkSource)(READ_BIT(RCC->CDCCIP1R, RCC_CDCCIP1R_FDCANSEL));
    #endif /* RCC_D2CCIP1R_FDCANSEL */
    }

    /**
      * @brief  Get SWP Kernel clock source
      * @rmtoll D2CCIP1R / CDCCIP1R       SWPSEL        GetSWPClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref SWP_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref SWP_CLKSOURCE_PCLK1
      *         @arg @ref SWP_CLKSOURCE_HSI
      */
    RCCSWPClkSource GetSWPClockSource(RCCSWPGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined(RCC_D2CCIP1R_SWPSEL)
      return (RCCSWPClkSource)(READ_BIT(RCC->D2CCIP1R, RCC_D2CCIP1R_SWPSEL));
    #else
      return (RCCSWPClkSource)(READ_BIT(RCC->CDCCIP1R, RCC_CDCCIP1R_SWPSEL));
    #endif /* RCC_D2CCIP1R_SWPSEL */
    }

    /**
      * @brief  Get ADC Kernel clock source
      * @rmtoll D3CCIPR / SRDCCIPR       ADCSEL        GetADCClockSource
      * @param  Periph This parameter can be one of the following values:
      *         @arg @ref ADC_CLKSOURCE
      * @retval Returned value can be one of the following values:
      *         @arg @ref ADC_CLKSOURCE_PLL2P
      *         @arg @ref ADC_CLKSOURCE_PLL3R
      *         @arg @ref ADC_CLKSOURCE_CLKP
      */
    RCCADCClkSource GetADCClockSource(RCCADCGetClkSource Periph)
    {
      UNUSED(Periph);
    #if defined (RCC_D3CCIPR_ADCSEL)
      return (RCCADCClkSource)(READ_BIT(RCC->D3CCIPR, RCC_D3CCIPR_ADCSEL));
    #else
      return (RCCADCClkSource)(READ_BIT(RCC->SRDCCIPR, RCC_SRDCCIPR_ADCSEL));
    #endif /* RCC_D3CCIPR_ADCSEL */
    }

    /** @defgroup RCC_EF_RTC RTC
      * @{
      */

    /**
      * @brief  Set RTC Clock Source
      * @note   Once the RTC clock source has been selected, it cannot be changed anymore unless
      *         the Backup domain is reset, or unless a failure is detected on LSE (LSECSSD is
      *         set). The BDRST bit can be used to reset them.
      * @rmtoll BDCR         RTCSEL        SetRTCClockSource
      * @param  Source This parameter can be one of the following values:
      *         @arg @ref RTC_CLKSOURCE_NONE
      *         @arg @ref RTC_CLKSOURCE_LSE
      *         @arg @ref RTC_CLKSOURCE_LSI
      *         @arg @ref RTC_CLKSOURCE_HSE
      * @retval None
      */
    void SetRTCClockSource(RCCRTCClkSrc Source)
    {
      MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
    }

    /**
      * @brief  Get RTC Clock Source
      * @rmtoll BDCR         RTCSEL        GetRTCClockSource
      * @retval Returned value can be one of the following values:
      *         @arg @ref RTC_CLKSOURCE_NONE
      *         @arg @ref RTC_CLKSOURCE_LSE
      *         @arg @ref RTC_CLKSOURCE_LSI
      *         @arg @ref RTC_CLKSOURCE_HSE
      */
    RCCRTCClkSrc GetRTCClockSource(void)
    {
      return (RCCRTCClkSrc)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
    }

    /**
      * @brief  Enable RTC
      * @rmtoll BDCR         RTCEN         EnableRTC
      * @retval None
      */
    void EnableRTC(void)
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
    }

    /**
      * @brief  Disable RTC
      * @rmtoll BDCR         RTCEN         DisableRTC
      * @retval None
      */
    void DisableRTC(void)
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
    }

    /**
      * @brief  Check if RTC has been enabled or not
      * @rmtoll BDCR         RTCEN         IsEnabledRTC
      * @retval State of bit (1 or 0).
      */
    bool IsEnabledRTC(void)
    {
      return ((READ_BIT(RCC->BDCR, RCC_BDCR_RTCEN) == (RCC_BDCR_RTCEN)) ? true : false);
    }

    /**
      * @brief  Force the Backup domain reset
      * @rmtoll BDCR         BDRST / VSWRST         ForceBackupDomainReset
      * @retval None
      */
    void ForceBackupDomainReset(void)
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
    }

    /**
      * @brief  Release the Backup domain reset
      * @rmtoll BDCR         BDRST / VSWRST          ReleaseBackupDomainReset
      * @retval None
      */
    void ReleaseBackupDomainReset(void)
    {
    #if defined(RCC_BDCR_BDRST)
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
    #else
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_VSWRST);
    #endif /* RCC_BDCR_BDRST */
    }

    /**
      * @brief  Set HSE Prescalers for RTC Clock
      * @rmtoll CFGR         RTCPRE        SetRTCHSEPrescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref RTC_NOCLOCK
      *         @arg @ref RTC_HSE_DIV_2
      *         @arg @ref RTC_HSE_DIV_3
      *         @arg @ref RTC_HSE_DIV_4
      *         @arg @ref RTC_HSE_DIV_5
      *         @arg @ref RTC_HSE_DIV_6
      *         @arg @ref RTC_HSE_DIV_7
      *         @arg @ref RTC_HSE_DIV_8
      *         @arg @ref RTC_HSE_DIV_9
      *         @arg @ref RTC_HSE_DIV_10
      *         @arg @ref RTC_HSE_DIV_11
      *         @arg @ref RTC_HSE_DIV_12
      *         @arg @ref RTC_HSE_DIV_13
      *         @arg @ref RTC_HSE_DIV_14
      *         @arg @ref RTC_HSE_DIV_15
      *         @arg @ref RTC_HSE_DIV_16
      *         @arg @ref RTC_HSE_DIV_17
      *         @arg @ref RTC_HSE_DIV_18
      *         @arg @ref RTC_HSE_DIV_19
      *         @arg @ref RTC_HSE_DIV_20
      *         @arg @ref RTC_HSE_DIV_21
      *         @arg @ref RTC_HSE_DIV_22
      *         @arg @ref RTC_HSE_DIV_23
      *         @arg @ref RTC_HSE_DIV_24
      *         @arg @ref RTC_HSE_DIV_25
      *         @arg @ref RTC_HSE_DIV_26
      *         @arg @ref RTC_HSE_DIV_27
      *         @arg @ref RTC_HSE_DIV_28
      *         @arg @ref RTC_HSE_DIV_29
      *         @arg @ref RTC_HSE_DIV_30
      *         @arg @ref RTC_HSE_DIV_31
      *         @arg @ref RTC_HSE_DIV_32
      *         @arg @ref RTC_HSE_DIV_33
      *         @arg @ref RTC_HSE_DIV_34
      *         @arg @ref RTC_HSE_DIV_35
      *         @arg @ref RTC_HSE_DIV_36
      *         @arg @ref RTC_HSE_DIV_37
      *         @arg @ref RTC_HSE_DIV_38
      *         @arg @ref RTC_HSE_DIV_39
      *         @arg @ref RTC_HSE_DIV_40
      *         @arg @ref RTC_HSE_DIV_41
      *         @arg @ref RTC_HSE_DIV_42
      *         @arg @ref RTC_HSE_DIV_43
      *         @arg @ref RTC_HSE_DIV_44
      *         @arg @ref RTC_HSE_DIV_45
      *         @arg @ref RTC_HSE_DIV_46
      *         @arg @ref RTC_HSE_DIV_47
      *         @arg @ref RTC_HSE_DIV_48
      *         @arg @ref RTC_HSE_DIV_49
      *         @arg @ref RTC_HSE_DIV_50
      *         @arg @ref RTC_HSE_DIV_51
      *         @arg @ref RTC_HSE_DIV_52
      *         @arg @ref RTC_HSE_DIV_53
      *         @arg @ref RTC_HSE_DIV_54
      *         @arg @ref RTC_HSE_DIV_55
      *         @arg @ref RTC_HSE_DIV_56
      *         @arg @ref RTC_HSE_DIV_57
      *         @arg @ref RTC_HSE_DIV_58
      *         @arg @ref RTC_HSE_DIV_59
      *         @arg @ref RTC_HSE_DIV_60
      *         @arg @ref RTC_HSE_DIV_61
      *         @arg @ref RTC_HSE_DIV_62
      *         @arg @ref RTC_HSE_DIV_63
      * @retval None
      */
    void SetRTCHSEPrescaler(RCCRTCHSEPrescaler Prescaler)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, Prescaler);
    }

    /**
      * @brief  Get HSE Prescalers for RTC Clock
      * @rmtoll CFGR         RTCPRE        GetRTCHSEPrescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref RTC_NOCLOCK
      *         @arg @ref RTC_HSE_DIV_2
      *         @arg @ref RTC_HSE_DIV_3
      *         @arg @ref RTC_HSE_DIV_4
      *         @arg @ref RTC_HSE_DIV_5
      *         @arg @ref RTC_HSE_DIV_6
      *         @arg @ref RTC_HSE_DIV_7
      *         @arg @ref RTC_HSE_DIV_8
      *         @arg @ref RTC_HSE_DIV_9
      *         @arg @ref RTC_HSE_DIV_10
      *         @arg @ref RTC_HSE_DIV_11
      *         @arg @ref RTC_HSE_DIV_12
      *         @arg @ref RTC_HSE_DIV_13
      *         @arg @ref RTC_HSE_DIV_14
      *         @arg @ref RTC_HSE_DIV_15
      *         @arg @ref RTC_HSE_DIV_16
      *         @arg @ref RTC_HSE_DIV_17
      *         @arg @ref RTC_HSE_DIV_18
      *         @arg @ref RTC_HSE_DIV_19
      *         @arg @ref RTC_HSE_DIV_20
      *         @arg @ref RTC_HSE_DIV_21
      *         @arg @ref RTC_HSE_DIV_22
      *         @arg @ref RTC_HSE_DIV_23
      *         @arg @ref RTC_HSE_DIV_24
      *         @arg @ref RTC_HSE_DIV_25
      *         @arg @ref RTC_HSE_DIV_26
      *         @arg @ref RTC_HSE_DIV_27
      *         @arg @ref RTC_HSE_DIV_28
      *         @arg @ref RTC_HSE_DIV_29
      *         @arg @ref RTC_HSE_DIV_30
      *         @arg @ref RTC_HSE_DIV_31
      *         @arg @ref RTC_HSE_DIV_32
      *         @arg @ref RTC_HSE_DIV_33
      *         @arg @ref RTC_HSE_DIV_34
      *         @arg @ref RTC_HSE_DIV_35
      *         @arg @ref RTC_HSE_DIV_36
      *         @arg @ref RTC_HSE_DIV_37
      *         @arg @ref RTC_HSE_DIV_38
      *         @arg @ref RTC_HSE_DIV_39
      *         @arg @ref RTC_HSE_DIV_40
      *         @arg @ref RTC_HSE_DIV_41
      *         @arg @ref RTC_HSE_DIV_42
      *         @arg @ref RTC_HSE_DIV_43
      *         @arg @ref RTC_HSE_DIV_44
      *         @arg @ref RTC_HSE_DIV_45
      *         @arg @ref RTC_HSE_DIV_46
      *         @arg @ref RTC_HSE_DIV_47
      *         @arg @ref RTC_HSE_DIV_48
      *         @arg @ref RTC_HSE_DIV_49
      *         @arg @ref RTC_HSE_DIV_50
      *         @arg @ref RTC_HSE_DIV_51
      *         @arg @ref RTC_HSE_DIV_52
      *         @arg @ref RTC_HSE_DIV_53
      *         @arg @ref RTC_HSE_DIV_54
      *         @arg @ref RTC_HSE_DIV_55
      *         @arg @ref RTC_HSE_DIV_56
      *         @arg @ref RTC_HSE_DIV_57
      *         @arg @ref RTC_HSE_DIV_58
      *         @arg @ref RTC_HSE_DIV_59
      *         @arg @ref RTC_HSE_DIV_60
      *         @arg @ref RTC_HSE_DIV_61
      *         @arg @ref RTC_HSE_DIV_62
      *         @arg @ref RTC_HSE_DIV_63
      */
    RCCRTCHSEPrescaler GetRTCHSEPrescaler(void)
    {
      return (RCCRTCHSEPrescaler)(READ_BIT(RCC->CFGR, RCC_CFGR_RTCPRE));
    }
    /** @defgroup RCC_EF_TIM_CLOCK_PRESCALER TIM
      * @{
      */

    /**
      * @brief  Set Timers Clock Prescalers
      * @rmtoll CFGR         TIMPRE        SetTIMPrescaler
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref TIM_PRESCALER_TWICE
      *         @arg @ref TIM_PRESCALER_FOUR_TIMES
      * @retval None
      */
    void SetTIMPrescaler(RCCTIMClkPrescaler Prescaler)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_TIMPRE, Prescaler);
    }

    /**
      * @brief  Get Timers Clock Prescalers
      * @rmtoll CFGR         TIMPRE        GetTIMPrescaler
      * @retval Returned value can be one of the following values:
      *         @arg @ref TIM_PRESCALER_TWICE
      *         @arg @ref TIM_PRESCALER_FOUR_TIMES
      */
    RCCTIMClkPrescaler GetTIMPrescaler(void)
    {
      return (RCCTIMClkPrescaler)(READ_BIT(RCC->CFGR, RCC_CFGR_TIMPRE));
    }

    #if defined(HRTIM1)
    /** @defgroup RCC_LL_EF_HRTIM_SET_CLOCK_SOURCE HRTIM
      * @{
      */

    /**
      * @brief  Set High Resolution Timers Clock Source
      * @rmtoll CFGR         HRTIMSEL        SetHRTIMClockSource
      * @param  Prescaler This parameter can be one of the following values:
      *         @arg @ref HRTIM_CLKSOURCE_TIM
      *         @arg @ref HRTIM_CLKSOURCE_CPU
      * @retval None
      */
    void SetHRTIMClockSource(RCCHRTIMClkSource Prescaler)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HRTIMSEL, Prescaler);
    }
    #endif /* HRTIM1 */

    #if defined(HRTIM1)
    /**
      * @brief  Get High Resolution Timers Clock Source
      * @rmtoll CFGR         HRTIMSEL        GetHRTIMClockSource
      * @retval Returned value can be one of the following values:
      *         @arg @ref HRTIM_CLKSOURCE_TIM
      *         @arg @ref HRTIM_CLKSOURCE_CPU
      */
    RCCHRTIMClkSource GetHRTIMClockSource(void)
    {
      return (RCCHRTIMClkSource)(READ_BIT(RCC->CFGR, RCC_CFGR_HRTIMSEL));
    }
    #endif /* HRTIM1 */

    /** @defgroup RCC_EF_PLL PLL
      * @{
      */

    /**
      * @brief  Set the oscillator used as PLL clock source.
      * @note   PLLSRC can be written only when All PLLs are disabled.
      * @rmtoll PLLCKSELR      PLLSRC        PLLSetSource
      * @param  PLLSource parameter can be one of the following values:
      *         @arg @ref PLLSOURCE_HSI
      *         @arg @ref PLLSOURCE_CSI
      *         @arg @ref PLLSOURCE_HSE
      *         @arg @ref PLLSOURCE_NONE
      * @retval None
      */
    void PLLSetSource(RCCPLLClkSource PLLSource)
    {
      MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC, PLLSource);
    }

    /**
      * @brief  Get the oscillator used as PLL clock source.
      * @rmtoll PLLCKSELR      PLLSRC        PLL_GetSource
      * @retval Returned value can be one of the following values:
      *         @arg @ref PLLSOURCE_HSI
      *         @arg @ref PLLSOURCE_CSI
      *         @arg @ref PLLSOURCE_HSE
      *         @arg @ref PLLSOURCE_NONE
      */
    RCCPLLClkSource PLLGetSource(void)
    {
      return (RCCPLLClkSource)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
    }

    /**
      * @brief  Enable PLL1
      * @rmtoll CR           PLL1ON         PLL1_Enable
      * @retval None
      */
    void PLL1Enable(void)
    {
      SET_BIT(RCC->CR, RCC_CR_PLL1ON);
    }

    /**
      * @brief  Disable PLL1
      * @note Cannot be disabled if the PLL1 clock is used as the system clock
      * @rmtoll CR           PLL1ON         PLL1_Disable
      * @retval None
      */
    void PLL1Disable(void)
    {
      CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
    }

    /**
      * @brief  Check if PLL1 Ready
      * @rmtoll CR           PLL1RDY        PLL1_IsReady
      * @retval State of bit (1 or 0).
      */
    bool PLL1IsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == (RCC_CR_PLL1RDY)) ? true : false);
    }

    /**
      * @brief  Enable PLL1P
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR           DIVP1EN         PLL1P_Enable
      * @retval None
      */
    void PLL1PEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN);
    }

    /**
      * @brief  Enable PLL1Q
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR           DIVQ1EN         PLL1Q_Enable
      * @retval None
      */
    void PLL1QEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN);
    }

    /**
      * @brief  Enable PLL1R
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR           DIVR1EN         PLL1R_Enable
      * @retval None
      */
    void PLL1REnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN);
    }

    /**
      * @brief  Enable PLL1 FRACN
      * @rmtoll PLLCFGR           PLL1FRACEN         PLL1FRACN_Enable
      * @retval None
      */
    void PLL1FRACNEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN);
    }

    /**
      * @brief  Check if PLL1 P is enabled
      * @rmtoll PLLCFGR           DIVP1EN         PLL1P_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL1PIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN) == RCC_PLLCFGR_DIVP1EN) ? true : false);
    }

    /**
      * @brief  Check if PLL1 Q is enabled
      * @rmtoll PLLCFGR           DIVQ1EN         PLL1Q_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL1QIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN) == RCC_PLLCFGR_DIVQ1EN) ? true : false);
    }

    /**
      * @brief  Check if PLL1 R is enabled
      * @rmtoll PLLCFGR           DIVR1EN         PLL1R_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL1RIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN) == RCC_PLLCFGR_DIVR1EN) ? true : false);
    }

    /**
      * @brief  Check if PLL1 FRACN is enabled
      * @rmtoll PLLCFGR           PLL1FRACEN         PLL1FRACN_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL1FRACNIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN) == RCC_PLLCFGR_PLL1FRACEN) ? true : false);
    }

    /**
      * @brief  Disable PLL1P
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR           DIVP1EN         PLL1P_Disable
      * @retval None
      */
    void PLL1PDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN);
    }

    /**
      * @brief  Disable PLL1Q
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR           DIVQ1EN         PLL1Q_Disable
      * @retval None
      */
    void PLL1QDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN);
    }

    /**
      * @brief  Disable PLL1R
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR           DIVR1EN         PLL1R_Disable
      * @retval None
      */
    void PLL1RDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN);
    }

    /**
      * @brief  Disable PLL1 FRACN
      * @rmtoll PLLCFGR           PLL1FRACEN         PLL1FRACN_Enable
      * @retval None
      */
    void PLL1FRACNDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN);
    }

    /**
      * @brief  Set PLL1 VCO OutputRange
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR        PLL1VCOSEL       PLL1_SetVCOOuputRange
      * @param  VCORange This parameter can be one of the following values:
      *         @arg @ref PLLVCORANGE_WIDE
      *         @arg @ref PLLVCORANGE_MEDIUM
      * @retval None
      */
    void PLL1SetVCOOutputRange(RCCPLLVocRange VCORange)
    {
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1VCOSEL, VCORange << RCC_PLLCFGR_PLL1VCOSEL_Pos);
    }

    /**
      * @brief  Set PLL1 VCO Input Range
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCFGR        PLL1RGE       PLL1_SetVCOInputRange
      * @param  InputRange This parameter can be one of the following values:
      *         @arg @ref PLLINPUTRANGE_1_2
      *         @arg @ref PLLINPUTRANGE_2_4
      *         @arg @ref PLLINPUTRANGE_4_8
      *         @arg @ref PLLINPUTRANGE_8_16
      * @retval None
      */
    void PLL1SetVCOInputRange(RCCPLLInputRange InputRange)
    {
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1RGE, InputRange << RCC_PLLCFGR_PLL1RGE_Pos);
    }

    /**
      * @brief  Get PLL1 N Coefficient
      * @rmtoll PLL1DIVR        N1          PLL1_GetN
      * @retval A value between 4 and 512
      */
    uint32_t PLL1GetN(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_N1) >>  RCC_PLL1DIVR_N1_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL1 M Coefficient
      * @rmtoll PLLCKSELR       DIVM1          PLL1_GetM
      * @retval A value between 0 and 63
      */
    uint32_t PLL1GetM(void)
    {
      return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1) >>  RCC_PLLCKSELR_DIVM1_Pos);
    }

    /**
      * @brief  Get PLL1 P Coefficient
      * @rmtoll PLL1DIVR        P1          PLL1_GetP
      * @retval A value between 2 and 128
      */
    uint32_t PLL1GetP(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_P1) >>  RCC_PLL1DIVR_P1_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL1 Q Coefficient
      * @rmtoll PLL1DIVR        Q1          PLL1_GetQ
      * @retval A value between 1 and 128
      */
    uint32_t PLL1GetQ(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1) >>  RCC_PLL1DIVR_Q1_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL1 R Coefficient
      * @rmtoll PLL1DIVR        R1          PLL1_GetR
      * @retval A value between 1 and 128
      */
    uint32_t PLL1GetR(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_R1) >>  RCC_PLL1DIVR_R1_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL1 FRACN Coefficient
      * @rmtoll PLL1FRACR      FRACN1          PLL1_GetFRACN
      * @retval A value between 0 and 8191 (0x1FFF)
      */
    uint32_t PLL1GetFRACN(void)
    {
      return (uint32_t)(READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_FRACN1) >>  RCC_PLL1FRACR_FRACN1_Pos);
    }

    /**
      * @brief  Set PLL1 N Coefficient
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLL1DIVR        N1          PLL1_SetN
      * @param  N parameter can be a value between 4 and 512
      */
    void PLL1SetN(uint32_t N)
    {
      MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_N1, (N - 1UL) << RCC_PLL1DIVR_N1_Pos);
    }

    /**
      * @brief  Set PLL1 M Coefficient
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLLCKSELR       DIVM1          PLL1_SetM
      * @param  M parameter can be a value between 0 and 63
      */
    void PLL1SetM(uint32_t M)
    {
      MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1, M << RCC_PLLCKSELR_DIVM1_Pos);
    }

    /**
      * @brief  Set PLL1 P Coefficient
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLL1DIVR        P1          PLL1_SetP
      * @param  P parameter can be a value between 2 (or 1*) and 128 (ODD division factor not supported)
      *
      * (*) : For stm32h72xxx and stm32h73xxx family lines.
      */
    void PLL1SetP(uint32_t P)
    {
      MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_P1, (P - 1UL) << RCC_PLL1DIVR_P1_Pos);
    }

    /**
      * @brief  Set PLL1 Q Coefficient
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLL1DIVR        Q1          PLL1_SetQ
      * @param  Q parameter can be a value between 1 and 128
      */
    void PLL1SetQ(uint32_t Q)
    {
      MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1, (Q - 1UL) << RCC_PLL1DIVR_Q1_Pos);
    }

    /**
      * @brief  Set PLL1 R Coefficient
      * @note   This API shall be called only when PLL1 is disabled.
      * @rmtoll PLL1DIVR        R1          PLL1_SetR
      * @param  R parameter can be a value between 1 and 128
      */
    void PLL1SetR(uint32_t R)
    {
      MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_R1, (R - 1UL) << RCC_PLL1DIVR_R1_Pos);
    }

    /**
      * @brief  Set PLL1 FRACN Coefficient
      * @rmtoll PLL1FRACR        FRACN1          PLL1_SetFRACN
      * @param  FRACN parameter can be a value between 0 and 8191 (0x1FFF)
      */
    void PLL1SetFRACN(uint32_t FRACN)
    {
      MODIFY_REG(RCC->PLL1FRACR, RCC_PLL1FRACR_FRACN1, FRACN << RCC_PLL1FRACR_FRACN1_Pos);
    }

    /**
      * @brief  Enable PLL2
      * @rmtoll CR           PLL2ON         PLL2_Enable
      * @retval None
      */
    void PLL2Enable(void)
    {
      SET_BIT(RCC->CR, RCC_CR_PLL2ON);
    }

    /**
      * @brief  Disable PLL2
      * @note Cannot be disabled if the PLL2 clock is used as the system clock
      * @rmtoll CR           PLL2ON         PLL2_Disable
      * @retval None
      */
    void PLL2Disable(void)
    {
      CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
    }

    /**
      * @brief  Check if PLL2 Ready
      * @rmtoll CR           PLL2RDY        PLL2_IsReady
      * @retval State of bit (1 or 0).
      */
    bool PLL2IsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_PLL2RDY) == (RCC_CR_PLL2RDY)) ? true : false);
    }

    /**
      * @brief  Enable PLL2P
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR           DIVP2EN         PLL2P_Enable
      * @retval None
      */
    void PLL2PEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN);
    }

    /**
      * @brief  Enable PLL2Q
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR           DIVQ2EN         PLL2Q_Enable
      * @retval None
      */
    void PLL2QEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN);
    }

    /**
      * @brief  Enable PLL2R
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR           DIVR2EN         PLL2R_Enable
      * @retval None
      */
    void PLL2REnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN);
    }

    /**
      * @brief  Enable PLL2 FRACN
      * @rmtoll PLLCFGR           PLL2FRACEN         PLL2FRACN_Enable
      * @retval None
      */
    void PLL2FRACNEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN);
    }

    /**
      * @brief  Check if PLL2 P is enabled
      * @rmtoll PLLCFGR           DIVP2EN         PLL2P_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL2PIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN) == RCC_PLLCFGR_DIVP2EN) ? true : false);
    }

    /**
      * @brief  Check if PLL2 Q is enabled
      * @rmtoll PLLCFGR           DIVQ2EN         PLL2Q_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL2QIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN) == RCC_PLLCFGR_DIVQ2EN) ? true : false);
    }

    /**
      * @brief  Check if PLL2 R is enabled
      * @rmtoll PLLCFGR           DIVR2EN         PLL2R_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL2RIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN) == RCC_PLLCFGR_DIVR2EN) ? true : false);
    }

    /**
      * @brief  Check if PLL2 FRACN is enabled
      * @rmtoll PLLCFGR           PLL2FRACEN         PLL2FRACN_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL2FRACNIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN) == RCC_PLLCFGR_PLL2FRACEN) ? true : false);
    }

    /**
      * @brief  Disable PLL2P
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR           DIVP2EN         PLL2P_Disable
      * @retval None
      */
    void PLL2PDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN);
    }

    /**
      * @brief  Disable PLL2Q
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR           DIVQ2EN         PLL2Q_Disable
      * @retval None
      */
    void PLL2QDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN);
    }

    /**
      * @brief  Disable PLL2R
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR           DIVR2EN         PLL2R_Disable
      * @retval None
      */
    void PLL2RDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN);
    }

    /**
      * @brief  Disable PLL2 FRACN
      * @rmtoll PLLCFGR           PLL2FRACEN         PLL2FRACN_Enable
      * @retval None
      */
    void PLL2FRACNDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN);
    }

    /**
      * @brief  Set PLL2 VCO OutputRange
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR        PLL2VCOSEL       PLL2_SetVCOOuputRange
      * @param  VCORange This parameter can be one of the following values:
      *         @arg @ref PLLVCORANGE_WIDE
      *         @arg @ref PLLVCORANGE_MEDIUM
      * @retval None
      */
    void PLL2SetVCOOutputRange(RCCPLLVocRange VCORange)
    {
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL2VCOSEL, VCORange << RCC_PLLCFGR_PLL2VCOSEL_Pos);
    }

    /**
      * @brief  Set PLL2 VCO Input Range
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCFGR        PLL2RGE       PLL2_SetVCOInputRange
      * @param  InputRange This parameter can be one of the following values:
      *         @arg @ref PLLINPUTRANGE_1_2
      *         @arg @ref PLLINPUTRANGE_2_4
      *         @arg @ref PLLINPUTRANGE_4_8
      *         @arg @ref PLLINPUTRANGE_8_16
      * @retval None
      */
    void PLL2SetVCOInputRange(RCCPLLInputRange InputRange)
    {
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL2RGE, InputRange << RCC_PLLCFGR_PLL2RGE_Pos);
    }

    /**
      * @brief  Get PLL2 N Coefficient
      * @rmtoll PLL2DIVR        N2          PLL2_GetN
      * @retval A value between 4 and 512
      */
    uint32_t PLL2GetN(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_N2) >>  RCC_PLL2DIVR_N2_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL2 M Coefficient
      * @rmtoll PLLCKSELR       DIVM2          PLL2_GetM
      * @retval A value between 0 and 63
      */
    uint32_t PLL2GetM(void)
    {
      return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2) >>  RCC_PLLCKSELR_DIVM2_Pos);
    }

    /**
      * @brief  Get PLL2 P Coefficient
      * @rmtoll PLL2DIVR        P2          PLL2_GetP
      * @retval A value between 1 and 128
      */
    uint32_t PLL2GetP(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_P2) >>  RCC_PLL2DIVR_P2_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL2 Q Coefficient
      * @rmtoll PLL2DIVR        Q2          PLL2_GetQ
      * @retval A value between 1 and 128
      */
    uint32_t PLL2GetQ(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_Q2) >>  RCC_PLL2DIVR_Q2_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL2 R Coefficient
      * @rmtoll PLL2DIVR        R2          PLL2_GetR
      * @retval A value between 1 and 128
      */
    uint32_t PLL2GetR(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_R2) >>  RCC_PLL2DIVR_R2_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL2 FRACN Coefficient
      * @rmtoll PLL2FRACR      FRACN2          PLL2_GetFRACN
      * @retval A value between 0 and 8191 (0x1FFF)
      */
    uint32_t PLL2GetFRACN(void)
    {
      return (uint32_t)(READ_BIT(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2) >>  RCC_PLL2FRACR_FRACN2_Pos);
    }

    /**
      * @brief  Set PLL2 N Coefficient
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLL2DIVR        N2          PLL2_SetN
      * @param  N parameter can be a value between 4 and 512
      */
    void PLL2SetN(uint32_t N)
    {
      MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_N2, (N - 1UL) << RCC_PLL2DIVR_N2_Pos);
    }

    /**
      * @brief  Set PLL2 M Coefficient
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLLCKSELR       DIVM2          PLL2_SetM
      * @param  M parameter can be a value between 0 and 63
      */
    void PLL2SetM(uint32_t M)
    {
      MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2, M << RCC_PLLCKSELR_DIVM2_Pos);
    }

    /**
      * @brief  Set PLL2 P Coefficient
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLL2DIVR        P2          PLL2_SetP
      * @param  P parameter can be a value between 1 and 128
      */
    void PLL2SetP(uint32_t P)
    {
      MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_P2, (P - 1UL) << RCC_PLL2DIVR_P2_Pos);
    }

    /**
      * @brief  Set PLL2 Q Coefficient
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLL2DIVR        Q2          PLL2_SetQ
      * @param  Q parameter can be a value between 1 and 128
      */
    void PLL2SetQ(uint32_t Q)
    {
      MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_Q2, (Q - 1UL) << RCC_PLL2DIVR_Q2_Pos);
    }

    /**
      * @brief  Set PLL2 R Coefficient
      * @note   This API shall be called only when PLL2 is disabled.
      * @rmtoll PLL2DIVR        R2          PLL2_SetR
      * @param  R parameter can be a value between 1 and 128
      */
    void PLL2SetR(uint32_t R)
    {
      MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_R2, (R - 1UL) << RCC_PLL2DIVR_R2_Pos);
    }

    /**
      * @brief  Set PLL2 FRACN Coefficient
      * @rmtoll PLL2FRACR        FRACN2          PLL2_SetFRACN
      * @param  FRACN parameter can be a value between 0 and 8191 (0x1FFF)
      */
    void PLL2SetFRACN(uint32_t FRACN)
    {
      MODIFY_REG(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2, FRACN << RCC_PLL2FRACR_FRACN2_Pos);
    }

    /**
      * @brief  Enable PLL3
      * @rmtoll CR           PLL3ON         PLL3_Enable
      * @retval None
      */
    void PLL3Enable(void)
    {
      SET_BIT(RCC->CR, RCC_CR_PLL3ON);
    }

    /**
      * @brief  Disable PLL3
      * @note Cannot be disabled if the PLL3 clock is used as the system clock
      * @rmtoll CR           PLL3ON         PLL3_Disable
      * @retval None
      */
    void PLL3Disable(void)
    {
      CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
    }

    /**
      * @brief  Check if PLL3 Ready
      * @rmtoll CR           PLL3RDY        PLL3_IsReady
      * @retval State of bit (1 or 0).
      */
    bool PLL3IsReady(void)
    {
      return ((READ_BIT(RCC->CR, RCC_CR_PLL3RDY) == (RCC_CR_PLL3RDY)) ? true : false);
    }

    /**
      * @brief  Enable PLL3P
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR           DIVP3EN         PLL3P_Enable
      * @retval None
      */
    void PLL3PEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN);
    }

    /**
      * @brief  Enable PLL3Q
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR           DIVQ3EN         PLL3Q_Enable
      * @retval None
      */
    void PLL3QEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ3EN);
    }

    /**
      * @brief  Enable PLL3R
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR           DIVR3EN         PLL3R_Enable
      * @retval None
      */
    void PLL3REnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR3EN);
    }

    /**
      * @brief  Enable PLL3 FRACN
      * @rmtoll PLLCFGR           PLL3FRACEN         PLL3FRACN_Enable
      * @retval None
      */
    void PLL3FRACNEnable(void)
    {
      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN);
    }

    /**
      * @brief  Check if PLL3 P is enabled
      * @rmtoll PLLCFGR           DIVP3EN         PLL3P_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL3PIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN) == RCC_PLLCFGR_DIVP3EN) ? true : false);
    }

    /**
      * @brief  Check if PLL3 Q is enabled
      * @rmtoll PLLCFGR           DIVQ3EN         PLL3Q_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL3QIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ3EN) == RCC_PLLCFGR_DIVQ3EN) ? true : false);
    }

    /**
      * @brief  Check if PLL3 R is enabled
      * @rmtoll PLLCFGR           DIVR3EN         PLL3R_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL3RIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR3EN) == RCC_PLLCFGR_DIVR3EN) ? true : false);
    }

    /**
      * @brief  Check if PLL3 FRACN is enabled
      * @rmtoll PLLCFGR           PLL3FRACEN         PLL3FRACN_IsEnabled
      * @retval State of bit (1 or 0).
      */
    bool PLL3FRACNIsEnabled(void)
    {
      return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN) == RCC_PLLCFGR_PLL3FRACEN) ? true : false);
    }

    /**
      * @brief  Disable PLL3P
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR           DIVP2EN         PLL3P_Disable
      * @retval None
      */
    void PLL3PDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN);
    }

    /**
      * @brief  Disable PLL3Q
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR           DIVQ3EN         PLL3Q_Disable
      * @retval None
      */
    void PLL3QDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ3EN);
    }

    /**
      * @brief  Disable PLL3R
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR           DIVR3EN         PLL3R_Disable
      * @retval None
      */
    void PLL3RDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR3EN);
    }

    /**
      * @brief  Disable PLL3 FRACN
      * @rmtoll PLLCFGR           PLL3FRACEN         PLL3FRACN_Enable
      * @retval None
      */
    void PLL3FRACNDisable(void)
    {
      CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN);
    }

    /**
      * @brief  Set PLL3 VCO OutputRange
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR        PLL3VCOSEL       PLL3_SetVCOOuputRange
      * @param  VCORange This parameter can be one of the following values:
      *         @arg @ref PLLVCORANGE_WIDE
      *         @arg @ref PLLVCORANGE_MEDIUM
      * @retval None
      */
    void PLL3SetVCOOutputRange(RCCPLLVocRange VCORange)
    {
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL3VCOSEL, VCORange << RCC_PLLCFGR_PLL3VCOSEL_Pos);
    }

    /**
      * @brief  Set PLL3 VCO Input Range
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCFGR        PLL3RGE       PLL3_SetVCOInputRange
      * @param  InputRange This parameter can be one of the following values:
      *         @arg @ref PLLINPUTRANGE_1_2
      *         @arg @ref PLLINPUTRANGE_2_4
      *         @arg @ref PLLINPUTRANGE_4_8
      *         @arg @ref PLLINPUTRANGE_8_16
      * @retval None
      */
    void PLL3SetVCOInputRange(RCCPLLInputRange InputRange)
    {
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL3RGE, InputRange << RCC_PLLCFGR_PLL3RGE_Pos);
    }

    /**
      * @brief  Get PLL3 N Coefficient
      * @rmtoll PLL3DIVR        N3          PLL3_GetN
      * @retval A value between 4 and 512
      */
    uint32_t PLL3GetN(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL3 M Coefficient
      * @rmtoll PLLCKSELR       DIVM3          PLL3_GetM
      * @retval A value between 0 and 63
      */
    uint32_t PLL3GetM(void)
    {
      return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3) >>  RCC_PLLCKSELR_DIVM3_Pos);
    }

    /**
      * @brief  Get PLL3 P Coefficient
      * @rmtoll PLL3DIVR        P3          PLL3_GetP
      * @retval A value between 1 and 128
      */
    uint32_t PLL3GetP(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_P3) >>  RCC_PLL3DIVR_P3_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL3 Q Coefficient
      * @rmtoll PLL3DIVR        Q3          PLL3_GetQ
      * @retval A value between 1 and 128
      */
    uint32_t PLL3GetQ(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_Q3) >>  RCC_PLL3DIVR_Q3_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL3 R Coefficient
      * @rmtoll PLL3DIVR        R3          PLL3_GetR
      * @retval A value between 1 and 128
      */
    uint32_t PLL3GetR(void)
    {
      return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_R3) >>  RCC_PLL3DIVR_R3_Pos) + 1UL);
    }

    /**
      * @brief  Get PLL3 FRACN Coefficient
      * @rmtoll PLL3FRACR      FRACN3          PLL3_GetFRACN
      * @retval A value between 0 and 8191 (0x1FFF)
      */
    uint32_t PLL3GetFRACN(void)
    {
      return (uint32_t)(READ_BIT(RCC->PLL3FRACR, RCC_PLL3FRACR_FRACN3) >>  RCC_PLL3FRACR_FRACN3_Pos);
    }

    /**
      * @brief  Set PLL3 N Coefficient
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLL3DIVR        N3          PLL3_SetN
      * @param  N parameter can be a value between 4 and 512
      */
    void PLL3SetN(uint32_t N)
    {
      MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_N3, (N - 1UL) << RCC_PLL3DIVR_N3_Pos);
    }

    /**
      * @brief  Set PLL3 M Coefficient
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLLCKSELR       DIVM3          PLL3_SetM
      * @param  M parameter can be a value between 0 and 63
      */
    void PLL3SetM(uint32_t M)
    {
      MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3, M << RCC_PLLCKSELR_DIVM3_Pos);
    }

    /**
      * @brief  Set PLL3 P Coefficient
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLL3DIVR        P3          PLL3_SetP
      * @param  P parameter can be a value between 1 and 128
      */
    void PLL3SetP(uint32_t P)
    {
      MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_P3, (P - 1UL) << RCC_PLL3DIVR_P3_Pos);
    }

    /**
      * @brief  Set PLL3 Q Coefficient
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLL3DIVR        Q3          PLL3_SetQ
      * @param  Q parameter can be a value between 1 and 128
      */
    void PLL3SetQ(uint32_t Q)
    {
      MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_Q3, (Q - 1UL) << RCC_PLL3DIVR_Q3_Pos);
    }

    /**
      * @brief  Set PLL3 R Coefficient
      * @note   This API shall be called only when PLL3 is disabled.
      * @rmtoll PLL3DIVR        R3          PLL3_SetR
      * @param  R parameter can be a value between 1 and 128
      */
    void PLL3SetR(uint32_t R)
    {
      MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_R3, (R - 1UL) << RCC_PLL3DIVR_R3_Pos);
    }

    /**
      * @brief  Set PLL3 FRACN Coefficient
      * @rmtoll PLL3FRACR        FRACN3          PLL3_SetFRACN
      * @param  FRACN parameter can be a value between 0 and 8191 (0x1FFF)
      */
    void PLL3SetFRACN(uint32_t FRACN)
    {
      MODIFY_REG(RCC->PLL3FRACR, RCC_PLL3FRACR_FRACN3, FRACN << RCC_PLL3FRACR_FRACN3_Pos);
    }
    /** @defgroup RCC_EF_FLAG_Management FLAG Management
      * @{
      */

    /**
      * @brief  Clear LSI ready interrupt flag
      * @rmtoll CICR         LSIRDYC       ClearFlag_LSIRDY
      * @retval None
      */
    void ClearFlagLSIRDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_LSIRDYC);
    }

    /**
      * @brief  Clear LSE ready interrupt flag
      * @rmtoll CICR         LSERDYC       ClearFlag_LSERDY
      * @retval None
      */
    void ClearFlagLSERDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_LSERDYC);
    }

    /**
      * @brief  Clear HSI ready interrupt flag
      * @rmtoll CICR         HSIRDYC       ClearFlag_HSIRDY
      * @retval None
      */
    void ClearFlagHSIRDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_HSIRDYC);
    }

    /**
      * @brief  Clear HSE ready interrupt flag
      * @rmtoll CICR         HSERDYC       ClearFlag_HSERDY
      * @retval None
      */
    void ClearFlagHSERDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_HSERDYC);
    }

    /**
      * @brief  Clear CSI ready interrupt flag
      * @rmtoll CICR         CSIRDYC       ClearFlag_CSIRDY
      * @retval None
      */
    void ClearFlagCSIRDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_CSIRDYC);
    }

    /**
      * @brief  Clear HSI48 ready interrupt flag
      * @rmtoll CICR         HSI48RDYC       ClearFlag_HSI48RDY
      * @retval None
      */
    void ClearFlagHSI48RDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_HSI48RDYC);
    }

    /**
      * @brief  Clear PLL1 ready interrupt flag
      * @rmtoll CICR         PLL1RDYC       ClearFlag_PLL1RDY
      * @retval None
      */
    void ClearFlagPLL1RDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_PLLRDYC);
    }

    /**
      * @brief  Clear PLL2 ready interrupt flag
      * @rmtoll CICR         PLL2RDYC       ClearFlag_PLL2RDY
      * @retval None
      */
    void ClearFlagPLL2RDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_PLL2RDYC);
    }

    /**
      * @brief  Clear PLL3 ready interrupt flag
      * @rmtoll CICR         PLL3RDYC       ClearFlag_PLL3RDY
      * @retval None
      */
    void ClearFlagPLL3RDY(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_PLL3RDYC);
    }

    /**
      * @brief  Clear LSE Clock security system interrupt flag
      * @rmtoll CICR         LSECSSC         ClearFlag_LSECSS
      * @retval None
      */
    void ClearFlagLSECSS(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_LSECSSC);
    }

    /**
      * @brief  Clear HSE Clock security system interrupt flag
      * @rmtoll CICR         HSECSSC         ClearFlag_HSECSS
      * @retval None
      */
    void ClearFlagHSECSS(void)
    {
      SET_BIT(RCC->CICR, RCC_CICR_HSECSSC);
    }

    /**
      * @brief  Check if LSI ready interrupt occurred or not
      * @rmtoll CIFR         LSIRDYF       IsActiveFlag_LSIRDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagLSIRDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_LSIRDYF) == (RCC_CIFR_LSIRDYF)) ? true : false);
    }

    /**
      * @brief  Check if LSE ready interrupt occurred or not
      * @rmtoll CIFR         LSERDYF       IsActiveFlag_LSERDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagLSERDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_LSERDYF) == (RCC_CIFR_LSERDYF)) ? true : false);
    }

    /**
      * @brief  Check if HSI ready interrupt occurred or not
      * @rmtoll CIFR         HSIRDYF       IsActiveFlag_HSIRDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagHSIRDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_HSIRDYF) == (RCC_CIFR_HSIRDYF)) ? true : false);
    }

    /**
      * @brief  Check if HSE ready interrupt occurred or not
      * @rmtoll CIFR         HSERDYF       IsActiveFlag_HSERDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagHSERDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_HSERDYF) == (RCC_CIFR_HSERDYF)) ? true : false);
    }

    /**
      * @brief  Check if CSI ready interrupt occurred or not
      * @rmtoll CIFR         CSIRDYF       IsActiveFlag_CSIRDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagCSIRDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_CSIRDYF) == (RCC_CIFR_CSIRDYF)) ? true : false);
    }

    /**
      * @brief  Check if HSI48 ready interrupt occurred or not
      * @rmtoll CIFR         HSI48RDYF       IsActiveFlag_HSI48RDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagHSI48RDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_HSI48RDYF) == (RCC_CIFR_HSI48RDYF)) ? true : false);
    }

    /**
      * @brief  Check if PLL1 ready interrupt occurred or not
      * @rmtoll CIFR         PLLRDYF       IsActiveFlag_PLL1RDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagPLL1RDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_PLLRDYF) == (RCC_CIFR_PLLRDYF)) ? true : false);
    }

    /**
      * @brief  Check if PLL2 ready interrupt occurred or not
      * @rmtoll CIFR         PLL2RDYF       IsActiveFlag_PLL2RDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagPLL2RDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_PLL2RDYF) == (RCC_CIFR_PLL2RDYF)) ? true : false);
    }

    /**
      * @brief  Check if PLL3 ready interrupt occurred or not
      * @rmtoll CIFR         PLL3RDYF       IsActiveFlag_PLL3RDY
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagPLL3RDY(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_PLL3RDYF) == (RCC_CIFR_PLL3RDYF)) ? true : false);
    }

    /**
      * @brief  Check if LSE Clock security system interrupt occurred or not
      * @rmtoll CIFR         LSECSSF          IsActiveFlag_LSECSS
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagLSECSS(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_LSECSSF) == (RCC_CIFR_LSECSSF)) ? true : false);
    }

    /**
      * @brief  Check if HSE Clock security system interrupt occurred or not
      * @rmtoll CIFR         HSECSSF          IsActiveFlag_HSECSS
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagHSECSS(void)
    {
      return ((READ_BIT(RCC->CIFR, RCC_CIFR_HSECSSF) == (RCC_CIFR_HSECSSF)) ? true : false);
    }

    /**
      * @brief  Check if RCC flag Low Power D1 reset is set or not.
      * @rmtoll RSR          LPWRRSTF       IsActiveFlag_LPWRRST (*)\n
      *         RSR          LPWR1RSTF      IsActiveFlag_LPWRRST (**)
      *
      * (*) Only available for single core devices
      * (**) Only available for Dual core devices
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagLPWRRST(void)
    {
    #if defined(DUAL_CORE)
      return ((READ_BIT(RCC->RSR, RCC_RSR_LPWR1RSTF) == (RCC_RSR_LPWR1RSTF)) ? true : false);
    #else
      return ((READ_BIT(RCC->RSR, RCC_RSR_LPWRRSTF) == (RCC_RSR_LPWRRSTF)) ? true : false);
    #endif /*DUAL_CORE*/
    }

    #if defined(DUAL_CORE)
    /**
      * @brief  Check if RCC flag Low Power D2 reset is set or not.
      * @rmtoll RSR          LPWR2RSTF      IsActiveFlag_LPWR2RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagLPWR2RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_LPWR2RSTF) == (RCC_RSR_LPWR2RSTF)) ? true : false);
    }
    #endif  /*DUAL_CORE*/

    /**
      * @brief  Check if RCC flag Window Watchdog 1 reset is set or not.
      * @rmtoll RSR          WWDG1RSTF      IsActiveFlag_WWDG1RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagWWDG1RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_WWDG1RSTF) == (RCC_RSR_WWDG1RSTF)) ? true : false);
    }

    #if defined(DUAL_CORE)
    /**
      * @brief  Check if RCC flag Window Watchdog 2 reset is set or not.
      * @rmtoll RSR          WWDG2RSTF      IsActiveFlag_WWDG2RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagWWDG2RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_WWDG2RSTF) == (RCC_RSR_WWDG2RSTF)) ? true : false);
    }
    #endif  /*DUAL_CORE*/

    /**
      * @brief  Check if RCC flag Independent Watchdog 1 reset is set or not.
      * @rmtoll RSR          IWDG1RSTF      IsActiveFlag_IWDG1RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagIWDG1RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_IWDG1RSTF) == (RCC_RSR_IWDG1RSTF)) ? true : false);
    }

    #if defined(DUAL_CORE)
    /**
      * @brief  Check if RCC flag Independent Watchdog 2 reset is set or not.
      * @rmtoll RSR          IWDG2RSTF      IsActiveFlag_IWDG2RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagIWDG2RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_IWDG2RSTF) == (RCC_RSR_IWDG2RSTF)) ? true : false);
    }
    #endif  /*DUAL_CORE*/

    /**
      * @brief  Check if RCC flag Software reset is set or not.
      * @rmtoll RSR          SFTRSTF        IsActiveFlag_SFTRST (*)\n
      *         RSR          SFT1RSTF       IsActiveFlag_SFTRST (**)
      *
      * (*) Only available for single core devices
      * (**) Only available for Dual core devices
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagSFTRST(void)
    {
    #if defined(DUAL_CORE)
      return ((READ_BIT(RCC->RSR, RCC_RSR_SFT1RSTF) == (RCC_RSR_SFT1RSTF)) ? true : false);
    #else
      return ((READ_BIT(RCC->RSR, RCC_RSR_SFTRSTF) == (RCC_RSR_SFTRSTF)) ? true : false);
    #endif  /*DUAL_CORE*/
    }

    #if defined(DUAL_CORE)
    /**
      * @brief  Check if RCC flag Software reset is set or not.
      * @rmtoll RSR          SFT2RSTF       IsActiveFlag_SFT2RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagSFT2RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_SFT2RSTF) == (RCC_RSR_SFT2RSTF)) ? true : false);
    }
    #endif  /*DUAL_CORE*/

    /**
      * @brief  Check if RCC flag POR/PDR reset is set or not.
      * @rmtoll RSR          PORRSTF       IsActiveFlag_PORRST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagPORRST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_PORRSTF) == (RCC_RSR_PORRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC flag Pin reset is set or not.
      * @rmtoll RSR          PINRSTF       IsActiveFlag_PINRST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagPINRST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_PINRSTF) == (RCC_RSR_PINRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC flag BOR reset is set or not.
      * @rmtoll RSR          BORRSTF       IsActiveFlag_BORRST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagBORRST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_BORRSTF) == (RCC_RSR_BORRSTF)) ? true : false);
    }

    #if defined(RCC_RSR_D1RSTF)
    /**
      * @brief  Check if RCC flag D1 reset is set or not.
      * @rmtoll RSR          D1RSTF       IsActiveFlag_D1RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagD1RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_D1RSTF) == (RCC_RSR_D1RSTF)) ? true : false);
    }
    #endif /* RCC_RSR_D1RSTF */

    #if defined(RCC_RSR_CDRSTF)
    /**
      * @brief  Check if RCC flag CD reset is set or not.
      * @rmtoll RSR          CDRSTF       IsActiveFlag_CDRST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagCDRST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_CDRSTF) == (RCC_RSR_CDRSTF)) ? true : false);
    }
    #endif /* RCC_RSR_CDRSTF */

    #if defined(RCC_RSR_D2RSTF)
    /**
      * @brief  Check if RCC flag D2 reset is set or not.
      * @rmtoll RSR          D2RSTF       IsActiveFlag_D2RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagD2RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_D2RSTF) == (RCC_RSR_D2RSTF)) ? true : false);
    }
    #endif /* RCC_RSR_D2RSTF */

    #if defined(RCC_RSR_C1RSTF) || defined(RCC_RSR_CPURSTF)
    /**
      * @brief  Check if RCC flag CPU reset is set or not.
      * @rmtoll RSR          CPURSTF       IsActiveFlag_CPURST (*)\n
      *         RSR          C1RSTF        IsActiveFlag_CPURST (**)
      *
      * (*) Only available for single core devices
      * (**) Only available for Dual core devices
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagCPURST(void)
    {
    #if defined(DUAL_CORE)
      return ((READ_BIT(RCC->RSR, RCC_RSR_C1RSTF) == (RCC_RSR_C1RSTF)) ? true : false);
    #else
      return ((READ_BIT(RCC->RSR, RCC_RSR_CPURSTF) == (RCC_RSR_CPURSTF)) ? true : false);
    #endif/*DUAL_CORE*/
    }
    #endif /* defined(RCC_RSR_C1RSTF) || defined(RCC_RSR_CPURSTF) */

    #if defined(DUAL_CORE)
    /**
      * @brief  Check if RCC flag CPU2 reset is set or not.
      * @rmtoll RSR          C2RSTF       IsActiveFlag_CPU2RST
      * @retval State of bit (1 or 0).
      */
    bool IsActiveFlagCPU2RST(void)
    {
      return ((READ_BIT(RCC->RSR, RCC_RSR_C2RSTF) == (RCC_RSR_C2RSTF)) ? true : false);
    }
    #endif  /*DUAL_CORE*/

    /**
      * @brief  Set RMVF bit to clear all reset flags.
      * @rmtoll RSR          RMVF          ClearResetFlags
      * @retval None
      */
    void ClearResetFlags(void)
    {
      SET_BIT(RCC->RSR, RCC_RSR_RMVF);
    }

    #if defined(DUAL_CORE)
    /**
      * @brief  Check if RCC_C1 flag Low Power D1 reset is set or not.
      * @rmtoll RSR          LPWR1RSTF      LL_C1_RCC_IsActiveFlag_LPWRRST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagLPWRRST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_LPWR1RSTF) == (RCC_RSR_LPWR1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Low Power D2 reset is set or not.
      * @rmtoll RSR          LPWR2RSTF      LL_C1_RCC_IsActiveFlag_LPWR2RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagLPWR2RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_LPWR2RSTF) == (RCC_RSR_LPWR2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Window Watchdog 1 reset is set or not.
      * @rmtoll RSR          WWDG1RSTF      LL_C1_RCC_IsActiveFlag_WWDG1RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagWWDG1RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_WWDG1RSTF) == (RCC_RSR_WWDG1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Window Watchdog 2 reset is set or not.
      * @rmtoll RSR          WWDG2RSTF      LL_C1_RCC_IsActiveFlag_WWDG2RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlag_WWDG2RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_WWDG2RSTF) == (RCC_RSR_WWDG2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Independent Watchdog 1 reset is set or not.
      * @rmtoll RSR          IWDG1RSTF      LL_C1_RCC_IsActiveFlag_IWDG1RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagIWDG1RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_IWDG1RSTF) == (RCC_RSR_IWDG1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Independent Watchdog 2 reset is set or not.
      * @rmtoll RSR          IWDG2RSTF      LL_C1_RCC_IsActiveFlag_IWDG2RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagIWDG2RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_IWDG2RSTF) == (RCC_RSR_IWDG2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Software reset is set or not.
      * @rmtoll RSR          SFT1RSTF       LL_C1_RCC_IsActiveFlag_SFTRST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagSFTRST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_SFT1RSTF) == (RCC_RSR_SFT1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Software reset is set or not.
      * @rmtoll RSR          SFT2RSTF       LL_C1_RCC_IsActiveFlag_SFT2RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagSFT2RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_SFT2RSTF) == (RCC_RSR_SFT2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag POR/PDR reset is set or not.
      * @rmtoll RSR          PORRSTF       LL_C1_RCC_IsActiveFlag_PORRST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagPORRST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_PORRSTF) == (RCC_RSR_PORRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag Pin reset is set or not.
      * @rmtoll RSR          PINRSTF       LL_C1_RCC_IsActiveFlag_PINRST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlag_PINRST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_PINRSTF) == (RCC_RSR_PINRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag BOR reset is set or not.
      * @rmtoll RSR          BORRSTF       LL_C1_RCC_IsActiveFlag_BORRST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlag_BORRST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_BORRSTF) == (RCC_RSR_BORRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag D1 reset is set or not.
      * @rmtoll RSR          D1RSTF       LL_C1_RCC_IsActiveFlag_D1RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlag_D1RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_D1RSTF) == (RCC_RSR_D1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag D2 reset is set or not.
      * @rmtoll RSR          D2RSTF       LL_C1_RCC_IsActiveFlag_D2RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlag_D2RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_D2RSTF) == (RCC_RSR_D2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag CPU reset is set or not.
      * @rmtoll RSR          C1RSTF       LL_C1_RCC_IsActiveFlag_CPURST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlag_CPURST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_C1RSTF) == (RCC_RSR_C1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C1 flag CPU2 reset is set or not.
      * @rmtoll RSR          C2RSTF       LL_C1_RCC_IsActiveFlag_CPU2RST
      * @retval State of bit (1 or 0).
      */
    bool C1RCCIsActiveFlagCPU2RST(void)
    {
      return ((READ_BIT(RCC_C1->RSR, RCC_RSR_C2RSTF) == (RCC_RSR_C2RSTF)) ? true : false);
    }

    /**
      * @brief  Set RMVF bit to clear the reset flags.
      * @rmtoll RSR          RMVF          LL_C1_RCC_ClearResetFlags
      * @retval None
      */
    void C1RCCClearResetFlags(void)
    {
      SET_BIT(RCC_C1->RSR, RCC_RSR_RMVF);
    }

    /**
      * @brief  Check if RCC_C2 flag Low Power D1 reset is set or not.
      * @rmtoll RSR          LPWR1RSTF      C2RCCIsActiveFlagLPWRRST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagLPWRRST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_LPWR1RSTF) == (RCC_RSR_LPWR1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Low Power D2 reset is set or not.
      * @rmtoll RSR          LPWR2RSTF      C2RCCIsActiveFlagLPWR2RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagLPWR2RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_LPWR2RSTF) == (RCC_RSR_LPWR2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Window Watchdog 1 reset is set or not.
      * @rmtoll RSR          WWDG1RSTF      C2RCCIsActiveFlagWWDG1RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagWWDG1RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_WWDG1RSTF) == (RCC_RSR_WWDG1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Window Watchdog 2 reset is set or not.
      * @rmtoll RSR          WWDG2RSTF      C2RCCIsActiveFlagWWDG2RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagWWDG2RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_WWDG2RSTF) == (RCC_RSR_WWDG2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Independent Watchdog 1 reset is set or not.
      * @rmtoll RSR          IWDG1RSTF      C2RCCIsActiveFlagIWDG1RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagIWDG1RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_IWDG1RSTF) == (RCC_RSR_IWDG1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Independent Watchdog 2 reset is set or not.
      * @rmtoll RSR          IWDG2RSTF      C2RCCIsActiveFlagIWDG2RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagIWDG2RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_IWDG2RSTF) == (RCC_RSR_IWDG2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Software reset is set or not.
      * @rmtoll RSR          SFT1RSTF       C2RCCIsActiveFlagSFTRST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagSFTRST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_SFT1RSTF) == (RCC_RSR_SFT1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Software reset is set or not.
      * @rmtoll RSR          SFT2RSTF       C2RCCIsActiveFlagSFT2RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagSFT2RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_SFT2RSTF) == (RCC_RSR_SFT2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag POR/PDR reset is set or not.
      * @rmtoll RSR          PORRSTF       C2RCCIsActiveFlagPORRST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagPORRST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_PORRSTF) == (RCC_RSR_PORRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag Pin reset is set or not.
      * @rmtoll RSR          PINRSTF       C2RCCIsActiveFlagPINRST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagPINRST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_PINRSTF) == (RCC_RSR_PINRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag BOR reset is set or not.
      * @rmtoll RSR          BORRSTF       C2RCCIsActiveFlagBORRST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagBORRST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_BORRSTF) == (RCC_RSR_BORRSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag D1 reset is set or not.
      * @rmtoll RSR          D1RSTF       C2RCCIsActiveFlagD1RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagD1RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_D1RSTF) == (RCC_RSR_D1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag D2 reset is set or not.
      * @rmtoll RSR          D2RSTF       C2RCCIsActiveFlagD2RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagD2RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_D2RSTF) == (RCC_RSR_D2RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag CPU reset is set or not.
      * @rmtoll RSR          C1RSTF       C2RCCIsActiveFlagCPURST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagCPURST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_C1RSTF) == (RCC_RSR_C1RSTF)) ? true : false);
    }

    /**
      * @brief  Check if RCC_C2 flag CPU2 reset is set or not.
      * @rmtoll RSR          C2RSTF       C2RCCIsActiveFlagCPU2RST
      * @retval State of bit (1 or 0).
      */
    bool C2RCCIsActiveFlagCPU2RST(void)
    {
      return ((READ_BIT(RCC_C2->RSR, RCC_RSR_C2RSTF) == (RCC_RSR_C2RSTF)) ? true : false);
    }

    /**
      * @brief  Set RMVF bit to clear the reset flags.
      * @rmtoll RSR          RMVF          LL_C2_RCC_ClearResetFlags
      * @retval None
      */
    void LL_C2_RCC_ClearResetFlags(void)
    {
      SET_BIT(RCC_C2->RSR, RCC_RSR_RMVF);
    }
    #endif /*DUAL_CORE*/

    /** @defgroup RCC_EF_IT_Management IT Management
      * @{
      */

    /**
      * @brief  Enable LSI ready interrupt
      * @rmtoll CIER         LSIRDYIE      EnableITLSIRDY
      * @retval None
      */
    void EnableITLSIRDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_LSIRDYIE);
    }

    /**
      * @brief  Enable LSE ready interrupt
      * @rmtoll CIER         LSERDYIE      EnableITLSERDY
      * @retval None
      */
    void EnableITLSERDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_LSERDYIE);
    }

    /**
      * @brief  Enable HSI ready interrupt
      * @rmtoll CIER         HSIRDYIE      EnableITHSIRDY
      * @retval None
      */
    void EnableITHSIRDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_HSIRDYIE);
    }

    /**
      * @brief  Enable HSE ready interrupt
      * @rmtoll CIER         HSERDYIE      EnableITHSERDY
      * @retval None
      */
    void EnableITHSERDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_HSERDYIE);
    }

    /**
      * @brief  Enable CSI ready interrupt
      * @rmtoll CIER         CSIRDYIE      EnableITCSIRDY
      * @retval None
      */
    void EnableITCSIRDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_CSIRDYIE);
    }

    /**
      * @brief  Enable HSI48 ready interrupt
      * @rmtoll CIER         HSI48RDYIE      EnableITHSI48RDY
      * @retval None
      */
    void EnableITHSI48RDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_HSI48RDYIE);
    }

    /**
      * @brief  Enable PLL1 ready interrupt
      * @rmtoll CIER         PLL1RDYIE      EnableITPLL1RDY
      * @retval None
      */
    void EnableITPLL1RDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_PLL1RDYIE);
    }

    /**
      * @brief  Enable PLL2 ready interrupt
      * @rmtoll CIER         PLL2RDYIE  EnableITPLL2RDY
      * @retval None
      */
    void EnableITPLL2RDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_PLL2RDYIE);
    }

    /**
      * @brief  Enable PLL3 ready interrupt
      * @rmtoll CIER         PLL3RDYIE  EnableITPLL3RDY
      * @retval None
      */
    void EnableITPLL3RDY(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_PLL3RDYIE);
    }

    /**
      * @brief  Enable LSECSS interrupt
      * @rmtoll CIER         LSECSSIE  EnableITLSECSS
      * @retval None
      */
    void EnableITLSECSS(void)
    {
      SET_BIT(RCC->CIER, RCC_CIER_LSECSSIE);
    }

    /**
      * @brief  Disable LSI ready interrupt
      * @rmtoll CIER         LSIRDYIE      DisableITLSIRDY
      * @retval None
      */
    void DisableITLSIRDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_LSIRDYIE);
    }

    /**
      * @brief  Disable LSE ready interrupt
      * @rmtoll CIER         LSERDYIE      DisableITLSERDY
      * @retval None
      */
    void DisableITLSERDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_LSERDYIE);
    }

    /**
      * @brief  Disable HSI ready interrupt
      * @rmtoll CIER         HSIRDYIE      DisableITHSIRDY
      * @retval None
      */
    void DisableITHSIRDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_HSIRDYIE);
    }

    /**
      * @brief  Disable HSE ready interrupt
      * @rmtoll CIER         HSERDYIE      DisableITHSERDY
      * @retval None
      */
    void DisableITHSERDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_HSERDYIE);
    }

    /**
      * @brief  Disable CSI ready interrupt
      * @rmtoll CIER         CSIRDYIE      DisableITCSIRDY
      * @retval None
      */
    void DisableITCSIRDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_CSIRDYIE);
    }

    /**
      * @brief  Disable HSI48 ready interrupt
      * @rmtoll CIER         HSI48RDYIE      DisableITHSI48RDY
      * @retval None
      */
    void DisableITHSI48RDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_HSI48RDYIE);
    }

    /**
      * @brief  Disable PLL1 ready interrupt
      * @rmtoll CIER         PLL1RDYIE      DisableITPLL1RDY
      * @retval None
      */
    void DisableITPLL1RDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_PLL1RDYIE);
    }

    /**
      * @brief  Disable PLL2 ready interrupt
      * @rmtoll CIER         PLL2RDYIE  DisableITPLL2RDY
      * @retval None
      */
    void DisableITPLL2RDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_PLL2RDYIE);
    }

    /**
      * @brief  Disable PLL3 ready interrupt
      * @rmtoll CIER         PLL3RDYIE  DisableITPLL3RDY
      * @retval None
      */
    void DisableITPLL3RDY(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_PLL3RDYIE);
    }

    /**
      * @brief  Disable LSECSS interrupt
      * @rmtoll CIER         LSECSSIE  DisableITLSECSS
      * @retval None
      */
    void DisableITLSECSS(void)
    {
      CLEAR_BIT(RCC->CIER, RCC_CIER_LSECSSIE);
    }

    /**
      * @brief  Checks if LSI ready interrupt source is enabled or disabled.
      * @rmtoll CIER         LSIRDYIE      IsEnableITLSIRDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITLSIRDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_LSIRDYIE) == RCC_CIER_LSIRDYIE) ? true : false);
    }

    /**
      * @brief  Checks if LSE ready interrupt source is enabled or disabled.
      * @rmtoll CIER         LSERDYIE      IsEnableITLSERDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITLSERDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_LSERDYIE) == RCC_CIER_LSERDYIE) ? true : false);
    }

    /**
      * @brief  Checks if HSI ready interrupt source is enabled or disabled.
      * @rmtoll CIER         HSIRDYIE      IsEnableITHSIRDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITHSIRDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_HSIRDYIE) == RCC_CIER_HSIRDYIE) ? true : false);
    }

    /**
      * @brief  Checks if HSE ready interrupt source is enabled or disabled.
      * @rmtoll CIER         HSERDYIE      IsEnableITHSERDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITHSERDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_HSERDYIE) == RCC_CIER_HSERDYIE) ? true : false);
    }

    /**
      * @brief  Checks if CSI ready interrupt source is enabled or disabled.
      * @rmtoll CIER         CSIRDYIE      IsEnableITCSIRDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITCSIRDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_CSIRDYIE) == RCC_CIER_CSIRDYIE) ? true : false);
    }

    /**
      * @brief  Checks if HSI48 ready interrupt source is enabled or disabled.
      * @rmtoll CIER         HSI48RDYIE      IsEnableITHSI48RDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITHSI48RDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_HSI48RDYIE) == RCC_CIER_HSI48RDYIE) ? true : false);
    }

    /**
      * @brief  Checks if PLL1 ready interrupt source is enabled or disabled.
      * @rmtoll CIER         PLL1RDYIE      IsEnableITPLL1RDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITPLL1RDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_PLL1RDYIE) == RCC_CIER_PLL1RDYIE) ? true : false);
    }

    /**
      * @brief  Checks if PLL2 ready interrupt source is enabled or disabled.
      * @rmtoll CIER         PLL2RDYIE  IsEnableITPLL2RDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITPLL2RDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_PLL2RDYIE) == RCC_CIER_PLL2RDYIE) ? true : false);
    }

    /**
      * @brief  Checks if PLL3 ready interrupt source is enabled or disabled.
      * @rmtoll CIER         PLL3RDYIE  IsEnableITPLL3RDY
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITPLL3RDY(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_PLL3RDYIE) == RCC_CIER_PLL3RDYIE) ? true : false);
    }

    /**
      * @brief  Checks if LSECSS interrupt source is enabled or disabled.
      * @rmtoll CIER         LSECSSIE  IsEnableITLSECSS
      * @retval State of bit (1 or 0).
      */
    bool IsEnableITLSECSS(void)
    {
      return ((READ_BIT(RCC->CIER, RCC_CIER_LSECSSIE) == RCC_CIER_LSECSSIE) ? true : false);
    }

    /** @defgroup RCC_LL_EF_Init De-initialization function
      * @{
      */
    void DeInit(void)
    {
      /* Increasing the CPU frequency */
      if (FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
      {
        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
        MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
      }

      /* Set HSION bit */
      SET_BIT(RCC->CR, RCC_CR_HSION);

      /* Wait for HSI READY bit */
      while (!HSIIsReady())
      {}

      /* Reset CFGR register */
      CLEAR_REG(RCC->CFGR);

      /* Reset CSION , CSIKERON, HSEON, HSI48ON, HSECSSON,HSIDIV, PLL1ON, PLL2ON, PLL3ON bits */
      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON | RCC_CR_HSIDIV | RCC_CR_HSIDIVF | RCC_CR_CSION | RCC_CR_CSIKERON |  RCC_CR_HSI48ON  \
                | RCC_CR_CSSHSEON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);

      /* Wait for PLL1 READY bit to be reset */
      while (PLL1IsReady())
      {}

      /* Wait for PLL2 READY bit to be reset */
      while (PLL2IsReady())
      {}

      /* Wait for PLL3 READY bit to be reset */
      while (PLL3IsReady())
      {}

    #if defined(RCC_D1CFGR_HPRE)
      /* Reset D1CFGR register */
      CLEAR_REG(RCC->D1CFGR);

      /* Reset D2CFGR register */
      CLEAR_REG(RCC->D2CFGR);

      /* Reset D3CFGR register */
      CLEAR_REG(RCC->D3CFGR);
    #else
      /* Reset CDCFGR1 register */
      CLEAR_REG(RCC->CDCFGR1);

      /* Reset CDCFGR2 register */
      CLEAR_REG(RCC->CDCFGR2);

      /* Reset SRDCFGR register */
      CLEAR_REG(RCC->SRDCFGR);

    #endif /* RCC_D1CFGR_HPRE */

      /* Reset PLLCKSELR register to default value */
      RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM1_5 | RCC_PLLCKSELR_DIVM2_5 | RCC_PLLCKSELR_DIVM3_5;

      /* Reset PLLCFGR register to default value */
      WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);

      /* Reset PLL1DIVR register to default value */
      WRITE_REG(RCC->PLL1DIVR, 0x01010280U);

      /* Reset PLL1FRACR register */
      CLEAR_REG(RCC->PLL1FRACR);

      /* Reset PLL2DIVR register to default value */
      WRITE_REG(RCC->PLL2DIVR, 0x01010280U);

      /* Reset PLL2FRACR register */
      CLEAR_REG(RCC->PLL2FRACR);

      /* Reset PLL3DIVR register to default value */
      WRITE_REG(RCC->PLL3DIVR, 0x01010280U);

      /* Reset PLL3FRACR register */
      CLEAR_REG(RCC->PLL3FRACR);

      /* Reset HSEBYP bit */
      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);

      /* Disable all interrupts */
      CLEAR_REG(RCC->CIER);

      /* Clear all interrupts */
      SET_BIT(RCC->CICR, RCC_CICR_LSIRDYC | RCC_CICR_LSERDYC | RCC_CICR_HSIRDYC | RCC_CICR_HSERDYC
              | RCC_CICR_CSIRDYC | RCC_CICR_HSI48RDYC | RCC_CICR_PLLRDYC | RCC_CICR_PLL2RDYC
              | RCC_CICR_PLL3RDYC | RCC_CICR_LSECSSC | RCC_CICR_HSECSSC);

      /* Clear reset source flags */
      SET_BIT(RCC->RSR, RCC_RSR_RMVF);

      /* Decreasing the number of wait states because of lower CPU frequency */
      if (FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
      {
        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
        MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
      }
    }

    /** @defgroup RCC_LL_EF_Get_Freq Get system and peripherals clocks frequency functions
      * @{
      */
    uint32_t CalcPLLClockFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t PQR)
    {
        float freq;

        freq = ((float)PLLInputFreq / (float)M) * ((float)N + ((float)FRACN / (float)0x2000));

        freq = freq / (float)PQR;

        return (uint32_t)freq;
    }

    void GetPLL1ClockFreq(PLLClocksTypeDef *PLL_Clocks)
    {
        uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO, pllsource;
        uint32_t m, n, fracn = 0U;

        /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
          SYSCLK = PLL_VCO / PLLP
        */
        pllsource = PLLGetSource();

        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:
            if (HSIIsReady())
            {
              pllinputfreq = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_PLLSOURCE_CSI:
            if (CSIIsReady())
            {
              pllinputfreq = CSI_VALUE;
            }
            break;

          case RCC_PLLSOURCE_HSE:
            if (HSEIsReady())
            {
              pllinputfreq = HSE_VALUE;
            }
            break;

          case RCC_PLLSOURCE_NONE:
          default:
            /* PLL clock disabled */
            break;
        }

        PLL_Clocks->PLL_P_Frequency = 0U;
        PLL_Clocks->PLL_Q_Frequency = 0U;
        PLL_Clocks->PLL_R_Frequency = 0U;

        m = PLL1GetM();
        n = PLL1GetN();
        if (PLL1FRACNIsEnabled())
        {
          fracn = PLL1GetFRACN();
        }

        if (m != 0U)
        {
          if (PLL1PIsEnabled())
          {
            PLL_Clocks->PLL_P_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL1GetP());
          }

          if (PLL1QIsEnabled())
          {
            PLL_Clocks->PLL_Q_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL1GetQ());
          }

          if (PLL1RIsEnabled())
          {
            PLL_Clocks->PLL_R_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL1GetR());
          }
        }
    }
    void GetPLL2ClockFreq(PLLClocksTypeDef *PLL_Clocks)
    {
        uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO, pllsource;
        uint32_t m, n, fracn = 0U;

        /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
          SYSCLK = PLL_VCO / PLLP
        */
        pllsource = PLLGetSource();

        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:
            if (HSIIsReady())
            {
              pllinputfreq = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_PLLSOURCE_CSI:
            if (CSIIsReady())
            {
              pllinputfreq = CSI_VALUE;
            }
            break;

          case RCC_PLLSOURCE_HSE:
            if (HSEIsReady())
            {
              pllinputfreq = HSE_VALUE;
            }
            break;

          case RCC_PLLSOURCE_NONE:
          default:
            /* PLL clock disabled */
            break;
        }

        PLL_Clocks->PLL_P_Frequency = 0U;
        PLL_Clocks->PLL_Q_Frequency = 0U;
        PLL_Clocks->PLL_R_Frequency = 0U;

        m = PLL2GetM();
        n = PLL2GetN();
        if (PLL2FRACNIsEnabled())
        {
          fracn = PLL2GetFRACN();
        }

        if (m != 0U)
        {
          if (PLL2PIsEnabled())
          {
            PLL_Clocks->PLL_P_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL2GetP());
          }

          if (PLL2QIsEnabled())
          {
            PLL_Clocks->PLL_Q_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL2GetQ());
          }

          if (PLL2RIsEnabled())
          {
            PLL_Clocks->PLL_R_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL2GetR());
          }
        }
    }
    void GetPLL3ClockFreq(PLLClocksTypeDef *PLL_Clocks)
    {
        uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO, pllsource;
        uint32_t m, n, fracn = 0U;

        /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
          SYSCLK = PLL_VCO / PLLP
        */
        pllsource = PLLGetSource();

        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:
            if (HSIIsReady())
            {
              pllinputfreq = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_PLLSOURCE_CSI:
            if (CSIIsReady())
            {
              pllinputfreq = CSI_VALUE;
            }
            break;

          case RCC_PLLSOURCE_HSE:
            if (HSEIsReady())
            {
              pllinputfreq = HSE_VALUE;
            }
            break;

          case RCC_PLLSOURCE_NONE:
          default:
            /* PLL clock disabled */
            break;
        }

        PLL_Clocks->PLL_P_Frequency = 0U;
        PLL_Clocks->PLL_Q_Frequency = 0U;
        PLL_Clocks->PLL_R_Frequency = 0U;

        m = PLL3GetM();
        n = PLL3GetN();
        if (PLL3FRACNIsEnabled())
        {
          fracn = PLL3GetFRACN();
        }

        if ((m != 0U) && (pllinputfreq != 0U))
        {
          if (PLL3PIsEnabled())
          {
            PLL_Clocks->PLL_P_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL3GetP());
          }

          if (PLL3QIsEnabled())
          {
            PLL_Clocks->PLL_Q_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL3GetQ());
          }

          if (PLL3RIsEnabled())
          {
            PLL_Clocks->PLL_R_Frequency = CalcPLLClockFreq(pllinputfreq, m, n, fracn, PLL3GetR());
          }
        }
    }

    void GetSystemClocksFreq(RCCClocksTypeDef *RCC_Clocks)
    {
        /* Get SYSCLK frequency */
        RCC_Clocks->SYSCLK_Frequency = GetSystemClockFreq();

        /* HCLK clock frequency */
        RCC_Clocks->HCLK_Frequency   = GetHCLKClockFreq();

        /* PCLK1 clock frequency */
        RCC_Clocks->PCLK1_Frequency  = GetPCLK1ClockFreq();

        /* PCLK2 clock frequency */
        RCC_Clocks->PCLK2_Frequency  = GetPCLK2ClockFreq();

        /* PCLK3 clock frequency */
        RCC_Clocks->PCLK3_Frequency  = GetPCLK3ClockFreq();

        /* PCLK4 clock frequency */
        RCC_Clocks->PCLK4_Frequency  = GetPCLK4ClockFreq();
    }

    uint32_t GetUSARTClockFreq(RCCUSARTxGetClkSource USARTxSource)
    {
        uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetUSARTClockSource(USARTxSource))
        {
          case RCC_USART16_CLKSOURCE_PCLK2:
            usart_frequency = GetPCLK2ClockFreq();
            break;

          case RCC_USART234578_CLKSOURCE_PCLK1:
            usart_frequency = GetPCLK1ClockFreq();
            break;

          case RCC_USART16_CLKSOURCE_PLL2Q:
          case RCC_USART234578_CLKSOURCE_PLL2Q:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              usart_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_USART16_CLKSOURCE_PLL3Q:
          case RCC_USART234578_CLKSOURCE_PLL3Q:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              usart_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_USART16_CLKSOURCE_HSI:
          case RCC_USART234578_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              usart_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_USART16_CLKSOURCE_CSI:
          case RCC_USART234578_CLKSOURCE_CSI:
            if (CSIIsReady())
            {
              usart_frequency = CSI_VALUE;
            }
            break;

          case RCC_USART16_CLKSOURCE_LSE:
          case RCC_USART234578_CLKSOURCE_LSE:
            if (LSEIsReady())
            {
              usart_frequency = LSE_VALUE;
            }
            break;

          default:
            /* Kernel clock disabled */
            break;
        }
        return usart_frequency;
    }
    uint32_t GetLPUARTClockFreq(RCCLPUARTxGetClkSource LPUARTxSource)
    {
        uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetLPUARTClockSource(LPUARTxSource))
        {
          case RCC_LPUART1_CLKSOURCE_PCLK4:
            lpuart_frequency = GetPCLK4ClockFreq();
            break;

          case RCC_LPUART1_CLKSOURCE_PLL2Q:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              lpuart_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_LPUART1_CLKSOURCE_PLL3Q:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              lpuart_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_LPUART1_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              lpuart_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_LPUART1_CLKSOURCE_CSI:
            if (CSIIsReady())
            {
              lpuart_frequency = CSI_VALUE;
            }
            break;

          case RCC_LPUART1_CLKSOURCE_LSE:
            if (LSEIsReady())
            {
              lpuart_frequency = LSE_VALUE;
            }
            break;

          default:
            /* Kernel clock disabled */
            break;
        }

        return lpuart_frequency;
    }
    uint32_t GetI2CClockFreq(RCCI2CxGetClkSource I2CxSource)
    {
        uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetI2CClockSource(I2CxSource))
        {
          case RCC_I2C123_CLKSOURCE_PCLK1:
            i2c_frequency = GetPCLK1ClockFreq();
            break;

          case RCC_I2C4_CLKSOURCE_PCLK4:
            i2c_frequency = GetPCLK4ClockFreq();
            break;

          case RCC_I2C123_CLKSOURCE_PLL3R:
          case RCC_I2C4_CLKSOURCE_PLL3R:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              i2c_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_I2C123_CLKSOURCE_HSI:
          case RCC_I2C4_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              i2c_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_I2C123_CLKSOURCE_CSI:
          case RCC_I2C4_CLKSOURCE_CSI:
            if (CSIIsReady())
            {
              i2c_frequency = CSI_VALUE;
            }
            break;

          default:
            /* Nothing to do */
            break;
        }
        return i2c_frequency;
    }
    uint32_t GetLPTIMClockFreq(RCCLPTIMxGetClkSource LPTIMxSource)
    {
        uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;
        switch (GetLPTIMClockSource(LPTIMxSource))
        {
          case RCC_LPTIM1_CLKSOURCE_PCLK1:
            lptim_frequency = GetPCLK1ClockFreq();
            break;

          case RCC_LPTIM2_CLKSOURCE_PCLK4:
          case RCC_LPTIM345_CLKSOURCE_PCLK4:
            lptim_frequency = GetPCLK4ClockFreq();
            break;

          case RCC_LPTIM1_CLKSOURCE_PLL2P:
          case RCC_LPTIM2_CLKSOURCE_PLL2P:
          case RCC_LPTIM345_CLKSOURCE_PLL2P:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              lptim_frequency = PLL_Clocks.PLL_P_Frequency;
            }
            break;

          case RCC_LPTIM1_CLKSOURCE_PLL3R:
          case RCC_LPTIM2_CLKSOURCE_PLL3R:
          case RCC_LPTIM345_CLKSOURCE_PLL3R:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              lptim_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_LPTIM1_CLKSOURCE_LSE:
          case RCC_LPTIM2_CLKSOURCE_LSE:
          case RCC_LPTIM345_CLKSOURCE_LSE:
            if (LSEIsReady())
            {
              lptim_frequency = LSE_VALUE;
            }
            break;

          case RCC_LPTIM1_CLKSOURCE_LSI:
          case RCC_LPTIM2_CLKSOURCE_LSI:
          case RCC_LPTIM345_CLKSOURCE_LSI:
            if (LSIIsReady())
            {
              lptim_frequency = LSI_VALUE;
            }
            break;

          case RCC_LPTIM1_CLKSOURCE_CLKP:
          case RCC_LPTIM2_CLKSOURCE_CLKP:
          case RCC_LPTIM345_CLKSOURCE_CLKP:
            lptim_frequency = GetCLKPClockFreq(RCC_CLKP_CLKSOURCE);
            break;

          default:
            /* Kernel clock disabled */
            break;
        }

        return lptim_frequency;
    }
    uint32_t GetSAIClockFreq(RCCSAIxGetClkSource SAIxSource)
    {
        uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;
        switch (GetSAIClockSource(SAIxSource))
        {
          case RCC_SAI1_CLKSOURCE_PLL1Q:
      #if defined(SAI3)
          case RCC_SAI23_CLKSOURCE_PLL1Q:
      #endif /* SAI3 */
      #if defined(SAI4)
          case RCC_SAI4A_CLKSOURCE_PLL1Q:
          case RCC_SAI4B_CLKSOURCE_PLL1Q:
      #endif /* SAI4 */
      #if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)
          case RCC_SAI2A_CLKSOURCE_PLL1Q:
          case RCC_SAI2B_CLKSOURCE_PLL1Q:
      #endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              sai_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_SAI1_CLKSOURCE_PLL2P:
      #if defined(SAI3)
          case RCC_SAI23_CLKSOURCE_PLL2P:
      #endif /* SAI3 */
      #if defined(SAI4)
          case RCC_SAI4A_CLKSOURCE_PLL2P:
          case RCC_SAI4B_CLKSOURCE_PLL2P:
      #endif /* SAI4 */
      #if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)
          case RCC_SAI2A_CLKSOURCE_PLL2P:
          case RCC_SAI2B_CLKSOURCE_PLL2P:
      #endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              sai_frequency = PLL_Clocks.PLL_P_Frequency;
            }
            break;

          case RCC_SAI1_CLKSOURCE_PLL3P:
      #if defined(SAI3)
          case RCC_SAI23_CLKSOURCE_PLL3P:
      #endif /* SAI3 */
      #if defined(SAI4)
          case RCC_SAI4A_CLKSOURCE_PLL3P:
          case RCC_SAI4B_CLKSOURCE_PLL3P:
      #endif /* SAI4 */
      #if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)
          case RCC_SAI2A_CLKSOURCE_PLL3P:
          case RCC_SAI2B_CLKSOURCE_PLL3P:
      #endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              sai_frequency = PLL_Clocks.PLL_P_Frequency;
            }
            break;

          case RCC_SAI1_CLKSOURCE_I2S_CKIN:
      #if defined(SAI3)
          case RCC_SAI23_CLKSOURCE_I2S_CKIN:
      #endif /* SAI3 */
      #if defined(SAI4)
          case RCC_SAI4A_CLKSOURCE_I2S_CKIN:
          case RCC_SAI4B_CLKSOURCE_I2S_CKIN:
      #endif /* SAI4 */
      #if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)
          case RCC_SAI2A_CLKSOURCE_I2S_CKIN:
          case RCC_SAI2B_CLKSOURCE_I2S_CKIN:
      #endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */
            sai_frequency = EXTERNAL_CLOCK_VALUE;
            break;

          case RCC_SAI1_CLKSOURCE_CLKP:
      #if defined(SAI3)
          case RCC_SAI23_CLKSOURCE_CLKP:
      #endif /* SAI3 */
      #if defined(SAI4)
          case RCC_SAI4A_CLKSOURCE_CLKP:
          case RCC_SAI4B_CLKSOURCE_CLKP:
      #endif /* SAI4 */
      #if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)
          case RCC_SAI2A_CLKSOURCE_CLKP:
          case RCC_SAI2B_CLKSOURCE_CLKP:
      #endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */
            sai_frequency = GetCLKPClockFreq(RCC_CLKP_CLKSOURCE);
            break;

          default:
            /* Kernel clock disabled */
            break;
        }
        return sai_frequency;
    }
    uint32_t GetADCClockFreq(RCCADCGetClkSource ADCxSource)
    {
        uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetADCClockSource(ADCxSource))
        {
          case RCC_ADC_CLKSOURCE_PLL2P:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              adc_frequency = PLL_Clocks.PLL_P_Frequency;
            }
            break;

          case RCC_ADC_CLKSOURCE_PLL3R:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              adc_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_ADC_CLKSOURCE_CLKP:
            adc_frequency = GetCLKPClockFreq(RCC_CLKP_CLKSOURCE);
            break;

          default:
            /* Kernel clock disabled */
            break;
        }

        return adc_frequency;
    }
    uint32_t GetSDMMCClockFreq(RCCSDMMCGetClkSource SDMMCxSource)
    {
        uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetSDMMCClockSource(SDMMCxSource))
        {
          case RCC_SDMMC_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              sdmmc_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_SDMMC_CLKSOURCE_PLL2R:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              sdmmc_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          default:
            /* Nothing to do */
            break;
        }

        return sdmmc_frequency;
    }
    uint32_t GetRNGClockFreq(RCCRNGGetClkSource RNGxSource)
    {
        uint32_t rng_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetRNGClockSource(RNGxSource))
        {
          case RCC_RNG_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              rng_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_RNG_CLKSOURCE_HSI48:
            if (HSI48IsReady())
            {
              rng_frequency = 48000000U;
            }
            break;

          case RCC_RNG_CLKSOURCE_LSE:
            if (LSEIsReady())
            {
              rng_frequency = LSE_VALUE;
            }
            break;

          case RCC_RNG_CLKSOURCE_LSI:
            if (LSIIsReady())
            {
              rng_frequency = LSI_VALUE;
            }
            break;

          default:
            /* Nothing to do */
            break;
        }

        return rng_frequency;
    }
    uint32_t GetCECClockFreq(RCCCECGetClkSource CECxSource)
    {
        uint32_t cec_frequency = RCC_PERIPH_FREQUENCY_NO;

          switch (GetCECClockSource(CECxSource))
          {
            case RCC_CEC_CLKSOURCE_LSE:
              if (LSEIsReady())
              {
                cec_frequency = LSE_VALUE;
              }
              break;

            case RCC_CEC_CLKSOURCE_LSI:
              if (LSIIsReady())
              {
                cec_frequency = LSI_VALUE;
              }
              break;

            case RCC_CEC_CLKSOURCE_CSI_DIV122:
              if (CSIIsReady())
              {
                cec_frequency = CSI_VALUE / 122U;
              }
              break;

            default:
              /* Kernel clock disabled */
              break;
          }

          return cec_frequency;
    }
    uint32_t GetUSBClockFreq(RCCUSBGetClkSource USBxSource)
    {
        uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetUSBClockSource(USBxSource))
        {
          case RCC_USB_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              usb_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_USB_CLKSOURCE_PLL3Q:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              usb_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_USB_CLKSOURCE_HSI48:
            if (HSI48IsReady())
            {
              usb_frequency = HSI48_VALUE;
            }
            break;

          case RCC_USB_CLKSOURCE_DISABLE:
          default:
            /* Nothing to do */
            break;
        }

        return usb_frequency;
    }
    uint32_t GetDFSDMClockFreq(RCCDFSDM1GetClkSource DFSDMxSource)
    {
        uint32_t dfsdm_frequency = RCC_PERIPH_FREQUENCY_NO;
        switch (GetDFSDMClockSource(DFSDMxSource))
        {
          case RCC_DFSDM1_CLKSOURCE_SYSCLK:
            dfsdm_frequency = GetSystemClockFreq();
            break;

          case RCC_DFSDM1_CLKSOURCE_PCLK2:
            dfsdm_frequency = GetPCLK2ClockFreq();
            break;

          default:
            /* Nothing to do */
            break;
        }
        return dfsdm_frequency;
    }
    #if defined(DFSDM2_BASE)
    uint32_t GetDFSDM2ClockFreq(RCCDFSDM2GetClkSource DFSDMxSource)
    {
        uint32_t dfsdm_frequency = RCC_PERIPH_FREQUENCY_NO;
        switch (GetDFSDM2ClockSource(DFSDMxSource))
        {
          case RCC_DFSDM2_CLKSOURCE_SYSCLK:
            dfsdm_frequency = GetSystemClockFreq();
            break;

          case RCC_DFSDM2_CLKSOURCE_PCLK4:
            dfsdm_frequency = GetPCLK4ClockFreq(GetHCLKClockFreq(RCCCalcSysFreqHz(GetSystemClockFreq(), GetSysPrescaler())));
            break;

          default:
            /* Nothing to do */
            break;
        }
        return dfsdm_frequency;
    }
    #endif /* DFSDM2_BASE */
    #if defined(DSI)
    uint32_t GetDSIClockFreq(RCCDSIGetClkSource DSIxSource)
    {
        uint32_t dsi_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetDSIClockSource(DSIxSource))
        {
          case RCC_DSI_CLKSOURCE_PLL2Q:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              dsi_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_DSI_CLKSOURCE_PHY:
            dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
            break;

          default:
            /* Nothing to do */
            break;
        }

        return dsi_frequency;
    }
    #endif /* DSI */
    uint32_t GetSPDIFClockFreq(RCCSPDIFGetClkSource SPDIFxSource)
    {
        uint32_t spdif_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetSPDIFClockSource(SPDIFxSource))
        {
          case RCC_SPDIF_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              spdif_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_SPDIF_CLKSOURCE_PLL2R:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              spdif_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_SPDIF_CLKSOURCE_PLL3R:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              spdif_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_SPDIF_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              spdif_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          default:
            /* Nothing to do */
            break;
        }

        return spdif_frequency;
    }
    uint32_t GetSPIClockFreq(RCCSPIxGetClkSource SPIxSource)
    {
        uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetSPIClockSource(SPIxSource))
        {
          case RCC_SPI123_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              spi_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_SPI123_CLKSOURCE_PLL2P:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              spi_frequency = PLL_Clocks.PLL_P_Frequency;
            }
            break;

          case RCC_SPI123_CLKSOURCE_PLL3P:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              spi_frequency = PLL_Clocks.PLL_P_Frequency;
            }
            break;

          case RCC_SPI123_CLKSOURCE_I2S_CKIN:
      #if defined(LL_RCC_SPI6_CLKSOURCE_I2S_CKIN)
          case RCC_SPI6_CLKSOURCE_I2S_CKIN:
      #endif /* LL_RCC_SPI6_CLKSOURCE_I2S_CKIN */
            spi_frequency = EXTERNAL_CLOCK_VALUE;
            break;

          case RCC_SPI123_CLKSOURCE_CLKP:
            spi_frequency = GetCLKPClockFreq(RCC_CLKP_CLKSOURCE);
            break;

          case RCC_SPI45_CLKSOURCE_PCLK2:
            spi_frequency = GetPCLK2ClockFreq();
            break;

          case RCC_SPI6_CLKSOURCE_PCLK4:
            spi_frequency = GetPCLK4ClockFreq();
            break;

          case RCC_SPI45_CLKSOURCE_PLL2Q:
          case RCC_SPI6_CLKSOURCE_PLL2Q:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              spi_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_SPI45_CLKSOURCE_PLL3Q:
          case RCC_SPI6_CLKSOURCE_PLL3Q:
            if (PLL3IsReady())
            {
              GetPLL3ClockFreq(&PLL_Clocks);
              spi_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_SPI45_CLKSOURCE_HSI:
          case RCC_SPI6_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              spi_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          case RCC_SPI45_CLKSOURCE_CSI:
          case RCC_SPI6_CLKSOURCE_CSI:
            if (CSIIsReady())
            {
              spi_frequency = CSI_VALUE;
            }
            break;

          case RCC_SPI45_CLKSOURCE_HSE:
          case RCC_SPI6_CLKSOURCE_HSE:
            if (HSEIsReady())
            {
              spi_frequency = HSE_VALUE;
            }
            break;

          default:
            /* Kernel clock disabled */
            break;
        }

        return spi_frequency;
    }
    uint32_t GetSWPClockFreq(RCCSWPGetClkSource SWPxSource)
    {
        uint32_t swp_frequency = RCC_PERIPH_FREQUENCY_NO;
        switch (GetSWPClockSource(SWPxSource))
        {
          case RCC_SWP_CLKSOURCE_PCLK1:
            swp_frequency = GetPCLK1ClockFreq();
            break;

          case RCC_SWP_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              swp_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;

          default:
            /* Nothing to do */
            break;
        }

        return swp_frequency;
    }
    uint32_t GetFDCANClockFreq(RCCFDCANGetClkSource FDCANxSource)
    {
        uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetFDCANClockSource(FDCANxSource))
        {
          case RCC_FDCAN_CLKSOURCE_HSE:
            if (HSEIsReady())
            {
              fdcan_frequency = HSE_VALUE;
            }
            break;

          case RCC_FDCAN_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              fdcan_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_FDCAN_CLKSOURCE_PLL2Q:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              fdcan_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          default:
            /* Kernel clock disabled */
            break;
        }

        return fdcan_frequency;
    }
    uint32_t GetFMCClockFreq(RCCFMCGetClkSource FMCxSource)
    {
        uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetFMCClockSource(FMCxSource))
        {
          case RCC_FMC_CLKSOURCE_HCLK:
            fmc_frequency = GetHCLKClockFreq();
            break;

          case RCC_FMC_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              fmc_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_FMC_CLKSOURCE_PLL2R:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              fmc_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_FMC_CLKSOURCE_CLKP:
            fmc_frequency = GetCLKPClockFreq(RCC_CLKP_CLKSOURCE);
            break;

          default:
            /* Nothing to do */
            break;
        }

        return fmc_frequency;
    }
    #if defined(QUADSPI)
    uint32_t GetQSPIClockFreq(RCCQSPIGetClkSource QSPIxSource)
    {
        uint32_t qspi_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetQSPIClockSource(QSPIxSource))
        {
          case RCC_QSPI_CLKSOURCE_HCLK:
            qspi_frequency = GetHCLKClockFreq();
            break;

          case RCC_QSPI_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              qspi_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_QSPI_CLKSOURCE_PLL2R:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              qspi_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_QSPI_CLKSOURCE_CLKP:
            qspi_frequency = GetCLKPClockFreq(RCC_CLKP_CLKSOURCE);
            break;

          default:
            /* Nothing to do */
            break;
        }

        return qspi_frequency;
    }
    #endif /* QUADSPI */
    #if defined(OCTOSPI1) || defined(OCTOSPI2)
    uint32_t GetOSPIClockFreq(RCCOSPIGetClkSource OSPIxSource)
    {
        uint32_t ospi_frequency = RCC_PERIPH_FREQUENCY_NO;
        PLLClocksTypeDef PLL_Clocks;

        switch (GetOSPIClockSource(OSPIxSource))
        {
          case RCC_OSPI_CLKSOURCE_HCLK:
            ospi_frequency = GetHCLKClockFreq(RCCCalcSysFreqHz(GetSystemClockFreq(), GetSysPrescaler()));
            break;

          case RCC_OSPI_CLKSOURCE_PLL1Q:
            if (PLL1IsReady())
            {
              GetPLL1ClockFreq(&PLL_Clocks);
              ospi_frequency = PLL_Clocks.PLL_Q_Frequency;
            }
            break;

          case RCC_OSPI_CLKSOURCE_PLL2R:
            if (PLL2IsReady())
            {
              GetPLL2ClockFreq(&PLL_Clocks);
              ospi_frequency = PLL_Clocks.PLL_R_Frequency;
            }
            break;

          case RCC_OSPI_CLKSOURCE_CLKP:
            ospi_frequency = GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);
            break;

          default:
            /* Nothing to do */
            break;
        }

        return ospi_frequency;
    }
    #endif /* defined(OCTOSPI1) || defined(OCTOSPI2) */
    uint32_t GetCLKPClockFreq(RCCCLKPGetClkSource CLKPxSource)
    {
        uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
        switch (GetCLKPClockSource(CLKPxSource))
        {
          case RCC_CLKP_CLKSOURCE_HSI:
            if (HSIIsReady())
            {
              clkp_frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
            }
            break;
          case RCC_CLKP_CLKSOURCE_CSI:
            if (CSIIsReady())
            {
              clkp_frequency = CSI_VALUE;
            }
            break;
          case RCC_CLKP_CLKSOURCE_HSE:
            if (HSEIsReady())
            {
              clkp_frequency = HSE_VALUE;
            }
            break;
          default:
            /* CLKP clock disabled */
            break;
        }
        return clkp_frequency;
    }
    void enableGPIOPerClk(GPIO_TypeDef *gpio, bool bEnabale)
    {
        uint32_t offset = (((uint32_t)gpio -  (uint32_t)GPIOA_BASE) / 0x400);
        bEnabale ? SET_BIT(RCC->AHB4ENR, 1UL << offset) : CLEAR_BIT(RCC->AHB4ENR, 1UL << offset);
    }
    void AHB3GRP1EnableClock(RCCAHB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB3ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB3ENR, periphs);
        (void)tmpreg;
    }
    bool AHB3GRP1IsEnabledClock(RCCAHB3GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->AHB3ENR, periphs) == periphs) ? true : false);
    }
    void AHB3GRP1DisableClock(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB3ENR, periphs);
    }
    void AHB3GRP1ForceReset(RCCAHB3GRP1PerClkType periphs)
    {
        SET_BIT(RCC->AHB3RSTR, periphs);
    }
    void AHB3GRP1ReleaseReset(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB3RSTR, periphs);
    }
    void AHB3GRP1EnableClockSleep(RCCAHB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB3LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB3LPENR, periphs);
        (void)tmpreg;
    }
    void AHB3GRP1DisableClockSleep(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB3LPENR, periphs);
    }

    /** @defgroup EF_AHB1 AHB1
     * @{
     */
    void AHB1GRP1EnableClock(RCCAHB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB1ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB1ENR, periphs);
        (void)tmpreg;
    }
    bool AHB1GRP1IsEnabledClock(RCCAHB1GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->AHB1ENR, periphs) == periphs) ? true : false);
    }
    void AHB1GRP1DisableClock(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB1ENR, periphs);
    }
    void AHB1GRP1ForceReset(RCCAHB1GRP1PerClkType periphs)
    {
        SET_BIT(RCC->AHB1RSTR, periphs);
    }
    void AHB1GRP1ReleaseReset(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB1RSTR, periphs);
    }
    void AHB1GRP1EnableClockSleep(RCCAHB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB1LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB1LPENR, periphs);
        (void)tmpreg;
    }
    void AHB1GRP1DisableClockSleep(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB1LPENR, periphs);
    }
    /** @defgroup BUS_LL_EF_AHB2 AHB2
     * @{
     */
    void AHB2GRP1EnableClock(RCCAHB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB2ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB2ENR, periphs);
        (void)tmpreg;
    }
    bool AHB2GRP1IsEnabledClock(RCCAHB2GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->AHB2ENR, periphs) == periphs) ? true : false);
    }
    void AHB2GRP1DisableClock(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB2ENR, periphs);
    }
    void AHB2GRP1ForceReset(RCCAHB2GRP1PerClkType periphs)
    {
        SET_BIT(RCC->AHB2RSTR, periphs);
    }
    void AHB2GRP1ReleaseReset(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB2RSTR, periphs);
    }
    void AHB2GRP1EnableClockSleep(RCCAHB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB2LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB2LPENR, periphs);
        (void)tmpreg;
    }
    void AHB2GRP1DisableClockSleep(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB2LPENR, periphs);
    }
    /** @defgroup BUS_LL_EF_AHB4 AHB4
     * @{
     */
    void AHB4GRP1EnableClock(RCCAHB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB4ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB4ENR, periphs);
        (void)tmpreg;
    }
    bool AHB4GRP1IsEnabledClock(RCCAHB4GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->AHB4ENR, periphs) == periphs) ? true : false);
    }
    void AHB4GRP1DisableClock(RCCAHB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB4ENR, periphs);
    }
    void AHB4GRP1ForceReset(RCCAHB4GRP1PerClkType periphs)
    {
        SET_BIT(RCC->AHB4RSTR, periphs);
    }
    void AHB4GRP1ReleaseReset(RCCAHB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB4RSTR, periphs);
    }
    void AHB4GRP1EnableClockSleep(RCCAHB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->AHB4LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->AHB4LPENR, periphs);
        (void)tmpreg;
    }
    void AHB4GRP1DisableClockSleep(RCCAHB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->AHB4LPENR, periphs);
    }
    /** @defgroup BUS_LL_EF_APB3 APB3
     * @{
     */
    void APB3GRP1EnableClock(RCCAPB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB3ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB3ENR, periphs);
        (void)tmpreg;
    }
    bool APB3GRP1IsEnabledClock(RCCAPB3GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->APB3ENR, periphs) == periphs) ? true : false);
    }
    void APB3GRP1DisableClock(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB3ENR, periphs);
    }
    void APB3GRP1ForceReset(RCCAPB3GRP1PerClkType periphs)
    {
        SET_BIT(RCC->APB3RSTR, periphs);
    }
    void APB3GRP1ReleaseReset(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB3RSTR, periphs);
    }
    void APB3GRP1EnableClockSleep(RCCAPB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB3LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB3LPENR, periphs);
        (void)tmpreg;
    }
    void APB3GRP1DisableClockSleep(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB3LPENR, periphs);
    }
    /** @defgroup EF_APB1 APB1
     * @{
     */
    void APB1GRP1EnableClock(RCCAPB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB1LENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB1LENR, periphs);
        (void)tmpreg;
    }
    bool APB1GRP1IsEnabledClock(RCCAPB1GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->APB1LENR, periphs) == periphs) ? true : false);
    }
    void APB1GRP1DisableClock(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB1LENR, periphs);
    }
    void APB1GRP1ForceReset(RCCAPB1GRP1PerClkType periphs)
    {
        SET_BIT(RCC->APB1LRSTR, periphs);
    }
    void APB1GRP1ReleaseReset(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB1LRSTR, periphs);
    }
    void APB1GRP1EnableClockSleep(RCCAPB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB1LLPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB1LLPENR, periphs);
        (void)tmpreg;
    }
    void APB1GRP1DisableClockSleep(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB1LLPENR, periphs);
    }
    void APB1GRP2EnableClock(RCCAPB1GRP2PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB1HENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB1HENR, periphs);
        (void)tmpreg;
    }
    bool APB1GRP2IsEnabledClock(RCCAPB1GRP2PerClkType periphs)
    {
        return ((READ_BIT(RCC->APB1HENR, periphs) == periphs) ? true : false);
    }
    void APB1GRP2DisableClock(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB1HENR, periphs);
    }
    void APB1GRP2ForceReset(RCCAPB1GRP2PerClkType periphs)
    {
        SET_BIT(RCC->APB1HRSTR, periphs);
    }
    void APB1GRP2ReleaseReset(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB1HRSTR, periphs);
    }
    void APB1GRP2EnableClockSleep(RCCAPB1GRP2PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB1HLPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB1HLPENR, periphs);
        (void)tmpreg;
    }
    void APB1GRP2DisableClockSleep(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB1HLPENR, periphs);
    }
    /** @defgroup EF_APB2 APB2
     * @{
     */
    void APB2GRP1EnableClock(RCCAPB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB2ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB2ENR, periphs);
        (void)tmpreg;
    }
    bool APB2GRP1IsEnabledClock(RCCAPB2GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->APB2ENR, periphs) == periphs) ? true : false);
    }
    void APB2GRP1DisableClock(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB2ENR, periphs);
    }
    void APB2GRP1ForceReset(RCCAPB2GRP1PerClkType periphs)
    {
        SET_BIT(RCC->APB2RSTR, periphs);
    }
    void APB2GRP1ReleaseReset(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB2RSTR, periphs);
    }
    void APB2GRP1EnableClockSleep(RCCAPB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB2LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB2LPENR, periphs);
        (void)tmpreg;
    }
    void APB2GRP1DisableClockSleep(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB2LPENR, periphs);
    }

    /** @defgroup EF_APB4 APB4
     * @{
     */
    void APB4GRP1EnableClock(RCCAPB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB4ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB4ENR, periphs);
        (void)tmpreg;
    }
    bool APB4GRP1IsEnabledClock(RCCAPB4GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC->APB4ENR, periphs) == periphs) ? true : false);
    }
    void APB4GRP1DisableClock(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB4ENR, periphs);
    }
    void APB4GRP1ForceReset(RCCAPB4GRP1PerClkType periphs)
    {
        SET_BIT(RCC->APB4RSTR, periphs);
    }
    void APB4GRP1ReleaseReset(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB4RSTR, periphs);
    }
    void APB4GRP1EnableClockSleep(RCCAPB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->APB4LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->APB4LPENR, periphs);
        (void)tmpreg;
    }
    void APB4GRP1DisableClockSleep(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC->APB4LPENR, periphs);
    }
    /** @defgroup BUS_LL_EF_CLKAM CLKAM
     * @{
     */
    void CLKAMEnable(RCCAMPerClkType periphs)
    {
        __IO uint32_t tmpreg;

        #if defined(RCC_D3AMR_BDMAAMEN)
        SET_BIT(RCC->D3AMR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->D3AMR, periphs);
        #else
        SET_BIT(RCC->SRDAMR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->SRDAMR, periphs);
        #endif /* RCC_D3AMR_BDMAAMEN */
        (void)tmpreg;
    }
    void CLKAMDisable(RCCAMPerClkType periphs)
    {
        #if defined(RCC_D3AMR_BDMAAMEN)
        CLEAR_BIT(RCC->D3AMR, periphs);
        #else
        CLEAR_BIT(RCC->SRDAMR, periphs);
        #endif /* RCC_D3AMR_BDMAAMEN */
    }

    /** @defgroup EF_CKGA CKGA
     * @{
     */

    #if defined(RCC_CKGAENR_AXICKG)
    void CKGAEnable(RCCCKGAPerType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC->CKGAENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC->CKGAENR, periphs);
        (void)tmpreg;
    }
    #endif /* RCC_CKGAENR_AXICKG */

    #if defined(RCC_CKGAENR_AXICKG)
    void CKGADisable(RCCCKGAPerType periphs)
    {
        CLEAR_BIT(RCC->CKGAENR, periphs);
    }
    #endif /* RCC_CKGAENR_AXICKG */

    #if defined(DUAL_CORE)
    /** @addtogroup EF_AHB3 AHB3
     * @{
     */
    void C1AHB3GRP1EnableClock(RCCAHB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB3ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB3ENR, periphs);
        (void)tmpreg;
    }
    bool C1AHB3GRP1IsEnabledClock(RCCAHB3GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->AHB3ENR, periphs) == periphs) ? true : false);
    }
    void C1AHB3GRP1DisableClock(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB3ENR, periphs);
    }
    void C1AHB3GRP1EnableClockSleep(RCCAHB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB3LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB3LPENR, periphs);
        (void)tmpreg;
    }
    void C1AHB3GRP1DisableClockSleep(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB3LPENR, periphs);
    }
    /** @addtogroup EF_AHB1 AHB1
     * @{
     */
    void C1AHB1GRP1EnableClock(RCCAHB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB1ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB1ENR, periphs);
        (void)tmpreg;
    }
    bool C1AHB1GRP1IsEnabledClock(RCCAHB1GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->AHB1ENR, periphs) == periphs) ? true : false);
    }
    void C1AHB1GRP1DisableClock(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB1ENR, periphs);
    }
    void LLC1AHB1GRP1EnableClockSleep(RCCAHB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB1LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB1LPENR, periphs);
        (void)tmpreg;
    }
    void C1AHB1GRP1DisableClockSleep(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB1LPENR, periphs);
    }

    /** @addtogroup EF_AHB2 AHB2
     * @{
     */
    void C1AHB2GRP1EnableClock(RCCAHB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB2ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB2ENR, periphs);
        (void)tmpreg;
    }
    bool C1AHB2GRP1IsEnabledClock(RCCAHB2GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->AHB2ENR, periphs) == periphs) ? true : false);
    }
    void C1AHB2GRP1DisableClock(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB2ENR, periphs);
    }
    void C1AHB2GRP1EnableClockSleep(RCCAHB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB2LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB2LPENR, periphs);
        (void)tmpreg;
    }
    void C1AHB2GRP1DisableClockSleep(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB2LPENR, periphs);
    }
    /** @addtogroup EF_AHB4 AHB4
     * @{
     */
    void C1AHB4GRP1EnableClock(RCCAHB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB4ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB4ENR, periphs);
        (void)tmpreg;
    }
    bool C1AHB4GRP1IsEnabledClock(RCCAHB4GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->AHB4ENR, periphs) == periphs) ? true : false);
    }
    void C1AHB4GRP1DisableClock(RCCAHB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB4ENR, periphs);
    }
    void C1AHB4GRP1EnableClockSleep(RCCAHB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->AHB4LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->AHB4LPENR, periphs);
        (void)tmpreg;
    }
    void C1AHB4GRP1DisableClockSleep(RCCAHB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->AHB4LPENR, periphs);
    }

    /** @addtogroup BUS_LL_EF_APB3 APB3
     * @{
     */
    void C1APB3GRP1EnableClock(RCCAPB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB3ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB3ENR, periphs);
        (void)tmpreg;
    }
    bool C1APB3GRP1IsEnabledClock(RCCAPB3GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->APB3ENR, periphs) == periphs) ? true : false);
    }
    void C1APB3GRP1DisableClock(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB3ENR, periphs);
    }
    void C1APB3GRP1EnableClockSleep(RCCAPB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB3LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB3LPENR, periphs);
        (void)tmpreg;
    }
    void C1APB3GRP1DisableClockSleep(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB3LPENR, periphs);
    }
    /** @addtogroup EF_APB1 APB1
     * @{
     */
    void C1APB1GRP1EnableClock(RCCAPB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB1LENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB1LENR, periphs);
        (void)tmpreg;
    }
    bool C1APB1GRP1IsEnabledClock(RCCAPB1GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->APB1LENR, periphs) == periphs) ? true : false);
    }
    void C1APB1GRP1DisableClock(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB1LENR, periphs);
    }
    void C1APB1GRP1EnableClockSleep(RCCAPB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB1LLPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB1LLPENR, periphs);
        (void)tmpreg;
    }
    void C1APB1GRP1DisableClockSleep(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB1LLPENR, periphs);
    }
    void C1APB1GRP2EnableClock(RCCAPB1GRP2PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB1HENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB1HENR, periphs);
        (void)tmpreg;
    }
    bool C1APB1GRP2IsEnabledClock(RCCAPB1GRP2PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->APB1HENR, periphs) == periphs) ? true : false);
    }
    void C1APB1GRP2DisableClock(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB1HENR, periphs);
    }
    void C1APB1GRP2EnableClockSleep(RCCAPB1GRP2PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB1HLPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB1HLPENR, periphs);
        (void)tmpreg;
    }
    void C1APB1GRP2DisableClockSleep(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB1HLPENR, periphs);
    }
    /** @addtogroup EF_APB2 APB2
     * @{
     */
    void C1APB2GRP1EnableClock(RCCAPB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB2ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB2ENR, periphs);
        (void)tmpreg;
    }
    bool C1APB2GRP1IsEnabledClock(uint32_t periphs)
    {
        return ((READ_BIT(RCC_C1->APB2ENR, periphs) == periphs) ? true : false);
    }
    void C1APB2GRP1DisableClock(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB2ENR, periphs);
    }
    void C1APB2GRP1EnableClockSleep(uint32_t periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB2LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB2LPENR, periphs);
        (void)tmpreg;
    }
    void C1APB2GRP1DisableClockSleep(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB2LPENR, periphs);
    }
    /** @addtogroup EF_APB4 APB4
     * @{
     */
    void C1APB4GRP1EnableClock(RCCAPB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB4ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB4ENR, periphs);
        (void)tmpreg;
    }
    bool C1APB4GRP1IsEnabledClock(RCCAPB4GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C1->APB4ENR, periphs) == periphs) ? true : false);
    }
    void C1APB4GRP1DisableClock(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB4ENR, periphs);
    }
    void LL_C1_APB4_GRP1_EnableClockSleep(RCCAPB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C1->APB4LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C1->APB4LPENR, periphs);
        (void)tmpreg;
    }
    void C1APB4GRP1DisableClockSleep(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C1->APB4LPENR, periphs);
    }
    /** @addtogroup EF_AHB3 AHB3
     * @{
     */
    void C2AHB3GRP1EnableClock(RCCAHB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB3ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB3ENR, periphs);
        (void)tmpreg;
    }
    bool C2AHB3GRP1IsEnabledClock(RCCAHB3GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->AHB3ENR, periphs) == periphs) ? true : false);
    }
    void C2AHB3GRP1DisableClock(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB3ENR, periphs);
    }
    void C2AHB3GRP1EnableClockSleep(RCCAHB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB3LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB3LPENR, periphs);
        (void)tmpreg;
    }
    void C2AHB3GRP1DisableClockSleep(RCCAHB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB3LPENR, periphs);
    }
    /** @addtogroup EF_AHB1 AHB1
     * @{
     */
    void C2AHB1GRP1EnableClock(RCCAHB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB1ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB1ENR, periphs);
        (void)tmpreg;
    }
    bool C2AHB1GRP1IsEnabledClock(RCCAHB1GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->AHB1ENR, periphs) == periphs) ? true : false);
    }
    void C2AHB1GRP1DisableClock(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB1ENR, periphs);
    }
    void C2AHB1GRP1EnableClockSleep(RCCAHB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB1LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB1LPENR, periphs);
        (void)tmpreg;
    }
    void C2AHB1GRP1DisableClockSleep(RCCAHB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB1LPENR, periphs);
    }
    /** @addtogroup EF_AHB2 AHB2
     * @{
     */
    void C2AHB2GRP1EnableClock(RCCAHB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB2ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB2ENR, periphs);
        (void)tmpreg;
    }
    bool C2AHB2GRP1IsEnabledClock(RCCAHB2GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->AHB2ENR, periphs) == periphs) ? true : false);
    }
    void C2AHB2GRP1DisableClock(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB2ENR, periphs);
    }
    void C2AHB2GRP1EnableClockSleep(RCCAHB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB2LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB2LPENR, periphs);
        (void)tmpreg;
    }
    void C2AHB2GRP1DisableClockSleep(RCCAHB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB2LPENR, periphs);
    }
    /** @addtogroup EF_AHB4 AHB4
     * @{
     */
    void C2AHB4GRP1EnableClock(RCCAHB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB4ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB4ENR, periphs);
        (void)tmpreg;
    }
    bool C2AHB4GRP1IsEnabledClock(RCCAHB4GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->AHB4ENR, periphs) == periphs) ? true : false);
    }
    void C2AHB4GRP1_DisableClock(uint32_t periphs)
    {
        CLEAR_BIT(RCC_C2->AHB4ENR, periphs);
    }
    void C2AHB4GRP1EnableClockSleep(RCCAHB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->AHB4LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->AHB4LPENR, periphs);
        (void)tmpreg;
    }
    void C2AHB4GRP1DisableClockSleep(RCCAHB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->AHB4LPENR, periphs);
    }
    /** @addtogroup EF_APB3 APB3
     * @{
     */
    void C2APB3GRP1EnableClock(RCCAPB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB3ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB3ENR, periphs);
        (void)tmpreg;
    }
    bool C2APB3GRP1IsEnabledClock(RCCAPB3GRP1PerClkTypes periphs)
    {
        return ((READ_BIT(RCC_C2->APB3ENR, periphs) == periphs) ? true : false);
    }
    void C2APB3GRP1DisableClock(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB3ENR, periphs);
    }
    void C2APB3GRP1EnableClockSleep(RCCAPB3GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB3LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB3LPENR, periphs);
        (void)tmpreg;
    }
    void C2APB3GRP1DisableClockSleep(RCCAPB3GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB3LPENR, periphs);
    }
    /** @addtogroup EF_APB1 APB1
     * @{
     */
    void C2APB1GRP1EnableClock(RCCAPB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB1LENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB1LENR, periphs);
        (void)tmpreg;
    }
    bool C2APB1GRP1IsEnabledClock(RCCAPB1GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->APB1LENR, periphs) == periphs) ? true : false);
    }
    void C2APB1GRP1DisableClock(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB1LENR, periphs);
    }
    void C2APB1GRP1EnableClockSleep(RCCAPB1GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB1LLPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB1LLPENR, periphs);
        (void)tmpreg;
    }
    void C2APB1GRP1DisableClockSleep(RCCAPB1GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB1LLPENR, periphs);
    }
    void C2APB1GRP2EnableClock(RCCAPB1GRP2PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB1HENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB1HENR, periphs);
        (void)tmpreg;
    }
    bool C2APB1GRP2IsEnabledClock(RCCAPB1GRP2PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->APB1HENR, periphs) == periphs) ? true : false);
    }
    void C2APB1GRP2DisableClock(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB1HENR, periphs);
    }
    void C2APB1GRP2EnableClockSleep(RCCAPB1GRP2PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB1HLPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB1HLPENR, periphs);
        (void)tmpreg;
    }
    void C2APB1GRP2DisableClockSleep(RCCAPB1GRP2PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB1HLPENR, periphs);
    }
    /** @addtogroup EF_APB2 APB2
     * @{
     */
    void C2APB2GRP1EnableClock(RCCAPB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB2ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB2ENR, periphs);
        (void)tmpreg;
    }
    bool C2APB2GRP1IsEnabledClock(RCCAPB2GRP1PerClkType periphs)
    {
        return ((READ_BIT(RCC_C2->APB2ENR, periphs) == periphs) ? true : false);
    }
    void C2APB2GRP1DisableClock(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB2ENR, periphs);
    }
    void C2APB2GRP1EnableClockSleep(RCCAPB2GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB2LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB2LPENR, periphs);
        (void)tmpreg;
    }
    void C2APB2GRP1DisableClockSleep(RCCAPB2GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB2LPENR, periphs);
    }
    /** @addtogroup EF_APB4 APB4
     * @{
     */
    void C2APB4GRP1EnableClock(uint32_t periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB4ENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB4ENR, periphs);
        (void)tmpreg;
    }
    bool C2APB4GRP1IsEnabledClock(uint32_t periphs)
    {
        return ((READ_BIT(RCC_C2->APB4ENR, periphs) == periphs) ? true : false);
    }
    void LL_C2_APB4_GRP1_DisableClock(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB4ENR, periphs);
    }
    void C2APB4GRP1EnableClockSleep(RCCAPB4GRP1PerClkType periphs)
    {
        __IO uint32_t tmpreg;
        SET_BIT(RCC_C2->APB4LPENR, periphs);
        /* Delay after an RCC peripheral clock enabling */
        tmpreg = READ_BIT(RCC_C2->APB4LPENR, periphs);
        (void)tmpreg;
    }
    void C2APB4GRP1DisableClockSleep(RCCAPB4GRP1PerClkType periphs)
    {
        CLEAR_BIT(RCC_C2->APB4LPENR, periphs);
    }
#endif /*DUAL_CORE*/
    /**
      * @brief  Return SYSTEM clock frequency
      * @retval SYSTEM clock frequency (in Hz)
      */
    uint32_t GetSystemClockFreq(void)
    {
      uint32_t frequency = 0U;
      PLLClocksTypeDef PLL_Clocks;

      /* Get SYSCLK source -------------------------------------------------------*/
      switch (GetSysClkSource())
      {
        /* No check on Ready: Won't be selected by hardware if not */
        case RCC_SYS_CLKSOURCE_STATUS_HSI:
          frequency = HSI_VALUE >> (HSIGetDivider() >> RCC_CR_HSIDIV_Pos);
          break;

        case RCC_SYS_CLKSOURCE_STATUS_CSI:
          frequency = CSI_VALUE;
          break;

        case RCC_SYS_CLKSOURCE_STATUS_HSE:
          frequency = HSE_VALUE;
          break;

        case RCC_SYS_CLKSOURCE_STATUS_PLL1:
          GetPLL1ClockFreq(&PLL_Clocks);
          frequency = PLL_Clocks.PLL_P_Frequency;
          break;

        default:
          /* Nothing to do */
          break;
      }

      return frequency;
    }

    /**
      * @brief  Return HCLK clock frequency
      * @param  SYSCLK_Frequency SYSCLK clock frequency
      * @retval HCLK clock frequency (in Hz)
      */
    uint32_t GetHCLKClockFreq()
    {
      /* HCLK clock frequency */
      return RCCCalcHclkFreqHz(GetSystemClockFreq(), GetAHBPrescaler());
    }
    /**
      * @brief  Return PCLK1 clock frequency
      * @param  HCLK_Frequency HCLK clock frequency
      * @retval PCLK1 clock frequency (in Hz)
      */
    uint32_t GetPCLK1ClockFreq()
    {
      /* PCLK1 clock frequency */
      return RCCCalcPclk1FreqHz(GetHCLKClockFreq(), GetAPB1Prescaler());
    }
    /**
      * @brief  Return PCLK2 clock frequency
      * @param  HCLK_Frequency HCLK clock frequency
      * @retval PCLK2 clock frequency (in Hz)
      */
    uint32_t GetPCLK2ClockFreq()
    {
      /* PCLK2 clock frequency */
      return RCCCalcPclk2FreqHz(GetHCLKClockFreq(), GetAPB2Prescaler());
    }
    /**
      * @brief  Return PCLK3 clock frequency
      * @param  HCLK_Frequency HCLK clock frequency
      * @retval PCLK3 clock frequency (in Hz)
      */
    uint32_t GetPCLK3ClockFreq()
    {
      /* PCLK3 clock frequency */
      return RCCCalcPclk3FreqHz(GetHCLKClockFreq(), GetAPB3Prescaler());
    }

    /**
      * @brief  Return PCLK4 clock frequency
      * @param  HCLK_Frequency HCLK clock frequency
      * @retval PCLK4 clock frequency (in Hz)
      */
    uint32_t GetPCLK4ClockFreq()
    {
      /* PCLK4 clock frequency */
      return RCCCalcPclk4FreqHz(GetHCLKClockFreq(), GetAPB4Prescaler());
    }
private:
    RCCControl()
    {

    }
    ~RCCControl()
    {

    }
    RCCControl(const RCCControl&) = delete;
    RCCControl(RCCControl&&) = delete;
    RCCControl& operator=(const RCCControl&) = delete;
    RCCControl& operator=(RCCControl&&) = delete;
    /** @defgroup RCC_LL_EM_CALC_FREQ Calculate frequencies
      * @{
      */
#if defined(RCC_D1CFGR_D1CPRE)
    inline uint32_t RCCCalcSysFreqHz(uint32_t sysInputClkFreq, RCCSysClkPrescaler sysPrescaler)
    {
        return ((sysInputClkFreq) >> ((PrescTable[((sysPrescaler) & RCC_D1CFGR_D1CPRE) >>  RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU));
    }
#else
    inline uint32_t RCCCalcSysFreqHz(uint32_t sysInputClkFreq, RCCSysClkPrescaler sysPrescaler)
    {
        return ((sysInputClkFreq) >> ((PrescTable[((sysPrescaler) & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU));
    }
#endif /* RCC_D1CFGR_D1CPRE */

#if defined(RCC_D1CFGR_HPRE)
    inline uint32_t RCCCalcHclkFreqHz(uint32_t sysClkFreq, RCCAHBPrescaler hPrescaler)
    {
        return ((sysClkFreq) >> ((PrescTable[((hPrescaler) & RCC_D1CFGR_HPRE) >>  RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    }
#else
    inline uint32_t RCCCalcHclkFreqHz(uint32_t sysClkFreq, RCCAHBPrescaler hPrescaler)
    {
        return ((sysClkFreq) >> ((PrescTable[((hPrescaler) & RCC_CDCFGR1_HPRE) >>  RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
    }
#endif  /* RCC_D1CFGR_HPRE */

#if defined(RCC_D2CFGR_D2PPRE1)
    inline uint32_t RCCCalcPclk1FreqHz(uint32_t hClkFreq, RCCAPB1Prescaler APB1Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB1Prescaler) & RCC_D2CFGR_D2PPRE1) >>  RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
    }
#else
    inline uint32_t RCCCalcPclk1FreqHz(uint32_t hClkFreq, RCCAPB1Prescaler APB1Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB1Prescaler) & RCC_CDCFGR2_CDPPRE1) >>  RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
    }
#endif /* RCC_D2CFGR_D2PPRE1 */

#if defined(RCC_D2CFGR_D2PPRE2)
    inline uint32_t RCCCalcPclk2FreqHz(uint32_t hClkFreq, RCCAPB2Prescaler APB2Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB2Prescaler) & RCC_D2CFGR_D2PPRE2) >>  RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
    }
#else
    inline uint32_t RCCCalcPclk2FreqHz(uint32_t hClkFreq, RCCAPB2Prescaler APB2Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB2Prescaler) & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
    }
#endif /* RCC_D2CFGR_D2PPRE2 */

#if defined(RCC_D1CFGR_D1PPRE)
    inline uint32_t RCCCalcPclk3FreqHz(uint32_t hClkFreq, RCCAPB3Prescaler APB3Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB3Prescaler) & RCC_D1CFGR_D1PPRE) >>  RCC_D1CFGR_D1PPRE_Pos]) & 0x1FU));
    }
#else
    inline uint32_t RCCCalcPclk3FreqHz(uint32_t hClkFreq, RCCAPB3Prescaler APB3Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB3Prescaler) & RCC_CDCFGR1_CDPPRE) >> RCC_CDCFGR1_CDPPRE_Pos]) & 0x1FU));
    }
#endif /* RCC_D1CFGR_D1PPRE */

    /**
      * @brief  Helper macro to calculate the PCLK4 frequency (ABP4)
      * @param  __HCLKFREQ__ HCLK frequency
      * @param  __APB4PRESCALER__ This parameter can be one of the following values:
      *         @arg @ref APB4_DIV_1
      *         @arg @ref APB4_DIV_2
      *         @arg @ref APB4_DIV_4
      *         @arg @ref APB4_DIV_8
      *         @arg @ref APB4_DIV_16
      * @retval PCLK1 clock frequency (in Hz)
      */
#if defined(RCC_D3CFGR_D3PPRE)
    inline uint32_t RCCCalcPclk4FreqHz(uint32_t hClkFreq, RCCAPB4Prescaler APB4Prescaler)
    {
        return ((hClkFreq) >> ((PrescTable[((APB4Prescaler) & RCC_D3CFGR_D3PPRE) >>  RCC_D3CFGR_D3PPRE_Pos]) & 0x1FU));
    }
#else
    inline uint32_t RCCCalcPclk4FreqHz(uint32_t hClkFreq, RCCAPB4Prescaler APB4Prescaler)
    {
        return ((__HCLKFREQ__) >> ((PrescTable[((__APB4PRESCALER__) & RCC_SRDCFGR_SRDPPRE) >>  RCC_SRDCFGR_SRDPPRE_Pos]) & 0x1FU));
    }
#endif /* RCC_D3CFGR_D3PPRE */
private:
    static const uint8_t PrescTable[16];
};
const uint8_t RCCControl::PrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};